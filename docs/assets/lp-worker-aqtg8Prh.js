function kt(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var ot={exports:{}},Ft=ot.exports,vt;function zt(){return vt||(vt=1,(function(n){(function(t,e){n.exports?n.exports=e():t.log=e()})(Ft,function(){var t=function(){},e="undefined",i=typeof window!==e&&typeof window.navigator!==e&&/Trident\/|MSIE /.test(window.navigator.userAgent),s=["trace","debug","info","warn","error"],o={},r=null;function a(p,v){var g=p[v];if(typeof g.bind=="function")return g.bind(p);try{return Function.prototype.bind.call(g,p)}catch{return function(){return Function.prototype.apply.apply(g,[p,arguments])}}}function l(){console.log&&(console.log.apply?console.log.apply(console,arguments):Function.prototype.apply.apply(console.log,[console,arguments])),console.trace&&console.trace()}function h(p){return p==="debug"&&(p="log"),typeof console===e?!1:p==="trace"&&i?l:console[p]!==void 0?a(console,p):console.log!==void 0?a(console,"log"):t}function u(){for(var p=this.getLevel(),v=0;v<s.length;v++){var g=s[v];this[g]=v<p?t:this.methodFactory(g,p,this.name)}if(this.log=this.debug,typeof console===e&&p<this.levels.SILENT)return"No console available for logging"}function m(p){return function(){typeof console!==e&&(u.call(this),this[p].apply(this,arguments))}}function c(p,v,g){return h(p)||m.apply(this,arguments)}function f(p,v){var g=this,w,y,x,b="loglevel";typeof p=="string"?b+=":"+p:typeof p=="symbol"&&(b=void 0);function I(S){var O=(s[S]||"silent").toUpperCase();if(!(typeof window===e||!b)){try{window.localStorage[b]=O;return}catch{}try{window.document.cookie=encodeURIComponent(b)+"="+O+";"}catch{}}}function C(){var S;if(!(typeof window===e||!b)){try{S=window.localStorage[b]}catch{}if(typeof S===e)try{var O=window.document.cookie,P=encodeURIComponent(b),E=O.indexOf(P+"=");E!==-1&&(S=/^([^;]+)/.exec(O.slice(E+P.length+1))[1])}catch{}return g.levels[S]===void 0&&(S=void 0),S}}function V(){if(!(typeof window===e||!b)){try{window.localStorage.removeItem(b)}catch{}try{window.document.cookie=encodeURIComponent(b)+"=; expires=Thu, 01 Jan 1970 00:00:00 UTC"}catch{}}}function B(S){var O=S;if(typeof O=="string"&&g.levels[O.toUpperCase()]!==void 0&&(O=g.levels[O.toUpperCase()]),typeof O=="number"&&O>=0&&O<=g.levels.SILENT)return O;throw new TypeError("log.setLevel() called with invalid level: "+S)}g.name=p,g.levels={TRACE:0,DEBUG:1,INFO:2,WARN:3,ERROR:4,SILENT:5},g.methodFactory=v||c,g.getLevel=function(){return x??y??w},g.setLevel=function(S,O){return x=B(S),O!==!1&&I(x),u.call(g)},g.setDefaultLevel=function(S){y=B(S),C()||g.setLevel(S,!1)},g.resetLevel=function(){x=null,V(),u.call(g)},g.enableAll=function(S){g.setLevel(g.levels.TRACE,S)},g.disableAll=function(S){g.setLevel(g.levels.SILENT,S)},g.rebuild=function(){if(r!==g&&(w=B(r.getLevel())),u.call(g),r===g)for(var S in o)o[S].rebuild()},w=B(r?r.getLevel():"WARN");var A=C();A!=null&&(x=B(A)),u.call(g)}r=new f,r.getLogger=function(v){if(typeof v!="symbol"&&typeof v!="string"||v==="")throw new TypeError("You must supply a name when creating a logger.");var g=o[v];return g||(g=o[v]=new f(v,r.methodFactory)),g};var d=typeof window!==e?window.log:void 0;return r.noConflict=function(){return typeof window!==e&&window.log===r&&(window.log=d),r},r.getLoggers=function(){return o},r.default=r,r})})(ot)),ot.exports}var jt=zt(),Nt=kt(jt);class St{constructor(t,e,i,s){this.feasible=i,this.evaluation=e,this.bounded=s,this._tableau=t,this.solutionSet={}}generateSolutionSet(){const t={},e=this._tableau,i=e.varIndexByRow,s=e.variablesPerIndex,o=e.matrix,r=e.width,a=e.rhsColumn,l=e.height-1,h=Math.round(1/e.precision);for(let u=1;u<=l;u+=1){const m=i[u],c=s[m];if(c===void 0||c.isSlack===!0)continue;const f=o[u*r+a];t[c.id]=Math.round((Number.EPSILON+f)*h)/h}return t}}class Lt extends St{constructor(t,e,i,s,o){super(t,e,i,s),this.iter=o}}class pt{constructor(t=64){this.heap=new Array(t),this.size=0,this.seqCounter=0,this.pool=new Array(64),this.poolSize=0}allocEntry(t,e){if(this.poolSize>0){const i=this.pool[--this.poolSize];return i.branch=t,i.seq=e,i}return{branch:t,seq:e}}freeEntry(t){this.poolSize<256&&(this.pool[this.poolSize++]=t)}get length(){return this.size}isEmpty(){return this.size===0}clear(){this.size=0,this.seqCounter=0}isBefore(t,e){return t.branch.relaxedEvaluation!==e.branch.relaxedEvaluation?t.branch.relaxedEvaluation<e.branch.relaxedEvaluation:t.seq>e.seq}push(t){const e=this.heap;let i=this.size;this.size++,i>=e.length&&(e.length=e.length*2);const s=this.allocEntry(t,this.seqCounter++);for(;i>0;){const o=i-1>>1,r=e[o];if(!this.isBefore(s,r))break;e[i]=r,i=o}e[i]=s}pop(){if(this.size===0)return;const t=this.heap,e=t[0],i=e.branch;if(this.size--,this.freeEntry(e),this.size===0)return i;const s=t[this.size];let o=0;const r=this.size>>1;for(;o<r;){let a=(o<<1)+1,l=t[a];const h=a+1;if(h<this.size&&this.isBefore(t[h],l)&&(a=h,l=t[h]),!this.isBefore(l,s))break;t[o]=l,o=a}return t[o]=s,i}peek(){return this.size>0?this.heap[0].branch:void 0}}function mt(n,t,e){return{type:n,varIndex:t,value:e}}function ht(n,t){return{relaxedEvaluation:n,cuts:t}}function dt(){const n=(e,i)=>{var s;if(e.restore(),e.addCutConstraints(i),e.simplex(),!((s=e.model)===null||s===void 0)&&s.useMIRCuts){let o=!0;for(;o;){const r=e.computeFractionalVolume(!0);e.applyMIRCuts(),e.simplex(),e.computeFractionalVolume(!0)>=.9*r&&(o=!1)}}};return{applyCuts:n,branchAndCut:e=>{var i,s,o,r,a;const l=new pt;let h=0;const u=(s=(i=e.model)===null||i===void 0?void 0:i.tolerance)!==null&&s!==void 0?s:0;let m=!0,c=1e99;!((o=e.model)===null||o===void 0)&&o.timeout&&(c=Date.now()+e.model.timeout);let f=1/0,d=null;const p=[],v=e.optionalObjectives,g=v.length;for(let x=0;x<g;x+=1)p.push(1/0);const w=ht(-1/0,[]);let y;for(l.push(w);!l.isEmpty()&&m===!0&&Date.now()<c;){!((r=e.model)===null||r===void 0)&&r.isMinimization?y=e.bestPossibleEval*(1+u):y=e.bestPossibleEval*(1-u),u>0&&f<y&&(m=!1);const x=l.pop();if(x.relaxedEvaluation>f)continue;const b=x.cuts;if(n(e,b),h++,e.feasible===!1)continue;const I=e.evaluation;if(!(I>f)){if(I===f){let C=!0;for(let V=0;V<g;V+=1){const B=v[V].reducedCosts[0],A=p[V];if(B>A)break;if(B<A){C=!1;break}}if(C)continue}if(e.isIntegral()===!0){if(e.__isIntegral=!0,h===1){e.branchAndCutIterations=h;return}d=x,f=I;for(let C=0;C<g;C+=1)p[C]=v[C].reducedCosts[0];if(!((a=e.model)===null||a===void 0)&&a.keep_solutions){const C=e.model.tableau.getSolution(),V=C.generateSolutionSet();V.result=C.evaluation,e.model.solutions||(e.model.solutions=[]),e.model.solutions.push(V)}}else{h===1&&e.save();const C=e.getMostFractionalVar(),V=C.index,B=C.value,A=[],S=[],O=b.length;for(let j=0;j<O;j+=1){const M=b[j];M.varIndex===V?M.type==="min"?S.push(M):A.push(M):(A.push(M),S.push(M))}const P=mt("min",V,Math.ceil(B));A.push(P);const E=mt("max",V,Math.floor(B));S.push(E),l.push(ht(I,A)),l.push(ht(I,S))}}}d!==null&&n(e,d.cuts),e.branchAndCutIterations=h}}}class Ot{constructor(){this.pairs=[],this.positions=new Map}add(t,e){const i=`${t}_${e}`,s=this.pairs.length;this.pairs.push([t,e]);const o=this.positions.get(i);if(o===void 0)return this.positions.set(i,[s]),[];for(const r of o){const a=s-r;if(a>this.pairs.length-s)continue;let l=!0;for(let h=1;h<a&&r+a+h<this.pairs.length;h++){const u=this.pairs[r+h],m=this.pairs[r+a+h];if(u[0]!==m[0]||u[1]!==m[1]){l=!1;break}}if(l)return[r,a]}return o.push(s),[]}}function $t(){return this.bounded=!0,this.phase1(),this.feasible===!0&&this.phase2(),this}function Dt(){const n=this.matrix,t=this.width,e=this.rhsColumn,i=t-1,s=this.height-1,r=-this.precision;let a=0;const l=1e4;for(;a<l;){let h=0,u=r;for(let d=1;d<=s;d++){const p=n[d*t+e];p<u&&(u=p,h=d)}if(h===0)return this.feasible=!0,this.setEvaluation(),a;let m=0,c=1/0;const f=h*t;for(let d=1;d<=i;d++){const p=n[f+d];if(p<r){const v=n[d];if(v>=r){const g=v/-p;g<c&&(c=g,m=d)}}}if(m===0)return this.feasible=!1,-1;this.pivot(h,m),a++}return this.feasible=!1,a}function qt(){const t=this.model.checkForCycles?new Ot:null,e=this.matrix,i=this.width,s=this.rhsColumn,o=this.width-1,r=this.height-1,l=-this.precision,h=this.unrestrictedVars,u=this.varIndexByRow,m=this.varIndexByCol;let c,f=0;for(;;){let d=0,p=l;for(let y=1;y<=r;y++){const x=e[y*i+s];x<p&&(p=x,d=y)}if(d===0)return this.feasible=!0,f;let v=0,g=-1/0;const w=d*i;for(let y=1;y<=o;y++){const x=e[w+y];if(c=h[m[y]]===!0,c||x<l){const b=-e[y]/x;g<b&&(g=b,v=y)}}if(v===0)return this.feasible=!1,f;if(t){const y=t.add(u[d],m[v]);if(y.length>0)return this.model.messages.push("Cycle in phase 1"),this.model.messages.push("Start :"+y[0]),this.model.messages.push("Length :"+y[1]),this.feasible=!1,f}this.pivot(d,v),f+=1}}function Ut(){const t=this.model.checkForCycles?new Ot:null,e=this.matrix,i=this.width,s=this.rhsColumn,o=this.width-1,r=this.height-1,a=this.precision,l=-a,h=this.optionalObjectives.length;let u=null;const m=this.unrestrictedVars,c=this.varIndexByCol,f=this.varIndexByRow;let d=0,p,v;const g=o,w=this.pricingBatchSize>0?this.pricingBatchSize:Math.min(500,Math.max(50,Math.floor(Math.sqrt(g)))),y=g>w*2;for(;;){h>0&&(u=[]);let x=0,b=a,I=!1;if(y){const B=this.pricingBatchStart;let A=0;const S=Math.ceil(g/w);for(;x===0&&A<S;){const O=this.pricingBatchStart,P=Math.min(O+w-1,o);for(let E=O;E<=P;E++){if(p=e[E],v=m[c[E]]===!0,h>0&&l<p&&p<a){u?.push(E);continue}if(v&&p<0){-p>b&&(b=-p,x=E,I=!0);continue}p>b&&(b=p,x=E,I=!1)}this.pricingBatchStart=P>=o?1:P+1,A++}x!==0&&(this.pricingBatchStart=B)}else for(let B=1;B<=o;B++){if(p=e[B],v=m[c[B]]===!0,h>0&&l<p&&p<a){u?.push(B);continue}if(v&&p<0){-p>b&&(b=-p,x=B,I=!0);continue}p>b&&(b=p,x=B,I=!1)}if(h>0){let B=0;for(;x===0&&u&&u.length>0&&B<h;){const A=[],S=this.optionalObjectives[B].reducedCosts;b=a;for(let O=0;O<u.length;O++){const P=u[O];if(p=S[P],v=m[c[P]]===!0,l<p&&p<a){A.push(P);continue}if(v&&p<0){-p>b&&(b=-p,x=P,I=!0);continue}p>b&&(b=p,x=P,I=!1)}u=A,B+=1}}if(x===0)return this.setEvaluation(),this.simplexIters+=1,d;let C=0,V=1/0;for(let B=1;B<=r;B++){const A=B*i,S=e[A+s],O=e[A+x];if(l<O&&O<a)continue;if(O>0&&a>S&&S>l){V=0,C=B;break}const P=I?-S/O:S/O;P>a&&V>P&&(V=P,C=B)}if(V===1/0)return this.evaluation=-1/0,this.bounded=!1,this.unboundedVarIndex=c[x],d;if(t){const B=t.add(f[C],c[x]);if(B.length>0)return this.model.messages.push("Cycle in phase 2"),this.model.messages.push("Start :"+B[0]),this.model.messages.push("Length :"+B[1]),this.feasible=!1,d}this.pivot(C,x),d+=1}}let W=new Int32Array(1024),st=new Float64Array(1024);function Wt(n,t){const e=this.matrix,i=this.width;i>W.length&&(W=new Int32Array(i*2),st=new Float64Array(i*2));const s=n*i,o=e[s+t],r=1/o,a=this.height,l=this.varIndexByRow[n],h=this.varIndexByCol[t];this.varIndexByRow[n]=h,this.varIndexByCol[t]=l,this.rowByVarIndex[h]=n,this.rowByVarIndex[l]=-1,this.colByVarIndex[h]=-1,this.colByVarIndex[l]=t;let u=0;for(let f=0;f<i;f++){const d=s+f,p=e[d];if(p>=-1e-16&&p<=1e-16)e[d]=0;else{const v=p/o;e[d]=v,W[u]=f,st[u]=v,u++}}e[s+t]=r;for(let f=0;f<a;f++)if(f!==n){const d=f*i,p=e[d+t];if(!(p>=-1e-16&&p<=1e-16)){const v=p;if(v>=-1e-16&&v<=1e-16)v!==0&&(e[d+t]=0);else{for(let g=0;g<u;g++){const w=W[g],y=st[g];y>=-1e-16&&y<=1e-16?y!==0&&(e[s+w]=0):e[d+w]-=v*y}e[d+t]=-v/o}}}const m=this.optionalObjectives,c=m.length;if(c>0)for(let f=0;f<c;f++){const d=m[f].reducedCosts,p=d[t];if(p!==0){for(let v=0;v<u;v++){const g=W[v];d[g]-=p*st[v]}d[t]=-p*r}}}function Ht(n){for(let t=0;t<n.length-1;t++)for(let e=t+1;e<n.length;e++){const i=n[t],s=n[e];if(i[0]===s[0]&&i[1]===s[1]){if(e-t>n.length-e)break;let o=!0;for(let r=1;r<e-t;r++){const a=n[t+r],l=n[e+r];if(a[0]!==l[0]||a[1]!==l[1]){o=!1;break}}if(o)return[t,e-t]}}return[]}class at{constructor(t,e,i=1e-12){this.nRows=t,this.nCols=e,this.precision=i,this.values=[],this.rowIndices=[],this.colPointers=new Array(e+1).fill(0),this.workVector=new Float64Array(Math.max(t,e)),this.workIndices=[]}static fromDense(t,e,i,s=1e-12){const o=new at(i,e,s),r=[],a=[],l=[0];for(let h=0;h<e;h++){for(let u=0;u<i;u++){const m=t[u*e+h];(m<-s||m>s)&&(r.push(m),a.push(u))}l.push(r.length)}return o.values=r,o.rowIndices=a,o.colPointers=l,o}toDense(){const t=new Float64Array(this.nRows*this.nCols);for(let e=0;e<this.nCols;e++){const i=this.colPointers[e],s=this.colPointers[e+1];for(let o=i;o<s;o++){const r=this.rowIndices[o];t[r*this.nCols+e]=this.values[o]}}return t}get(t,e){const i=this.colPointers[e],s=this.colPointers[e+1];let o=i,r=s;for(;o<r;){const a=o+r>>>1;this.rowIndices[a]<t?o=a+1:r=a}return o<s&&this.rowIndices[o]===t?this.values[o]:0}set(t,e,i){const s=this.colPointers[e],o=this.colPointers[e+1],r=i>=-this.precision&&i<=this.precision;let a=s,l=o;for(;a<l;){const u=a+l>>>1;this.rowIndices[u]<t?a=u+1:l=u}if(a<o&&this.rowIndices[a]===t)if(r){this.values.splice(a,1),this.rowIndices.splice(a,1);for(let u=e+1;u<=this.nCols;u++)this.colPointers[u]--}else this.values[a]=i;else if(!r){this.values.splice(a,0,i),this.rowIndices.splice(a,0,t);for(let u=e+1;u<=this.nCols;u++)this.colPointers[u]++}}getColumn(t){const e=this.colPointers[t],i=this.colPointers[t+1],s=i-e;return{indices:this.rowIndices.slice(e,i),values:this.values.slice(e,i),length:s}}getRow(t){const e=[],i=[];for(let s=0;s<this.nCols;s++){const o=this.get(t,s);o!==0&&(e.push(s),i.push(o))}return{indices:e,values:i,length:e.length}}getRowDense(t,e){const i=[];e.fill(0,0,this.nCols);for(let s=0;s<this.nCols;s++){const o=this.colPointers[s],r=this.colPointers[s+1];let a=o,l=r;for(;a<l;){const h=a+l>>>1;this.rowIndices[h]<t?a=h+1:l=h}a<r&&this.rowIndices[a]===t&&(e[s]=this.values[a],i.push(s))}return i}addRow(){this.nRows++,this.workVector.length<this.nRows&&(this.workVector=new Float64Array(this.nRows*2))}addColumn(){this.colPointers.push(this.colPointers[this.nCols]),this.nCols++,this.workVector.length<this.nCols&&(this.workVector=new Float64Array(this.nCols*2))}setColumn(t,e){const i=this.colPointers[t],s=this.colPointers[t+1],o=s-i,r=e.length,a=r-o;if(a!==0){if(a>0)for(let h=0;h<a;h++)this.values.splice(s,0,0),this.rowIndices.splice(s,0,0);else this.values.splice(i,-a),this.rowIndices.splice(i,-a);for(let h=t+1;h<=this.nCols;h++)this.colPointers[h]+=a}const l=this.colPointers[t];for(let h=0;h<r;h++)this.values[l+h]=e.values[h],this.rowIndices[l+h]=e.indices[h]}get nnz(){return this.values.length}get density(){return this.nnz/(this.nRows*this.nCols)}scaleRow(t,e){for(let i=0;i<this.nCols;i++){const s=this.colPointers[i],o=this.colPointers[i+1];for(let r=s;r<o;r++)if(this.rowIndices[r]===t){this.values[r]*=e;break}}}addScaledRow(t,e,i){if(i>=-this.precision&&i<=this.precision)return;const s=this.getRowDense(e,this.workVector);for(const o of s){const r=this.workVector[o],a=this.get(t,o)+i*r;this.set(t,o,a)}}pivot(t,e){const i=this.get(t,e);if(i===0)throw new Error("Cannot pivot on zero element");const s=1/i,o=this.getRowDense(t,this.workVector);for(const a of o)this.workVector[a]*=s;this.workVector[e]=s;for(const a of o)this.set(t,a,this.workVector[a]);this.set(t,e,s);const r=this.getColumn(e);for(let a=0;a<r.length;a++){const l=r.indices[a];if(l===t)continue;const h=r.values[a];if(!(h>=-this.precision&&h<=this.precision)){for(const u of o){if(u===e)continue;const m=this.workVector[u];if(m>=-this.precision&&m<=this.precision)continue;const c=this.get(l,u)-h*m;this.set(l,u,c)}this.set(l,e,-h*s)}}return o}clone(){const t=new at(this.nRows,this.nCols,this.precision);return t.values=this.values.slice(),t.rowIndices=this.rowIndices.slice(),t.colPointers=this.colPointers.slice(),t}}function Zt(){const n=at.fromDense(this.matrix,this.width,this.height,this.precision);this.bounded=!0,Yt.call(this,n),this.feasible===!0&&Jt.call(this,n);const t=n.toDense();return this.matrix.set(t),this}function Yt(n){const t=this.model.checkForCycles,e=[],i=this.rhsColumn,s=this.width-1,o=this.height-1,r=this.precision;let a,l=0;for(;;){let h=0,u=-r;for(let d=1;d<=o;d++){const p=n.get(d,i);p<u&&(u=p,h=d)}if(h===0)return this.feasible=!0,l;let m=0,c=-1/0;const f=n.getRow(h);for(let d=0;d<f.length;d++){const p=f.indices[d];if(p===0||p===i)continue;const v=f.values[d];if(a=this.unrestrictedVars[this.varIndexByCol[p]]===!0,a||v<-r){const w=-n.get(0,p)/v;c<w&&(c=w,m=p)}}for(let d=1;d<=s;d++){if(d===i)continue;const p=n.get(h,d);if(a=this.unrestrictedVars[this.varIndexByCol[d]]===!0,a||p<-r){const g=-n.get(0,d)/p;c<g&&(c=g,m=d)}}if(m===0)return this.feasible=!1,l;if(t&&(e.push([this.varIndexByRow[h],this.varIndexByCol[m]]),this.checkForCycles(e).length>0))return this.model.messages.push("Cycle in phase 1"),this.feasible=!1,l;Rt.call(this,n,h,m),l+=1}}function Jt(n){const t=this.model.checkForCycles,e=[],i=this.rhsColumn,s=this.width-1;this.height-1;const o=this.precision;this.optionalObjectives.length;let r=0,a,l;const h=Math.min(500,Math.max(50,Math.floor(Math.sqrt(s))));let u=1;for(;;){let c=0,f=o,d=!1,p=0;const v=Math.ceil(s/h);for(;c===0&&p<v;){const x=Math.min(u+h-1,s);for(let b=u;b<=x;b++)if(b!==i){if(a=n.get(0,b),l=this.unrestrictedVars[this.varIndexByCol[b]]===!0,l&&a<0){-a>f&&(f=-a,c=b,d=!0);continue}a>f&&(f=a,c=b,d=!1)}u=x>=s?1:x+1,p++}if(c===0)return this.setEvaluation(),this.simplexIters+=1,r;let g=0,w=1/0;const y=n.getColumn(c);for(let x=0;x<y.length;x++){const b=y.indices[x];if(b===0)continue;const I=y.values[x];if(I>=-o&&I<=o)continue;const C=n.get(b,i);if(I>0&&o>C&&C>-o){w=0,g=b;break}const V=d?-C/I:C/I;V>o&&w>V&&(w=V,g=b)}if(w===1/0)return this.evaluation=-1/0,this.bounded=!1,this.unboundedVarIndex=this.varIndexByCol[c],r;if(t&&(e.push([this.varIndexByRow[g],this.varIndexByCol[c]]),this.checkForCycles(e).length>0))return this.model.messages.push("Cycle in phase 2"),this.feasible=!1,r;Rt.call(this,n,g,c),r+=1}}function Rt(n,t,e){const i=this.varIndexByRow[t],s=this.varIndexByCol[e];this.varIndexByRow[t]=s,this.varIndexByCol[e]=i,this.rowByVarIndex[s]=t,this.rowByVarIndex[i]=-1,this.colByVarIndex[s]=-1,this.colByVarIndex[i]=e,n.pivot(t,e);const o=this.optionalObjectives,r=o.length;if(r>0){const a=n.get(t,e),l=n.getRow(t);for(let h=0;h<r;h++){const u=o[h].reducedCosts,m=u[e];if(m!==0){for(let c=0;c<l.length;c++){const f=l.indices[c],d=l.values[c];d!==0&&(u[f]=u[f]-m*d)}u[e]=-m*a}}}}const Kt=1/0,Qt=.1;function Gt(n){if(n.width*n.height<Kt)return!1;const e=n.matrix,i=n.width,s=1,o=Math.min(20,n.height-1);let r=0;for(let l=s;l<s+o;l++){const h=l*i;for(let u=0;u<i;u++)e[h+u]!==0&&r++}return r/(o*i)<Qt}class lt{constructor(t,e,i,s){this.id=t,this.cost=e,this.index=i,this.value=0,this.priority=s}}class Xt extends lt{constructor(t,e,i,s){super(t,e,i,s),this.isInteger=!0}}class ct extends lt{constructor(t,e){super(t,0,e,0),this.isSlack=!0}}class At{constructor(t,e){this.variable=t,this.coefficient=e}}function Mt(n,t,e){if(e===0||e==="required")return null;const i=t===void 0?1:t,s=e===void 0?1:e,o=n.isMinimization===!1?-i:i;return n.addVariable(o,"r"+n.relaxationIndex++,!1,!1,s)}class Y{constructor(t,e,i,s){this.slack=new ct("s"+i,i),this.index=i,this.model=s,this.rhs=t,this.isUpperBound=e,this.terms=[],this.termsByVarIndex={},this.relaxation=null}addTerm(t,e){const i=e.index,s=this.termsByVarIndex[i];if(s===void 0){const o=new At(e,t);this.termsByVarIndex[i]=o,this.terms.push(o);const r=this.isUpperBound===!0?-t:t;this.model.updateConstraintCoefficient(this,e,r)}else{const o=s.coefficient+t;this.setVariableCoefficient(o,e)}return this}removeTerm(t){return this}setRightHandSide(t){if(t!==this.rhs){let e=t-this.rhs;this.isUpperBound===!0&&(e=-e),this.rhs=t,this.model.updateRightHandSide(this,e)}return this}setVariableCoefficient(t,e){const i=e.index;if(i===-1){console.warn("[Constraint.setVariableCoefficient] Trying to change coefficient of inexistant variable.");return}const s=this.termsByVarIndex[i];if(s===void 0)this.addTerm(t,e);else if(t!==s.coefficient){let o=t-s.coefficient;this.isUpperBound===!0&&(o=-o),s.coefficient=t,this.model.updateConstraintCoefficient(this,e,o)}return this}relax(t,e){this.relaxation=Mt(this.model,t,e),this._relax(this.relaxation)}_relax(t){t!==null&&(this.isUpperBound?this.setVariableCoefficient(-1,t):this.setVariableCoefficient(1,t))}}class gt{constructor(t,e){this.isEquality=!0,this.upperBound=t,this.lowerBound=e,this.model=t.model,this.rhs=t.rhs,this.relaxation=null}addTerm(t,e){return this.upperBound.addTerm(t,e),this.lowerBound.addTerm(t,e),this}removeTerm(t){return this.upperBound.removeTerm(t),this.lowerBound.removeTerm(t),this}setRightHandSide(t){this.upperBound.setRightHandSide(t),this.lowerBound.setRightHandSide(t),this.rhs=t}relax(t,e){this.relaxation=Mt(this.model,t,e),this.upperBound.relaxation=this.relaxation,this.upperBound._relax(this.relaxation),this.lowerBound.relaxation=this.relaxation,this.lowerBound._relax(this.relaxation)}}class te{constructor(t){this.value=t}}function ee(n){const t=n.length,e=this.height,i=e+t,s=this.width,o=s-1,r=this.matrix,a=i*s;if(r.length<a){const h=Math.ceil(a*1.5),u=new Float64Array(h);u.set(r),this.matrix=u}const l=this.matrix;this.height=i,this.nVars=this.width+this.height-2;for(let h=0;h<t;h+=1){const u=n[h],m=e+h,c=m*s,f=u.type==="min"?-1:1,d=u.varIndex;let p=this.rowByVarIndex[d];if(p===-1){l[c+this.rhsColumn]=f*u.value;for(let v=1;v<=o;v+=1)l[c+v]=0;l[c+this.colByVarIndex[d]]=f}else{const v=p*s,g=l[v+this.rhsColumn];l[c+this.rhsColumn]=f*(u.value-g);for(let w=1;w<=o;w+=1)l[c+w]=-f*l[v+w]}p=this.getNewElementIndex(),this.varIndexByRow[m]=p,this.rowByVarIndex[p]=m,this.colByVarIndex[p]=-1,this.variablesPerIndex[p]=new ct("s"+p,p),this.nVars+=1}}function ie(n){if(n===this.costRowIndex)return!1;const t=this.width,e=this.matrix,i=n*t,s=this.variablesPerIndex[this.varIndexByRow[n]];if(s===void 0||!s.isInteger)return!1;const o=e[i+this.rhsColumn],r=o-Math.floor(o);if(r<this.precision||r>1-this.precision)return!1;const a=this.height,l=a*t,h=(a+1)*t;if(e.length<h){const c=Math.ceil(h*1.5),f=new Float64Array(c);f.set(e),this.matrix=f}const u=this.matrix;this.height+=1,this.nVars+=1;const m=this.getNewElementIndex();this.varIndexByRow[a]=m,this.rowByVarIndex[m]=a,this.colByVarIndex[m]=-1,this.variablesPerIndex[m]=new ct("s"+m,m),u[l+this.rhsColumn]=Math.floor(o);for(let c=1;c<this.varIndexByCol.length;c+=1){const f=this.variablesPerIndex[this.varIndexByCol[c]],d=u[i+c];if(f!==void 0&&f.isInteger){const p=Math.floor(d)+Math.max(0,d-Math.floor(d)-r)/(1-r);u[l+c]=p}else u[l+c]=Math.min(0,d/(1-r))}for(let c=0;c<t;c+=1)u[l+c]-=u[i+c];return!0}function se(n){if(n===this.costRowIndex)return!1;const t=this.width,e=this.matrix,i=n*t,s=this.variablesPerIndex[this.varIndexByRow[n]];if(s===void 0||!s.isInteger)return!1;const o=e[i+this.rhsColumn],r=o-Math.floor(o);if(r<this.precision||r>1-this.precision)return!1;const a=this.height,l=a*t,h=(a+1)*t;if(e.length<h){const c=Math.ceil(h*1.5),f=new Float64Array(c);f.set(e),this.matrix=f}const u=this.matrix;this.height+=1,this.nVars+=1;const m=this.getNewElementIndex();this.varIndexByRow[a]=m,this.rowByVarIndex[m]=a,this.colByVarIndex[m]=-1,this.variablesPerIndex[m]=new ct("s"+m,m),u[l+this.rhsColumn]=-r;for(let c=1;c<this.varIndexByCol.length;c+=1){const f=this.variablesPerIndex[this.varIndexByCol[c]],d=u[i+c],p=d-Math.floor(d);f!==void 0&&f.isInteger?u[l+c]=p<=r?-p:-(1-p)*r/p:u[l+c]=d>=0?-d:d*r/(1-r)}return!0}function ne(){const n=this.height;let t=0;const e=10;for(let i=1;i<n&&t<e;i++)this.addLowerBoundMIRCut(i)&&t++}function oe(n){const t=this.width;let e=this.rowByVarIndex[n];if(e===-1){const i=this.colByVarIndex[n];for(let s=1;s<this.height;s+=1){const o=this.matrix[s*t+i];if(o<-this.precision||this.precision<o){e=s;break}}this.pivot(e,i)}return e}function re(n){const t=this.width;let e=this.colByVarIndex[n];if(e===-1){const i=this.rowByVarIndex[n],s=i*t;for(let o=1;o<this.height;o+=1){const r=this.matrix[s+o];if(r<-this.precision||this.precision<r){e=o;break}}this.pivot(i,e)}return e}function ae(){const n=this.width,t=this.matrix,e=this.rhsColumn,i=this.variables.length,s=Math.round(1/this.precision);for(let o=0;o<i;o+=1){const r=this.variables[o],a=r.index,l=this.rowByVarIndex[a];if(l===-1)r.value=0;else{const h=t[l*n+e];r.value=Math.round((h+Number.EPSILON)*s)/s}}}function le(n,t){const e=this.width,i=this.matrix,s=this.rhsColumn,o=this.height-1,r=this.rowByVarIndex[n.index];if(r===-1){const a=this.colByVarIndex[n.index];for(let h=0;h<=o;h+=1){const u=h*e;i[u+s]-=t*i[u+a]}const l=this.optionalObjectives.length;if(l>0)for(let h=0;h<l;h+=1){const u=this.optionalObjectives[h].reducedCosts;u[s]-=t*u[a]}}else i[r*e+s]-=t}function ce(n,t,e){if(n.index===t.index)throw new Error("[Tableau.updateConstraintCoefficient] constraint index should not be equal to variable index !");const i=this.width,s=this.matrix,r=this.putInBase(n.index)*i,a=this.colByVarIndex[t.index];if(a===-1){const h=this.rowByVarIndex[t.index]*i;for(let u=0;u<i;u+=1)s[r+u]+=e*s[h+u]}else s[r+a]-=e}function he(n,t){const e=this.width,i=this.matrix,s=n.index,o=e-1,r=this.colByVarIndex[s];if(r===-1){const a=this.rowByVarIndex[s]*e;if(n.priority===0)for(let l=0;l<=o;l+=1)i[l]+=t*i[a+l];else{const l=this.objectivesByPriority[n.priority].reducedCosts;for(let h=0;h<=o;h+=1)l[h]+=t*i[a+h]}}else i[r]-=t}function ue(n){const t=n.isUpperBound?1:-1,e=this.height,i=this.width,s=i-1,r=(e+1)*i;if(this.matrix.length<r){const c=this.matrix.length,f=Math.max(i*16,Math.floor(c*.5)),d=c+f,p=this.matrix,v=new Float64Array(d);v.set(p),this.matrix=v}const a=this.matrix,l=e*i;for(let c=0;c<=s;c+=1)a[l+c]=0;a[l+this.rhsColumn]=t*n.rhs;const h=n.terms,u=h.length;for(let c=0;c<u;c+=1){const f=h[c],d=f.coefficient,p=f.variable.index,v=this.rowByVarIndex[p];if(v===-1)a[l+this.colByVarIndex[p]]+=t*d;else{const g=v*i;for(let w=0;w<=s;w+=1)a[l+w]-=t*d*a[g+w]}}const m=n.index;this.varIndexByRow[e]=m,this.rowByVarIndex[m]=e,this.colByVarIndex[m]=-1,this.height+=1}function fe(n){const t=n.index,e=this.height-1,i=this.width,s=this.matrix,o=this.putInBase(t),r=o*i,a=e*i;for(let l=0;l<i;l++){const h=s[a+l];s[a+l]=s[r+l],s[r+l]=h}this.varIndexByRow[o]=this.varIndexByRow[e],this.varIndexByRow[e]=-1,this.rowByVarIndex[t]=-1,this.availableIndexes[this.availableIndexes.length]=t,n.slack.index=-1,this.height-=1}function de(n){this.height-1;const t=this.width,e=t+1,i=this.height,s=this.model.isMinimization===!0?-n.cost:n.cost,o=n.priority,r=this.matrix,a=new Float64Array(i*e);for(let u=0;u<i;u++){const m=u*t,c=u*e;for(let f=0;f<t;f++)a[c+f]=r[m+f]}this.matrix=a,this.width=e;const l=e-1,h=this.optionalObjectives.length;if(h>0)for(let u=0;u<h;u+=1)this.optionalObjectives[u].reducedCosts[l]=0;o===0?a[l]=s:(this.setOptionalObjective(o,l,s),a[l]=0),this.colByVarIndex[n.index]=l,this.varIndexByCol[l]=n.index}function pe(n){const t=n.index,e=this.width,i=this.matrix,s=e-1,o=this.takeOutOfBase(t),r=this.height-1;for(let a=0;a<=r;a+=1){const l=a*e;i[l+o]=i[l+s]}this.varIndexByCol[o]=this.varIndexByCol[s],this.rowByVarIndex[t]=-1,this.colByVarIndex[t]=-1,this.availableIndexes[this.availableIndexes.length]=t,this.width-=1}function ve(){const n=new this.constructor(this.precision,this.branchAndCutService);n.width=this.width,n.height=this.height,n.nVars=this.nVars,n.model=this.model,n.variables=this.variables,n.variablesPerIndex=this.variablesPerIndex,n.unrestrictedVars=this.unrestrictedVars,n.lastElementIndex=this.lastElementIndex,n.varIndexByRow=this.varIndexByRow.slice(),n.varIndexByCol=this.varIndexByCol.slice(),n.rowByVarIndex=this.rowByVarIndex.slice(),n.colByVarIndex=this.colByVarIndex.slice(),n.availableIndexes=this.availableIndexes.slice();const t=[];for(let e=0;e<this.optionalObjectives.length;e++)t[e]=this.optionalObjectives[e].copy();return n.optionalObjectives=t,n.objectivesByPriority={...this.objectivesByPriority},n.optionalObjectivePerPriority={...this.optionalObjectivePerPriority},n.matrix=new Float64Array(this.matrix),n}function me(){this.savedState=this.copy()}function ge(){if(this.savedState===null)return;const n=this.savedState;this.nVars=n.nVars,this.model=n.model,this.variables=n.variables,this.variablesPerIndex=n.variablesPerIndex,this.unrestrictedVars=n.unrestrictedVars,this.lastElementIndex=n.lastElementIndex,this.width=n.width,this.height=n.height,this.matrix.set(n.matrix);const t=n.varIndexByRow,e=this.height;for(let a=0;a<e;a+=1)this.varIndexByRow[a]=t[a];this.varIndexByRow.length=e;const i=n.varIndexByCol,s=this.width;for(let a=0;a<s;a+=1)this.varIndexByCol[a]=i[a];this.varIndexByCol.length=s;const o=n.rowByVarIndex,r=n.colByVarIndex;for(let a=0;a<this.nVars;a+=1)this.rowByVarIndex[a]=o[a],this.colByVarIndex[a]=r[a];if(n.optionalObjectives.length>0&&this.optionalObjectives.length>0){this.optionalObjectives=[],this.optionalObjectivePerPriority={};for(let a=0;a<n.optionalObjectives.length;a++){const l=n.optionalObjectives[a].copy();this.optionalObjectives[a]=l,this.optionalObjectivePerPriority[l.priority]=l,this.objectivesByPriority[l.priority]=l}}}function ye(){let n=0;const t=this.width,e=this.matrix,i=this.rhsColumn;for(let s=1;s<this.height;s+=1){const o=this.variablesPerIndex[this.varIndexByRow[s]];if(o!==void 0&&o.isInteger){const r=e[s*t+i],a=r-Math.floor(r);a<this.precision&&-a<this.precision&&(n+=1)}}return n}function we(){const n=this.width,t=this.matrix,e=this.rhsColumn,i=this.model.integerVariables,s=i.length;for(let o=0;o<s;o++){const r=i[o].index,a=this.rowByVarIndex[r];if(a!==-1){const l=t[a*n+e];if(Math.abs(l-Math.round(l))>this.precision)return!1}}return!0}function xe(n){let t=-1;const e=this.width,i=this.matrix,s=this.rhsColumn;for(let o=1;o<this.height;o+=1){const r=this.variablesPerIndex[this.varIndexByRow[o]];if(r!==void 0&&r.isInteger){const a=i[o*e+s],l=Math.abs(a);if(Math.min(l-Math.floor(l),Math.floor(l+1))<this.precision){if(n!==!0)return 0}else t===-1?t=l:t*=l}}return t===-1?0:t}function be(){let n=0,t=null,e=0;const i=this.width,s=this.matrix,o=this.rhsColumn,r=this.model.integerVariables,a=r.length;for(let l=0;l<a;l+=1){const h=r[l].index,u=this.rowByVarIndex[h];if(u!==-1){const m=s[u*i+o],c=Math.abs(m-Math.round(m));c>n&&(n=c,t=h,e=m)}}return{index:t,value:e}}function Ie(){let n=1/0,t=null,e=null;const i=this.width,s=this.matrix,o=this.rhsColumn,r=this.model.integerVariables,a=r.length;for(let l=0;l<a;l+=1){const h=r[l],u=h.index,m=this.rowByVarIndex[u];if(m!==-1){const c=s[m*i+o];Math.abs(c-Math.round(c))>this.precision&&h.cost<n&&(n=h.cost,t=u,e=c)}}return{index:t,value:e}}function Ce(n,t){if(!t)return this;console.log("****",n,"****"),console.log("Nb Variables",this.width-1),console.log("Nb Constraints",this.height-1),console.log("Basic Indexes",this.varIndexByRow),console.log("Non Basic Indexes",this.varIndexByCol),console.log("Rows",this.rowByVarIndex),console.log("Cols",this.colByVarIndex);const e=5,i=this.matrix,s=this.width;let o="";const r=[" "];let a,l,h,u,m,c,f;for(l=1;l<this.width;l+=1){h=this.varIndexByCol[l];const w=this.variablesPerIndex[h];w===void 0?u="c"+h:u=w.id,m=u.length,c=" ",f="	",m>5?c+=" ":f+="	",r[l]=c,o+=f+u}console.log(o);let d;const p=this.costRowIndex*s;let v="	";for(a=1;a<this.width;a+=1)d="	",v+=d,v+=r[a],v+=i[p+a].toFixed(e);d="	",v+=d+r[0]+i[p].toFixed(e),console.log(v+"	Z");for(let w=1;w<this.height;w+=1){const y=w*s;let x="	";for(l=1;l<this.width;l+=1)d="	",x+=d+r[l]+i[y+l].toFixed(e);d="	",x+=d+r[0]+i[y].toFixed(e),h=this.varIndexByRow[w];const b=this.variablesPerIndex[h];b===void 0?u="c"+h:u=b.id,console.log(x+"	"+u)}console.log("");const g=this.optionalObjectives.length;if(g>0){console.log("    Optional objectives:");for(let w=0;w<g;w+=1){const y=this.optionalObjectives[w].reducedCosts;let x="";for(a=1;a<this.width;a+=1)d=y[a]<0?"":" ",x+=d,x+=r[a],x+=y[a].toFixed(e);d=y[0]<0?"":" ",x+=d+r[0]+y[0].toFixed(e),console.log(x+" z"+w)}}return console.log("Feasible?",this.feasible),console.log("evaluation",this.evaluation),this}function Pt(n,t,e){return{priority:n,reducedCosts:e?e.slice():new Array(t).fill(0),copy(){return Pt(this.priority,this.reducedCosts.length,this.reducedCosts)}}}class _t{constructor(t=1e-8,e){this.model=null,this.matrix=new Float64Array(0),this.width=0,this.height=0,this.costRowIndex=0,this.rhsColumn=0,this.variablesPerIndex=[],this.unrestrictedVars={},this.feasible=!0,this.evaluation=0,this.simplexIters=0,this.varIndexByRow=[],this.varIndexByCol=[],this.rowByVarIndex=[],this.colByVarIndex=[],this.optionalObjectives=[],this.objectivesByPriority={},this.optionalObjectivePerPriority={},this.savedState=null,this.availableIndexes=[],this.lastElementIndex=0,this.variables=[],this.nVars=0,this.bounded=!0,this.unboundedVarIndex=null,this.branchAndCutIterations=0,this.bestPossibleEval=0,this.pricingBatchStart=1,this.pricingBatchSize=0,this.precision=t,this.branchAndCutService=e??dt()}simplex(){return Gt(this)?Zt.call(this):$t.call(this),this}phase1(){return qt.call(this)}phase2(){return Ut.call(this)}dualSimplex(){return Dt.call(this)}pivot(t,e){Wt.call(this,t,e)}checkForCycles(t){return Ht.call(this,t)}countIntegerValues(){return ye.call(this)}isIntegral(){return we.call(this)}computeFractionalVolume(t){return xe.call(this,t)}addCutConstraints(t){ee.call(this,t)}applyMIRCuts(){ne.call(this)}addLowerBoundMIRCut(t){return ie.call(this,t)}addUpperBoundMIRCut(t){return se.call(this,t)}getMostFractionalVar(){return be.call(this)}getFractionalVarWithLowestCost(){return Ie.call(this)}putInBase(t){return oe.call(this,t)}takeOutOfBase(t){return re.call(this,t)}updateVariableValues(){ae.call(this)}updateRightHandSide(t,e){le.call(this,t,e)}updateConstraintCoefficient(t,e,i){ce.call(this,t,e,i)}updateCost(t,e){he.call(this,t,e)}addConstraint(t){ue.call(this,t)}removeConstraint(t){fe.call(this,t)}addVariable(t){de.call(this,t)}removeVariable(t){pe.call(this,t)}copy(){return ve.call(this)}save(){me.call(this)}restore(){ge.call(this)}log(t){return Ce.call(this,t),this}applyCuts(t){this.branchAndCutService.applyCuts(this,t)}branchAndCut(){this.branchAndCutService.branchAndCut(this)}solve(){var t,e;return((e=(t=this.model)===null||t===void 0?void 0:t.getNumberOfIntegerVariables())!==null&&e!==void 0?e:0)>0?this.branchAndCut():this.simplex(),this.updateVariableValues(),this.getSolution()}getSolution(){var t,e,i;const s=((t=this.model)===null||t===void 0?void 0:t.isMinimization)===!0?this.evaluation:-this.evaluation;return((i=(e=this.model)===null||e===void 0?void 0:e.getNumberOfIntegerVariables())!==null&&i!==void 0?i:0)>0?new Lt(this,s,this.feasible,this.bounded,this.branchAndCutIterations):new St(this,s,this.feasible,this.bounded)}setOptionalObjective(t,e,i){let s=this.objectivesByPriority[t];if(s===void 0){const o=Math.max(this.width,e+1);s=Pt(t,o),this.objectivesByPriority[t]=s,this.optionalObjectivePerPriority[t]=s,this.optionalObjectives.push(s),this.optionalObjectives.sort((r,a)=>r.priority-a.priority)}s.reducedCosts[e]=i}initialize(t,e,i,s){this.variables=i,this.unrestrictedVars=s,this.width=t,this.height=e,this.matrix=new Float64Array(t*e),this.varIndexByRow=new Array(this.height),this.varIndexByCol=new Array(this.width),this.varIndexByRow[0]=-1,this.varIndexByCol[0]=-1,this.nVars=t+e-2,this.rowByVarIndex=new Array(this.nVars),this.colByVarIndex=new Array(this.nVars),this.lastElementIndex=this.nVars}_resetMatrix(){if(this.model===null)throw new Error("[Tableau._resetMatrix] Model not set");const t=this.matrix,e=this.width,i=this.model.variables,s=this.model.constraints,o=i.length,r=s.length,a=this.model.isMinimization===!0?-1:1;for(let h=0;h<o;h+=1){const u=i[h],m=u.priority,c=a*u.cost;m===0?t[h+1]=c:this.setOptionalObjective(m,h+1,c);const f=i[h].index;this.rowByVarIndex[f]=-1,this.colByVarIndex[f]=h+1,this.varIndexByCol[h+1]=f}let l=1;for(let h=0;h<r;h+=1){const u=s[h],m=u.index;this.rowByVarIndex[m]=l,this.colByVarIndex[m]=-1,this.varIndexByRow[l]=m;const c=u.terms,f=c.length,d=l*e;if(l++,u.isUpperBound){for(let p=0;p<f;p+=1){const v=c[p],g=this.colByVarIndex[v.variable.index];t[d+g]=v.coefficient}t[d]=u.rhs}else{for(let p=0;p<f;p+=1){const v=c[p],g=this.colByVarIndex[v.variable.index];t[d+g]=-v.coefficient}t[d]=-u.rhs}}}setModel(t){this.model=t;const e=t.nVariables+1,i=t.nConstraints+1;return this.initialize(e,i,t.variables,t.unrestrictedVariables),this._resetMatrix(),this}getNewElementIndex(){if(this.availableIndexes.length>0)return this.availableIndexes.pop();const t=this.lastElementIndex;return this.lastElementIndex+=1,t}density(){let t=0;const e=this.matrix,i=this.width;for(let s=0;s<this.height;s++){const o=s*i;for(let r=0;r<i;r++)e[o+r]!==0&&(t+=1)}return t/(this.height*this.width)}setEvaluation(){const t=Math.round(1/this.precision),e=this.matrix[this.costRowIndex*this.width+this.rhsColumn],i=Math.round((Number.EPSILON+e)*t)/t;this.evaluation=i,this.simplexIters===0&&(this.bestPossibleEval=i)}}function Ve(n,t){var e,i,s,o,r,a,l;let h=!1;for(const u of n.constraints){if(t.removedConstraints.has(u)||!u.isUpperBound)continue;let m=0;for(const f of u.terms)if(t.fixedVariables.has(f.variable))m+=f.coefficient*t.fixedVariables.get(f.variable);else{const d=(e=t.tightenedBounds.get(f.variable))!==null&&e!==void 0?e:{},p=(i=d.lower)!==null&&i!==void 0?i:0;if(f.coefficient>0)m+=f.coefficient*p;else{const v=(s=d.upper)!==null&&s!==void 0?s:1/0;m+=f.coefficient*v}}const c=u.rhs-m;if(!(c<0))for(const f of u.terms){if(t.fixedVariables.has(f.variable)||!f.variable.isInteger||f.coefficient<=0)continue;const d=(o=t.tightenedBounds.get(f.variable))!==null&&o!==void 0?o:{},p=(r=d.lower)!==null&&r!==void 0?r:0,v=(a=d.upper)!==null&&a!==void 0?a:1;if(p>=-.5&&v<=1.5&&f.coefficient*(v-p)>c+1e-6){const w=p+c/f.coefficient;if(w<v-1e-6){const y=(l=t.tightenedBounds.get(f.variable))!==null&&l!==void 0?l:{};(!y.upper||w<y.upper)&&(t.tightenedBounds.set(f.variable,{...y,upper:w}),t.stats.boundsTightened++,h=!0)}}}}return h}function Be(n,t){var e,i,s;let o=!1;for(const r of n.constraints){if(t.removedConstraints.has(r))continue;let a=0,l=0;for(const h of r.terms){const u=t.fixedVariables.get(h.variable);if(u!==void 0){a+=h.coefficient*u,l+=h.coefficient*u;continue}const m=(e=t.tightenedBounds.get(h.variable))!==null&&e!==void 0?e:{},c=(i=m.lower)!==null&&i!==void 0?i:0,f=(s=m.upper)!==null&&s!==void 0?s:1/0;h.coefficient>0?(a+=h.coefficient*c,l+=h.coefficient*(f===1/0?1e10:f)):(a+=h.coefficient*(f===1/0?1e10:f),l+=h.coefficient*c)}if(r.isUpperBound){if(l<=r.rhs+1e-6&&(t.removedConstraints.add(r),t.stats.constraintsRemoved++,o=!0),a>r.rhs+1e-6)return t.isInfeasible=!0,!1}else if(a>=r.rhs-1e-6&&(t.removedConstraints.add(r),t.stats.constraintsRemoved++,o=!0),l<r.rhs-1e-6)return t.isInfeasible=!0,!1}return o}function Se(n){var t,e;const i={fixedVariables:new Map,removedConstraints:new Set,tightenedBounds:new Map,isInfeasible:!1,stats:{variablesFixed:0,constraintsRemoved:0,boundsTightened:0}};let s=!0,o=0;const r=5;for(;s&&o<r;){s=!1,o++;for(const a of n.constraints){if(i.removedConstraints.has(a))continue;const l=a.terms.filter(h=>!i.fixedVariables.has(h.variable));if(l.length===0){let h=0;for(const m of a.terms){const c=i.fixedVariables.get(m.variable);c!==void 0&&(h+=m.coefficient*c)}if(!(a.isUpperBound?h<=a.rhs+1e-6:h>=a.rhs-1e-6))return i.isInfeasible=!0,i;i.removedConstraints.add(a),i.stats.constraintsRemoved++,s=!0}else if(l.length===1){const h=l[0],u=h.variable,m=h.coefficient;let c=a.rhs;for(const d of a.terms)if(d.variable!==u){const p=i.fixedVariables.get(d.variable);p!==void 0&&(c-=d.coefficient*p)}const f=c/m;if(a.isUpperBound)if(m>0){const d=i.tightenedBounds.get(u);(!d?.upper||f<d.upper)&&(i.tightenedBounds.set(u,{...d,upper:f}),i.stats.boundsTightened++,s=!0)}else{const d=i.tightenedBounds.get(u);(!d?.lower||f>d.lower)&&(i.tightenedBounds.set(u,{...d,lower:f}),i.stats.boundsTightened++,s=!0)}i.removedConstraints.add(a),i.stats.constraintsRemoved++}}for(const[a,l]of i.tightenedBounds)if(!i.fixedVariables.has(a)){if(l.lower!==void 0&&l.upper!==void 0){if(l.lower>l.upper+1e-6)return i.isInfeasible=!0,i;if(Math.abs(l.lower-l.upper)<1e-6){let h=l.lower;a.isInteger&&(h=Math.round(h)),i.fixedVariables.set(a,h),i.stats.variablesFixed++,s=!0}}a.isInteger&&l.lower!==void 0&&l.lower>=.5&&((t=l.upper)!==null&&t!==void 0?t:1/0)<=1.5&&(i.fixedVariables.set(a,1),i.stats.variablesFixed++,s=!0),a.isInteger&&l.upper!==void 0&&l.upper<=.5&&((e=l.lower)!==null&&e!==void 0?e:0)>=-.5&&(i.fixedVariables.set(a,0),i.stats.variablesFixed++,s=!0)}if(Be(n,i)&&(s=!0),i.isInfeasible)return i;Ve(n,i)&&(s=!0)}return i}class ut{constructor(t,e,i){this.tableau=new _t(t,i),this.name=e,this.variables=[],this.integerVariables=[],this.unrestrictedVariables={},this.constraints=[],this.nConstraints=0,this.nVariables=0,this.isMinimization=!0,this.tableauInitialized=!1,this.relaxationIndex=1,this.useMIRCuts=!1,this.checkForCycles=!0,this.messages=[],this.availableIndexes=[],this.lastElementIndex=0,this.usePresolve=!0,this.presolveResult=null}minimize(){return this.isMinimization=!0,this}maximize(){return this.isMinimization=!1,this}_getNewElementIndex(){if(this.availableIndexes.length>0)return this.availableIndexes.pop();const t=this.lastElementIndex;return this.lastElementIndex+=1,t}_addConstraint(t){const e=t.slack;this.tableau.variablesPerIndex[e.index]=e,this.constraints.push(t),this.nConstraints+=1,this.tableauInitialized===!0&&this.tableau.addConstraint(t)}smallerThan(t){const e=new Y(t,!0,this.tableau.getNewElementIndex(),this);return this._addConstraint(e),e}greaterThan(t){const e=new Y(t,!1,this.tableau.getNewElementIndex(),this);return this._addConstraint(e),e}equal(t){const e=new Y(t,!0,this.tableau.getNewElementIndex(),this);this._addConstraint(e);const i=new Y(t,!1,this.tableau.getNewElementIndex(),this);return this._addConstraint(i),new gt(e,i)}addVariable(t,e,i,s,o){if(typeof o=="string")switch(o){case"required":o=0;break;case"strong":o=1;break;case"medium":o=2;break;case"weak":o=3;break;default:o=0;break}const r=this.tableau.getNewElementIndex(),a=e??"v"+r,l=t??0,h=o??0;let u;if(i){const m=new Xt(a,l,r,h);this.integerVariables.push(m),u=m}else u=new lt(a,l,r,h);return this.variables.push(u),this.tableau.variablesPerIndex[r]=u,s&&(this.unrestrictedVariables[r]=!0),this.nVariables+=1,this.tableauInitialized===!0&&this.tableau.addVariable(u),u}_removeConstraint(t){const e=this.constraints.indexOf(t);if(e===-1){console.warn("[Model.removeConstraint] Constraint not present in model");return}this.constraints.splice(e,1),this.nConstraints-=1,this.tableauInitialized===!0&&this.tableau.removeConstraint(t),t.relaxation&&this.removeVariable(t.relaxation)}removeConstraint(t){if(t.isEquality){const e=t;this._removeConstraint(e.upperBound),this._removeConstraint(e.lowerBound)}else this._removeConstraint(t);return this}removeVariable(t){const e=this.variables.indexOf(t);if(e===-1){console.warn("[Model.removeVariable] Variable not present in model");return}return this.variables.splice(e,1),this.tableauInitialized===!0&&this.tableau.removeVariable(t),this}updateRightHandSide(t,e){return this.tableauInitialized===!0&&this.tableau.updateRightHandSide(t,e),this}updateConstraintCoefficient(t,e,i){return this.tableauInitialized===!0&&this.tableau.updateConstraintCoefficient(t,e,i),this}setCost(t,e){let i=t-e.cost;return this.isMinimization===!1&&(i=-i),e.cost=t,this.tableau.updateCost(e,i),this}loadJson(t){this.isMinimization=t.opType!=="max";const e=t.variables,i=t.constraints,s={},o={},r=Object.keys(i),a=r.length;for(let d=0;d<a;d+=1){const p=r[d],v=i[p],g=v.equal,w=v.weight,y=v.priority,x=w!==void 0||y!==void 0;let b,I;if(g===void 0){const C=v.min;C!==void 0&&(b=this.greaterThan(C),s[p]=b,x&&b.relax(w,y));const V=v.max;V!==void 0&&(I=this.smallerThan(V),o[p]=I,x&&I.relax(w,y))}else{b=this.greaterThan(g),s[p]=b,I=this.smallerThan(g),o[p]=I;const C=new gt(b,I);x&&C.relax(w,y)}}const l=Object.keys(e),h=l.length;this.tolerance=t.tolerance||0,t.timeout&&(this.timeout=t.timeout),t.options&&(t.options.timeout&&(this.timeout=t.options.timeout),this.tolerance===0&&(this.tolerance=t.options.tolerance||0),t.options.useMIRCuts&&(this.useMIRCuts=t.options.useMIRCuts),typeof t.options.exitOnCycles>"u"?this.checkForCycles=!0:this.checkForCycles=t.options.exitOnCycles,t.options.keep_solutions?this.keep_solutions=t.options.keep_solutions:this.keep_solutions=!1,t.options.presolve!==void 0&&(this.usePresolve=t.options.presolve));const u=t.ints||{},m=t.binaries||{},c=t.unrestricted||{},f=t.optimize;for(let d=0;d<h;d+=1){const p=l[d],v=e[p],g=v[f]||0,w=!!m[p],y=!!u[p]||w,x=!!c[p],b=this.addVariable(g,p,y,x);w&&this.smallerThan(1).addTerm(1,b);const I=Object.keys(v);for(let C=0;C<I.length;C+=1){const V=I[C];if(V===f)continue;const B=v[V],A=s[V];A!==void 0&&A.addTerm(B,b);const S=o[V];S!==void 0&&S.addTerm(B,b)}}return this}getNumberOfIntegerVariables(){return this.integerVariables.length}solve(){if(this.usePresolve&&this.presolveResult===null){if(this.presolveResult=Se(this),this.presolveResult.isInfeasible)return this.tableau.feasible=!1,this.tableau.getSolution();this.applyPresolveReductions(this.presolveResult)}return this.tableauInitialized===!1&&(this.tableau.setModel(this),this.tableauInitialized=!0),this.tableau.solve()}applyPresolveReductions(t){for(const[e,i]of t.fixedVariables)e.value=i,e.cost=0}isFeasible(){return this.tableau.feasible}save(){this.tableau.save()}restore(){this.tableau.restore()}activateMIRCuts(t){this.useMIRCuts=t}debug(t){this.checkForCycles=t}log(t){return this.tableau.log(t)}}const ft={optype:"opType",OpType:"opType",op_type:"opType",type:"opType",optimise:"optimize",Optimize:"optimize",objective:"optimize",constraint:"constraints",Constraints:"constraints",variable:"variables",Variables:"variables",vars:"variables",int:"ints",integers:"ints",Ints:"ints",binary:"binaries",Binaries:"binaries"},Oe={minimum:"min",maximum:"max",Min:"min",Max:"max",eq:"equal",equals:"equal",Equal:"equal"};function Re(n){const t=Object.keys(n);for(const e of t){const i=ft[e];i&&console.warn(`[jsLPSolver] Warning: Model has '${e}' but expected '${i}'. This may cause unexpected behavior.`)}if(!n.optimize&&!t.some(e=>ft[e]==="optimize")&&console.warn("[jsLPSolver] Warning: Model is missing 'optimize' property. The solver needs to know which attribute to optimize."),!n.opType&&!t.some(e=>ft[e]==="opType")&&console.warn(`[jsLPSolver] Warning: Model is missing 'opType' property. Defaulting to 'max'. Use 'opType: "max"' or 'opType: "min"' to be explicit.`),n.constraints){for(const[e,i]of Object.entries(n.constraints))if(typeof i=="object"&&i!==null)for(const s of Object.keys(i)){const o=Oe[s];o&&console.warn(`[jsLPSolver] Warning: Constraint '${e}' has '${s}' but expected '${o}'.`)}}return n}function Ae(n){let t,e,i;if(typeof n.optimize=="string"){if(n.constraints[n.optimize]){t=Math.random();for(e in n.variables)n.variables[e][n.optimize]&&(n.variables[e][t]=n.variables[e][n.optimize]);return n.constraints[t]=n.constraints[n.optimize],delete n.constraints[n.optimize],n}return n}else{for(i in n.optimize)if(n.constraints[i])if(n.constraints[i]==="equal")delete n.optimize[i];else{t=Math.random();for(e in n.variables)n.variables[e][i]&&(n.variables[e][t]=n.variables[e][i]);n.constraints[t]=n.constraints[i],delete n.constraints[i]}return n}}var yt=Object.freeze({__proto__:null,CleanObjectiveAttributes:Ae,WarnOnTypos:Re});const nt={};function Me(n){return JSON.parse(JSON.stringify(n))}function wt(n){if(n&&typeof n=="object")return n;throw new Error("Polyopt requires the solver to return an object result.")}function Pe(n,t,e){for(const i of e)if(!t.variables[i]){typeof n[i]!="number"&&(n[i]=0);for(const[s,o]of Object.entries(t.variables)){const r=o[i],a=n[s];typeof r=="number"&&typeof a=="number"&&(n[i]+=a*r)}}}function _e(n,t){return`base-${t.map(i=>{const s=n[i];return typeof s=="number"?Math.round(s*1e3)/1e3:0}).join("-")}`}function Ee(n){var t;const e={};for(const i of n)for(const[s,o]of Object.entries(i)){if(typeof o!="number")continue;const r=(t=e[s])!==null&&t!==void 0?t:{min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};e[s]={min:Math.min(r.min,o),max:Math.max(r.max,o)}}for(const i of n)for(const s of Object.keys(e))typeof i[s]!="number"&&(i[s]=0),e[s].min=Math.min(e[s].min,i[s]),e[s].max=Math.max(e[s].max,i[s]);for(const[i,s]of Object.entries(e))Number.isFinite(s.min)||(e[i]={min:0,max:0});return e}function xt(n,t){const e=Me(t),i=e.optimize,s=Object.keys(i);if(s.length===0)throw new Error("Multi-objective solve requires at least one objective definition.");const o=e;delete o.optimize,delete o.opType;const r={},a=new Set,l=[];for(const c of s)r[c]=0;for(const c of s){e.optimize=c,e.opType=i[c];const f=wt(n.Solve(e,void 0,void 0,!0));Pe(f,e,s);const d=_e(f,s);if(a.has(d))continue;a.add(d);for(const y of s){const x=f[y];typeof x=="number"&&(r[y]+=x)}const{feasible:p,result:v,bounded:g,...w}=f;l.push(w)}for(const c of s)e.constraints[c]={equal:r[c]/a.size};const h=`cheater-${Math.random()}`;e.optimize=h,e.opType="max";for(const c of Object.values(e.variables))c[h]=1;const u=Ee(l);return{midpoint:wt(n.Solve(e,void 0,void 0,!0)),vertices:l,ranges:u}}function Te(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function ke(n){var t={is_objective:/(max|min)(imize){0,}\:/i,is_int:/^(?!\/\*)\W{0,}int/i,is_bin:/^(?!\/\*)\W{0,}bin/i,is_constraint:/(\>|\<){0,}\=/i,is_unrestricted:/^\S{0,}unrestricted/i,parse_lhs:/(\-|\+){0,1}\s{0,1}\d{0,}\.{0,}\d{0,}\s{0,}[A-Za-z]\S{0,}/gi,parse_rhs:/(\-|\+){0,1}\d{1,}\.{0,}\d{0,}\W{0,}\;{0,1}$/i,parse_dir:/(\>|\<){0,}\=/gi,parse_int:/[^\s|^\,]+/gi,parse_bin:/[^\s|^\,]+/gi,get_num:/(\-|\+){0,1}(\W|^)\d+\.{0,1}\d{0,}/g,get_word:/[A-Za-z].*/},e={opType:"",optimize:"_obj",constraints:{},variables:{}},i={">=":"min","<=":"max","=":"equal"},s="",o=null,r="",a="",l="",h=0;typeof n=="string"&&(n=n.split(`
`));for(var u=0;u<n.length;u++)if(l="__"+u,s=n[u],o=null,t.is_objective.test(s))e.opType=s.match(/(max|min)/gi)[0],o=s.match(t.parse_lhs).map(function(f){return f.replace(/\s+/,"")}).slice(1),o.forEach(function(f){r=f.match(t.get_num),r===null?f.substr(0,1)==="-"?r=-1:r=1:r=r[0],r=parseFloat(r),a=f.match(t.get_word)[0].replace(/\;$/,""),e.variables[a]=e.variables[a]||{},e.variables[a]._obj=r});else if(t.is_int.test(s))o=s.match(t.parse_int).slice(1),e.ints=e.ints||{},o.forEach(function(f){f=f.replace(";",""),e.ints[f]=1});else if(t.is_bin.test(s))o=s.match(t.parse_bin).slice(1),e.binaries=e.binaries||{},o.forEach(function(f){f=f.replace(";",""),e.binaries[f]=1});else if(t.is_constraint.test(s)){var m=s.indexOf(":"),c=m===-1?s:s.slice(m+1);o=c.match(t.parse_lhs).map(function(f){return f.replace(/\s+/,"")}),o.forEach(function(f){r=f.match(t.get_num),r===null?f.substr(0,1)==="-"?r=-1:r=1:r=r[0],r=parseFloat(r),a=f.match(t.get_word)[0],e.variables[a]=e.variables[a]||{},e.variables[a][l]=r}),h=parseFloat(s.match(t.parse_rhs)[0]),s=i[s.match(t.parse_dir)[0]],e.constraints[l]=e.constraints[l]||{},e.constraints[l][s]=h}else t.is_unrestricted.test(s)&&(o=s.match(t.parse_int).slice(1),e.unrestricted=e.unrestricted||{},o.forEach(function(f){f=f.replace(";",""),e.unrestricted[f]=1}));return e}function Fe(n){if(!n)throw new Error("Solver requires a model to operate on");var t="",e={max:"<=",min:">=",equal:"="},i=new RegExp("[^A-Za-z0-9_[{}/.&#$%~'@^]","gi");if(n.opType){t+=n.opType+":";for(var s in n.variables)n.variables[s][s]=n.variables[s][s]?n.variables[s][s]:1,n.variables[s][n.optimize]&&(t+=" "+n.variables[s][n.optimize]+" "+s.replace(i,"_"))}else t+="max:";t+=`;

`;for(var o in n.constraints)for(var r in n.constraints[o])if(typeof e[r]<"u"){for(var a in n.variables)typeof n.variables[a][o]<"u"&&(t+=" "+n.variables[a][o]+" "+a.replace(i,"_"));t+=" "+e[r]+" "+n.constraints[o][r],t+=`;
`}if(n.ints){t+=`

`;for(var l in n.ints)t+="int "+l.replace(i,"_")+`;
`}if(n.unrestricted){t+=`

`;for(var h in n.unrestricted)t+="unrestricted "+h.replace(i,"_")+`;
`}return t}var ze=function(n){return n.length?ke(n):Fe(n)},je=Te(ze);function bt(n,t,e){return{type:n,varIndex:t,value:e}}function H(n,t,e,i,s,o,r){return{relaxedEvaluation:n,cuts:t,depth:e,branchVarIndex:i,branchDirection:s,branchFractionality:o,parentEvaluation:r}}function Ne(n={}){const{nodeSelection:t="hybrid",branching:e="pseudocost",useDiving:i=!0,strongBranchingCandidates:s=5}=n,o=new Map,r=c=>{let f=o.get(c);return f||(f={upSum:0,upCount:0,downSum:0,downCount:0},o.set(c,f)),f},a=(c,f,d,p)=>{const v=r(c),g=d/(f==="up"?1-p:p);f==="up"?(v.upSum+=g,v.upCount++):(v.downSum+=g,v.downCount++)},l=(c,f)=>{const d=r(c),p=d.upCount>0?d.upSum/d.upCount:1,v=d.downCount>0?d.downSum/d.downCount:1,g=p*(1-f),w=v*f;return Math.max(g,1e-6)*Math.max(w,1e-6)},h=(c,f)=>{const d=c.width,p=c.matrix,v=c.rhsColumn,g=c.model.integerVariables,w=c.precision;let y=[];for(const x of g){const b=x.index,I=c.rowByVarIndex[b];if(I!==-1){const C=p[I*d+v],V=Math.abs(C-Math.round(C));V>w&&y.push({index:b,value:C,fraction:V})}}if(y.length===0)return null;if(e==="most-fractional")return y.sort((x,b)=>b.fraction-x.fraction),{index:y[0].index,value:y[0].value};if(e==="pseudocost"){let x=-1/0,b=y[0];for(const I of y){const C=l(I.index,I.fraction);C>x&&(x=C,b=I)}return{index:b.index,value:b.value}}if(e==="strong"){y.sort((I,C)=>C.fraction-I.fraction),y=y.slice(0,s);let x=-1/0,b=y[0];for(const I of y){const C=r(I.index);if(C.upCount>=2&&C.downCount>=2){const V=l(I.index,I.fraction);V>x&&(x=V,b=I)}else{const V=I.fraction*(1-I.fraction);V>x&&(x=V,b=I)}}return{index:b.index,value:b.value}}return{index:y[0].index,value:y[0].value}},u=(c,f)=>{var d;if(c.restore(),c.addCutConstraints(f),c.simplex(),!((d=c.model)===null||d===void 0)&&d.useMIRCuts&&c.feasible){let p=!0,v=0;const g=3;for(;p&&v<g;){const w=c.computeFractionalVolume(!0);c.applyMIRCuts(),c.simplex();const y=c.computeFractionalVolume(!0);v++,y>=.9*w&&(p=!1)}}};return{applyCuts:u,branchAndCut:c=>{var f,d,p,v,g;const w=new pt,y=[];let x=0;const b=(d=(f=c.model)===null||f===void 0?void 0:f.tolerance)!==null&&d!==void 0?d:0;let I=!0,C=1e99;!((p=c.model)===null||p===void 0)&&p.timeout&&(C=Date.now()+c.model.timeout);let V=1/0,B=null;const A=[];for(let M=0;M<c.optionalObjectives.length;M+=1)A.push(1/0);const S=1;let O=0,P=t==="depth-first"||t==="hybrid";const E=H(-1/0,[],0);let j;for(P?y.push(E):w.push(E);(P?y.length>0:!w.isEmpty())&&I===!0&&Date.now()<C;){!((v=c.model)===null||v===void 0)&&v.isMinimization?j=c.bestPossibleEval*(1+b):j=c.bestPossibleEval*(1-b),b>0&&V<j&&(I=!1);let M;if(P&&y.length>0)M=y.pop();else if(!w.isEmpty())M=w.pop();else break;if(M.relaxedEvaluation>V)continue;const k=M.cuts;if(c.evaluation,u(c,k),x++,!c.feasible)continue;const F=c.evaluation;if(!(F>V)){if(M.branchVarIndex!==void 0&&M.branchDirection!==void 0&&M.branchFractionality!==void 0&&M.parentEvaluation!==void 0){const _=Math.abs(F-M.parentEvaluation);a(M.branchVarIndex,M.branchDirection,_,M.branchFractionality)}if(F===V){let _=!0;for(let R=0;R<c.optionalObjectives.length&&!(c.optionalObjectives[R].reducedCosts[0]>A[R]);R++)if(c.optionalObjectives[R].reducedCosts[0]<A[R]){_=!1;break}if(_)continue}if(c.isIntegral()){if(c.__isIntegral=!0,O++,x===1){c.branchAndCutIterations=x;return}B=M,V=F;for(let _=0;_<c.optionalObjectives.length;_++)A[_]=c.optionalObjectives[_].reducedCosts[0];if(!((g=c.model)===null||g===void 0)&&g.keep_solutions){const _=c.model.tableau.getSolution(),R=_.generateSolutionSet();R.result=_.evaluation,c.model.solutions||(c.model.solutions=[]),c.model.solutions.push(R)}if(t==="hybrid"&&O>=S)for(P=!1;y.length>0;)w.push(y.pop())}else{x===1&&c.save();const _=h(c);if(!_)continue;const R=_.index,T=_.value,$=[],N=[],q=k.length;for(let U=0;U<q;U++){const z=k[U];z.varIndex===R?z.type==="min"?N.push(z):$.push(z):($.push(z),N.push(z))}const D=Math.ceil(T),G=Math.floor(T),X=D-T,tt=T-G,et=bt("min",R,D);$.push(et);const it=bt("max",R,G);N.push(it);const L=M.depth+1;P?(y.push(H(F,N,L,R,"down",tt,F)),y.push(H(F,$,L,R,"up",X,F))):(w.push(H(F,$,L,R,"up",X,F)),w.push(H(F,N,L,R,"down",tt,F)))}}}B!==null&&u(c,B.cuts),c.branchAndCutIterations=x}}}function Le(n){return{matrix:new Float64Array(n.matrix),width:n.width,height:n.height,nVars:n.nVars,varIndexByRow:n.varIndexByRow.slice(),varIndexByCol:n.varIndexByCol.slice(),rowByVarIndex:n.rowByVarIndex.slice(),colByVarIndex:n.colByVarIndex.slice(),availableIndexes:n.availableIndexes.slice(),lastElementIndex:n.lastElementIndex,evaluation:n.evaluation,feasible:n.feasible}}function $e(n,t){n.matrix.length>=t.matrix.length?n.matrix.set(t.matrix):n.matrix=new Float64Array(t.matrix),n.width=t.width,n.height=t.height,n.nVars=t.nVars;const e=t.height;for(let o=0;o<e;o++)n.varIndexByRow[o]=t.varIndexByRow[o];n.varIndexByRow.length=e;const i=t.width;for(let o=0;o<i;o++)n.varIndexByCol[o]=t.varIndexByCol[o];n.varIndexByCol.length=i;const s=t.nVars;for(let o=0;o<s;o++)n.rowByVarIndex[o]=t.rowByVarIndex[o],n.colByVarIndex[o]=t.colByVarIndex[o];n.availableIndexes=t.availableIndexes.slice(),n.lastElementIndex=t.lastElementIndex,n.evaluation=t.evaluation,n.feasible=t.feasible}function It(n,t,e){return{type:n,varIndex:t,value:e}}function Z(n,t,e,i,s){return{relaxedEvaluation:n,cuts:t,depth:e,parentCheckpoint:i,newCut:s}}function De(n={}){const{nodeSelection:t="hybrid",branching:e="pseudocost",maxCheckpoints:i=50}=n,s=new Map,o=c=>{let f=s.get(c);return f||(f={upSum:0,upCount:0,downSum:0,downCount:0},s.set(c,f)),f},r=(c,f,d,p)=>{const v=o(c),g=d/(f==="up"?1-p:p);f==="up"?(v.upSum+=g,v.upCount++):(v.downSum+=g,v.downCount++)},a=(c,f)=>{const d=o(c),p=d.upCount>0?d.upSum/d.upCount:1,v=d.downCount>0?d.downSum/d.downCount:1,g=p*(1-f),w=v*f;return Math.max(g,1e-6)*Math.max(w,1e-6)},l=c=>{const f=c.width,d=c.matrix,p=c.rhsColumn,v=c.model.integerVariables,g=c.precision,w=[];for(const b of v){const I=b.index,C=c.rowByVarIndex[I];if(C!==-1){const V=d[C*f+p],B=Math.abs(V-Math.round(V));B>g&&w.push({index:I,value:V,fraction:B})}}if(w.length===0)return null;if(e==="most-fractional")return w.sort((b,I)=>I.fraction-b.fraction),w[0];let y=-1/0,x=w[0];for(const b of w){const I=a(b.index,b.fraction);I>y&&(y=I,x=b)}return x},h=(c,f)=>{var d;if(c.restore(),c.addCutConstraints(f),c.simplex(),!((d=c.model)===null||d===void 0)&&d.useMIRCuts&&c.feasible){let p=!0,v=0;const g=3;for(;p&&v<g;){const w=c.computeFractionalVolume(!0);c.applyMIRCuts(),c.simplex();const y=c.computeFractionalVolume(!0);v++,y>=.9*w&&(p=!1)}}},u=(c,f)=>{var d;if(f.parentCheckpoint&&f.newCut?($e(c,f.parentCheckpoint),c.addCutConstraints([f.newCut]),c.simplex()):(c.restore(),c.addCutConstraints(f.cuts),c.simplex()),!((d=c.model)===null||d===void 0)&&d.useMIRCuts&&c.feasible){let p=!0,v=0;const g=3;for(;p&&v<g;){const w=c.computeFractionalVolume(!0);c.applyMIRCuts(),c.simplex();const y=c.computeFractionalVolume(!0);v++,y>=.9*w&&(p=!1)}}};return{applyCuts:h,branchAndCut:c=>{var f,d,p,v,g;const w=new pt,y=[];let x=0,b=0;const I=(d=(f=c.model)===null||f===void 0?void 0:f.tolerance)!==null&&d!==void 0?d:0;let C=!0,V=1e99;!((p=c.model)===null||p===void 0)&&p.timeout&&(V=Date.now()+c.model.timeout);let B=1/0,A=null;const S=[];for(let M=0;M<c.optionalObjectives.length;M++)S.push(1/0);const O=1;let P=0,E=t==="depth-first"||t==="hybrid";const j=Z(-1/0,[],0);for(E?y.push(j):w.push(j);(E?y.length>0:!w.isEmpty())&&C===!0&&Date.now()<V;){let M;!((v=c.model)===null||v===void 0)&&v.isMinimization?M=c.bestPossibleEval*(1+I):M=c.bestPossibleEval*(1-I),I>0&&B<M&&(C=!1);let k;if(E&&y.length>0)k=y.pop();else if(!w.isEmpty())k=w.pop();else break;if(k.relaxedEvaluation>B)continue;const F=c.evaluation;if(u(c,k),x++,!c.feasible)continue;const _=c.evaluation;if(!(_>B)){if(k.newCut&&F!==0){const R=Math.abs(_-F);r(k.newCut.varIndex,k.newCut.type==="min"?"up":"down",R,.5)}if(_===B){let R=!0;for(let T=0;T<c.optionalObjectives.length&&!(c.optionalObjectives[T].reducedCosts[0]>S[T]);T++)if(c.optionalObjectives[T].reducedCosts[0]<S[T]){R=!1;break}if(R)continue}if(c.isIntegral()){if(c.__isIntegral=!0,P++,x===1){c.branchAndCutIterations=x;return}A=k,B=_;for(let R=0;R<c.optionalObjectives.length;R++)S[R]=c.optionalObjectives[R].reducedCosts[0];if(!((g=c.model)===null||g===void 0)&&g.keep_solutions){const R=c.model.tableau.getSolution(),T=R.generateSolutionSet();T.result=R.evaluation,c.model.solutions||(c.model.solutions=[]),c.model.solutions.push(T)}if(t==="hybrid"&&P>=O)for(E=!1;y.length>0;)w.push(y.pop())}else{x===1&&c.save();const R=l(c);if(!R)continue;const T=R.index,$=R.value;let N;E&&b<i&&(N=Le(c),b++);const q=[],D=[],G=k.cuts.length;for(let U=0;U<G;U++){const z=k.cuts[U];z.varIndex===T?z.type==="min"?D.push(z):q.push(z):(q.push(z),D.push(z))}const X=Math.ceil($),tt=Math.floor($),et=It("min",T,X);q.push(et);const it=It("max",T,tt);D.push(it);const L=k.depth+1;E?(y.push(Z(_,D,L,N,it)),y.push(Z(_,q,L,N,et))):(w.push(Z(_,q,L)),w.push(Z(_,D,L)))}}}A!==null&&h(c,A.cuts),c.branchAndCutIterations=x}}}class qe{constructor(){this.Model=ut,this.Tableau=_t,this.Constraint=Y,this.Variable=lt,this.Numeral=te,this.Term=At,this.External=nt,this.ReformatLP=je,this.branchAndCutService=dt(),this.branchAndCut=t=>this.branchAndCutService.branchAndCut(t),this.lastSolvedModel=null}selectBranchAndCutService(t){var e,i,s,o;const r=t.options,a=r?.nodeSelection||r?.branching;return r?.useIncremental===!0?De({nodeSelection:(e=r?.nodeSelection)!==null&&e!==void 0?e:"hybrid",branching:(i=r?.branching)!==null&&i!==void 0?i:"pseudocost"}):a?Ne({nodeSelection:(s=r?.nodeSelection)!==null&&s!==void 0?s:"hybrid",branching:(o=r?.branching)!==null&&o!==void 0?o:"pseudocost",useDiving:!0}):dt()}Solve(t,e,i,s){if(s)for(const a in yt){const l=yt[a];typeof l=="function"&&(t=l(t))}if(!t)throw new Error("Solver requires a model to operate on");if(typeof t.optimize=="object"&&Object.keys(t.optimize).length>1)return xt(this,t);if(t.external)return this.solveWithExternalSolver(t);let o;if(t instanceof ut)o=t;else{const a=this.selectBranchAndCutService(t);o=new ut(e,void 0,a).loadJson(t)}const r=o.solve();return this.lastSolvedModel=o,r.solutionSet=r.generateSolutionSet(),i?r:this.buildSimplifiedResult(r)}solveWithExternalSolver(t){var e;const i=Object.keys(nt),s=JSON.stringify(i);if(!(!((e=t.external)===null||e===void 0)&&e.solver))throw new Error(`Model has 'external' object without solver attribute. Available: ${s}`);const o=t.external.solver;if(!nt[o])throw new Error(`Solver '${o}' not supported. Available: ${s}`);return nt[o].solve(t)}buildSimplifiedResult(t){const e={feasible:t.feasible,result:t.evaluation,bounded:t.bounded};t._tableau.__isIntegral&&(e.isIntegral=!0);for(const i of Object.keys(t.solutionSet)){const s=t.solutionSet[i];s!==0&&(e[i]=s)}return e}MultiObjective(t){return xt(this,t)}}const J=new qe;typeof define=="function"?define([],()=>J):typeof window=="object"?window.solver=J:typeof self=="object"&&(self.solver=J);Nt.setLevel("warn");const Ct=1,Vt="p_",Bt="o_";class Ue{constructor(t,e=!1){this.nodeId=t,this.isTerminal=e,this.playerActions=[],this.opponentActions=[],this.children=new Map,this.rewards=new Map,this.playerStrategy=new Map,this.opponentStrategy=new Map,this.playerValue=0,this.opponentValue=0}}class We{constructor(t){this.gameTree=t,this.nodes=new Map,this.nodeMap=new Map,this.topologicalOrder=[],this.buildInternalTree()}buildInternalTree(){const t=this.gameTree.nodes[this.gameTree.root];if(!t)throw new Error(`Root node ${this.gameTree.root} not found in nodes map`);this.collectAllNodes(t),this.buildLPNode(t),this.computeTopologicalOrder()}collectAllNodes(t){this.nodeMap.set(t.nodeId,t);for(const e of t.transitions)if(e.nextNodeId){const i=this.findNodeById(e.nextNodeId);i&&!this.nodeMap.has(i.nodeId)&&this.collectAllNodes(i)}}findNodeById(t){if(this.nodeMap.has(t))return this.nodeMap.get(t);const e=this.gameTree.nodes[t];if(e)return e}isTerminalNode(t){return t.playerReward!==void 0||t.opponentReward!==void 0}buildLPNode(t){if(this.nodes.has(t.nodeId))return this.nodes.get(t.nodeId);const e=this.isTerminalNode(t),i=new Ue(t.nodeId,e);t.playerActions&&(i.playerActions=t.playerActions.actions.map(s=>s.actionId)),t.opponentActions&&(i.opponentActions=t.opponentActions.actions.map(s=>s.actionId));for(const s of t.transitions){const o=`${s.playerActionId}-${s.opponentActionId}`;if(s.nextNodeId){const r=this.nodeMap.get(s.nextNodeId);if(r)if(this.isTerminalNode(r)){const a=r.playerReward?.value??0,l=r.opponentReward?.value??0;i.rewards.set(o,[a,l])}else{const a=this.buildLPNode(r);i.children.set(o,a)}}}return this.nodes.set(t.nodeId,i),i}computeTopologicalOrder(){const t=new Set,e=new Set,i=[],s=o=>{if(e.has(o)||t.has(o))return;e.add(o);const r=this.nodes.get(o);if(r){const a=Array.from(r.children.values());for(const l of a)s(l.nodeId)}e.delete(o),t.add(o),i.push(o)};s(this.gameTree.root),this.topologicalOrder=i}solvePlayerLP(t){if(t.playerActions.length===0)return;if(t.playerActions.length===1){t.playerStrategy.set(t.playerActions[0],1),t.playerValue=this.calculateMinimaxValueForSinglePlayerAction(t);return}const e=[];for(const a of t.playerActions){const l=[];for(const h of t.opponentActions){const u=`${a}-${h}`,m=t.rewards.get(u),c=t.children.get(u);let f=0;m?f=m[0]:c&&(f=c.playerValue),l.push(f)}e.push(l)}let i=1/0;for(const a of e)for(const l of a)i=Math.min(i,l);const s=i<0?-i+Ct:0,o=this.buildPlayerLPModel(t,e,s),r=J.Solve(o);if(r.feasible){for(const a of t.playerActions){const l=`${Vt}${a}`,h=r[l]??0;t.playerStrategy.set(a,h)}t.playerValue=(r.v??0)-s}else{const a=1/t.playerActions.length;for(const l of t.playerActions)t.playerStrategy.set(l,a);t.playerValue=this.calculateExpectedValue(t,!0)}}buildPlayerLPModel(t,e,i){const s={optimize:"v",opType:"max",constraints:{},variables:{}};s.constraints.prob_sum={equal:1};for(let o=0;o<t.opponentActions.length;o++)s.constraints[`opp_${o}`]={min:0};s.variables.v={v:1};for(let o=0;o<t.opponentActions.length;o++)s.variables.v[`opp_${o}`]=-1;for(let o=0;o<t.playerActions.length;o++){const r=t.playerActions[o],a=`${Vt}${r}`;s.variables[a]={prob_sum:1};for(let l=0;l<t.opponentActions.length;l++){const h=e[o][l]+i;s.variables[a][`opp_${l}`]=h}}return s}solveOpponentLP(t){if(t.opponentActions.length===0)return;if(t.opponentActions.length===1){t.opponentStrategy.set(t.opponentActions[0],1),t.opponentValue=this.calculateMinimaxValueForSingleOpponentAction(t);return}const e=[];for(const a of t.playerActions){const l=[];for(const h of t.opponentActions){const u=`${a}-${h}`,m=t.rewards.get(u),c=t.children.get(u);let f=0;m?f=m[1]:c&&(f=c.opponentValue),l.push(f)}e.push(l)}let i=1/0;for(const a of e)for(const l of a)i=Math.min(i,l);const s=i<0?-i+Ct:0,o=this.buildOpponentLPModel(t,e,s),r=J.Solve(o);if(r.feasible){for(const a of t.opponentActions){const l=`${Bt}${a}`,h=r[l]??0;t.opponentStrategy.set(a,h)}t.opponentValue=(r.v??0)-s}else{const a=1/t.opponentActions.length;for(const l of t.opponentActions)t.opponentStrategy.set(l,a);t.opponentValue=this.calculateExpectedValue(t,!1)}}buildOpponentLPModel(t,e,i){const s={optimize:"v",opType:"max",constraints:{},variables:{}};s.constraints.prob_sum={equal:1};for(let o=0;o<t.playerActions.length;o++)s.constraints[`player_${o}`]={min:0};s.variables.v={v:1};for(let o=0;o<t.playerActions.length;o++)s.variables.v[`player_${o}`]=-1;for(let o=0;o<t.opponentActions.length;o++){const r=t.opponentActions[o],a=`${Bt}${r}`;s.variables[a]={prob_sum:1};for(let l=0;l<t.playerActions.length;l++){const h=e[l][o]+i;s.variables[a][`player_${l}`]=h}}return s}calculateMinimaxValueForSinglePlayerAction(t){const e=t.playerActions[0];let i=1/0;for(const s of t.opponentActions){const o=`${e}-${s}`,r=t.rewards.get(o),a=t.children.get(o);let l=0;r?l=r[0]:a&&(l=a.playerValue),i=Math.min(i,l)}return i===1/0?0:i}calculateMinimaxValueForSingleOpponentAction(t){const e=t.opponentActions[0];let i=1/0;for(const s of t.playerActions){const o=`${s}-${e}`,r=t.rewards.get(o),a=t.children.get(o);let l=0;r?l=r[1]:a&&(l=a.opponentValue),i=Math.min(i,l)}return i===1/0?0:i}calculateExpectedValue(t,e){let i=0;for(const s of t.playerActions){const o=t.playerStrategy.get(s)??1/t.playerActions.length;for(const r of t.opponentActions){const a=t.opponentStrategy.get(r)??1/t.opponentActions.length,l=`${s}-${r}`,h=t.rewards.get(l),u=t.children.get(l);let m=0;h?m=e?h[0]:h[1]:u&&(m=e?u.playerValue:u.opponentValue),i+=o*a*m}}return i}solve(t){for(const e of this.topologicalOrder){const i=this.nodes.get(e);!i||i.isTerminal||(this.solvePlayerLP(i),this.solveOpponentLP(i))}}getAverageStrategy(t){const e=this.nodes.get(t);if(!e)return null;if(e.playerStrategy.size===0&&e.playerActions.length>0){const i=new Map,s=1/e.playerActions.length;for(const o of e.playerActions)i.set(o,s);return i}return new Map(e.playerStrategy)}getAverageOpponentStrategy(t){const e=this.nodes.get(t);if(!e)return null;if(e.opponentStrategy.size===0&&e.opponentActions.length>0){const i=new Map,s=1/e.opponentActions.length;for(const o of e.opponentActions)i.set(o,s);return i}return new Map(e.opponentStrategy)}getRootStrategy(){return this.getAverageStrategy(this.gameTree.root)}}let K=null,Q=null;function rt(n){self.postMessage(n)}function Et(n){if(!K||!Q)return null;const t=Q.nodes[n];if(!t)return null;const e=K.getAverageStrategy(n),i=[];if(t.playerActions)for(const r of t.playerActions.actions){const a=e?.get(r.actionId)??0;i.push({actionId:r.actionId,probability:a})}const s=K.getAverageOpponentStrategy(n),o=[];if(t.opponentActions)for(const r of t.opponentActions.actions){const a=s?.get(r.actionId)??0;o.push({actionId:r.actionId,probability:a})}return{nodeId:n,playerStrategy:i,opponentStrategy:o}}function Tt(){if(!Q)return{};const n={};for(const t of Object.keys(Q.nodes)){const e=Et(t);e&&(n[t]=e)}return n}async function He(n){Q=n,K=new We(n),K.solve();const t=Tt();rt({type:"complete",strategies:t})}self.onmessage=async n=>{const t=n.data;switch(t.type){case"start":try{await He(t.gameTree)}catch(e){rt({type:"error",message:e instanceof Error?e.message:"Unknown error"})}break;case"pause":break;case"resume":break;case"getStrategy":{const e=Et(t.nodeId);rt({type:"strategy",nodeId:t.nodeId,data:e});break}case"getAllStrategies":rt({type:"allStrategies",strategies:Tt()});break}};
