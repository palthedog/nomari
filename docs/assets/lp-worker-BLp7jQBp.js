function Ft(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var at={exports:{}},zt=at.exports,mt;function jt(){return mt||(mt=1,(function(s){(function(t,e){s.exports?s.exports=e():t.log=e()})(zt,function(){var t=function(){},e="undefined",i=typeof window!==e&&typeof window.navigator!==e&&/Trident\/|MSIE /.test(window.navigator.userAgent),n=["trace","debug","info","warn","error"],o={},r=null;function a(p,v){var g=p[v];if(typeof g.bind=="function")return g.bind(p);try{return Function.prototype.bind.call(g,p)}catch{return function(){return Function.prototype.apply.apply(g,[p,arguments])}}}function l(){console.log&&(console.log.apply?console.log.apply(console,arguments):Function.prototype.apply.apply(console.log,[console,arguments])),console.trace&&console.trace()}function h(p){return p==="debug"&&(p="log"),typeof console===e?!1:p==="trace"&&i?l:console[p]!==void 0?a(console,p):console.log!==void 0?a(console,"log"):t}function u(){for(var p=this.getLevel(),v=0;v<n.length;v++){var g=n[v];this[g]=v<p?t:this.methodFactory(g,p,this.name)}if(this.log=this.debug,typeof console===e&&p<this.levels.SILENT)return"No console available for logging"}function m(p){return function(){typeof console!==e&&(u.call(this),this[p].apply(this,arguments))}}function c(p,v,g){return h(p)||m.apply(this,arguments)}function f(p,v){var g=this,w,y,x,b="loglevel";typeof p=="string"?b+=":"+p:typeof p=="symbol"&&(b=void 0);function I(S){var O=(n[S]||"silent").toUpperCase();if(!(typeof window===e||!b)){try{window.localStorage[b]=O;return}catch{}try{window.document.cookie=encodeURIComponent(b)+"="+O+";"}catch{}}}function C(){var S;if(!(typeof window===e||!b)){try{S=window.localStorage[b]}catch{}if(typeof S===e)try{var O=window.document.cookie,P=encodeURIComponent(b),E=O.indexOf(P+"=");E!==-1&&(S=/^([^;]+)/.exec(O.slice(E+P.length+1))[1])}catch{}return g.levels[S]===void 0&&(S=void 0),S}}function V(){if(!(typeof window===e||!b)){try{window.localStorage.removeItem(b)}catch{}try{window.document.cookie=encodeURIComponent(b)+"=; expires=Thu, 01 Jan 1970 00:00:00 UTC"}catch{}}}function B(S){var O=S;if(typeof O=="string"&&g.levels[O.toUpperCase()]!==void 0&&(O=g.levels[O.toUpperCase()]),typeof O=="number"&&O>=0&&O<=g.levels.SILENT)return O;throw new TypeError("log.setLevel() called with invalid level: "+S)}g.name=p,g.levels={TRACE:0,DEBUG:1,INFO:2,WARN:3,ERROR:4,SILENT:5},g.methodFactory=v||c,g.getLevel=function(){return x??y??w},g.setLevel=function(S,O){return x=B(S),O!==!1&&I(x),u.call(g)},g.setDefaultLevel=function(S){y=B(S),C()||g.setLevel(S,!1)},g.resetLevel=function(){x=null,V(),u.call(g)},g.enableAll=function(S){g.setLevel(g.levels.TRACE,S)},g.disableAll=function(S){g.setLevel(g.levels.SILENT,S)},g.rebuild=function(){if(r!==g&&(w=B(r.getLevel())),u.call(g),r===g)for(var S in o)o[S].rebuild()},w=B(r?r.getLevel():"WARN");var A=C();A!=null&&(x=B(A)),u.call(g)}r=new f,r.getLogger=function(v){if(typeof v!="symbol"&&typeof v!="string"||v==="")throw new TypeError("You must supply a name when creating a logger.");var g=o[v];return g||(g=o[v]=new f(v,r.methodFactory)),g};var d=typeof window!==e?window.log:void 0;return r.noConflict=function(){return typeof window!==e&&window.log===r&&(window.log=d),r},r.getLoggers=function(){return o},r.default=r,r})})(at)),at.exports}var Nt=jt(),W=Ft(Nt);class Ot{constructor(t,e,i,n){this.feasible=i,this.evaluation=e,this.bounded=n,this._tableau=t,this.solutionSet={}}generateSolutionSet(){const t={},e=this._tableau,i=e.varIndexByRow,n=e.variablesPerIndex,o=e.matrix,r=e.width,a=e.rhsColumn,l=e.height-1,h=Math.round(1/e.precision);for(let u=1;u<=l;u+=1){const m=i[u],c=n[m];if(c===void 0||c.isSlack===!0)continue;const f=o[u*r+a];t[c.id]=Math.round((Number.EPSILON+f)*h)/h}return t}}class Lt extends Ot{constructor(t,e,i,n,o){super(t,e,i,n),this.iter=o}}class vt{constructor(t=64){this.heap=new Array(t),this.size=0,this.seqCounter=0,this.pool=new Array(64),this.poolSize=0}allocEntry(t,e){if(this.poolSize>0){const i=this.pool[--this.poolSize];return i.branch=t,i.seq=e,i}return{branch:t,seq:e}}freeEntry(t){this.poolSize<256&&(this.pool[this.poolSize++]=t)}get length(){return this.size}isEmpty(){return this.size===0}clear(){this.size=0,this.seqCounter=0}isBefore(t,e){return t.branch.relaxedEvaluation!==e.branch.relaxedEvaluation?t.branch.relaxedEvaluation<e.branch.relaxedEvaluation:t.seq>e.seq}push(t){const e=this.heap;let i=this.size;this.size++,i>=e.length&&(e.length=e.length*2);const n=this.allocEntry(t,this.seqCounter++);for(;i>0;){const o=i-1>>1,r=e[o];if(!this.isBefore(n,r))break;e[i]=r,i=o}e[i]=n}pop(){if(this.size===0)return;const t=this.heap,e=t[0],i=e.branch;if(this.size--,this.freeEntry(e),this.size===0)return i;const n=t[this.size];let o=0;const r=this.size>>1;for(;o<r;){let a=(o<<1)+1,l=t[a];const h=a+1;if(h<this.size&&this.isBefore(t[h],l)&&(a=h,l=t[h]),!this.isBefore(l,n))break;t[o]=l,o=a}return t[o]=n,i}peek(){return this.size>0?this.heap[0].branch:void 0}}function gt(s,t,e){return{type:s,varIndex:t,value:e}}function ut(s,t){return{relaxedEvaluation:s,cuts:t}}function pt(){const s=(e,i)=>{var n;if(e.restore(),e.addCutConstraints(i),e.simplex(),!((n=e.model)===null||n===void 0)&&n.useMIRCuts){let o=!0;for(;o;){const r=e.computeFractionalVolume(!0);e.applyMIRCuts(),e.simplex(),e.computeFractionalVolume(!0)>=.9*r&&(o=!1)}}};return{applyCuts:s,branchAndCut:e=>{var i,n,o,r,a;const l=new vt;let h=0;const u=(n=(i=e.model)===null||i===void 0?void 0:i.tolerance)!==null&&n!==void 0?n:0;let m=!0,c=1e99;!((o=e.model)===null||o===void 0)&&o.timeout&&(c=Date.now()+e.model.timeout);let f=1/0,d=null;const p=[],v=e.optionalObjectives,g=v.length;for(let x=0;x<g;x+=1)p.push(1/0);const w=ut(-1/0,[]);let y;for(l.push(w);!l.isEmpty()&&m===!0&&Date.now()<c;){!((r=e.model)===null||r===void 0)&&r.isMinimization?y=e.bestPossibleEval*(1+u):y=e.bestPossibleEval*(1-u),u>0&&f<y&&(m=!1);const x=l.pop();if(x.relaxedEvaluation>f)continue;const b=x.cuts;if(s(e,b),h++,e.feasible===!1)continue;const I=e.evaluation;if(!(I>f)){if(I===f){let C=!0;for(let V=0;V<g;V+=1){const B=v[V].reducedCosts[0],A=p[V];if(B>A)break;if(B<A){C=!1;break}}if(C)continue}if(e.isIntegral()===!0){if(e.__isIntegral=!0,h===1){e.branchAndCutIterations=h;return}d=x,f=I;for(let C=0;C<g;C+=1)p[C]=v[C].reducedCosts[0];if(!((a=e.model)===null||a===void 0)&&a.keep_solutions){const C=e.model.tableau.getSolution(),V=C.generateSolutionSet();V.result=C.evaluation,e.model.solutions||(e.model.solutions=[]),e.model.solutions.push(V)}}else{h===1&&e.save();const C=e.getMostFractionalVar(),V=C.index,B=C.value,A=[],S=[],O=b.length;for(let j=0;j<O;j+=1){const M=b[j];M.varIndex===V?M.type==="min"?S.push(M):A.push(M):(A.push(M),S.push(M))}const P=gt("min",V,Math.ceil(B));A.push(P);const E=gt("max",V,Math.floor(B));S.push(E),l.push(ut(I,A)),l.push(ut(I,S))}}}d!==null&&s(e,d.cuts),e.branchAndCutIterations=h}}}class Rt{constructor(){this.pairs=[],this.positions=new Map}add(t,e){const i=`${t}_${e}`,n=this.pairs.length;this.pairs.push([t,e]);const o=this.positions.get(i);if(o===void 0)return this.positions.set(i,[n]),[];for(const r of o){const a=n-r;if(a>this.pairs.length-n)continue;let l=!0;for(let h=1;h<a&&r+a+h<this.pairs.length;h++){const u=this.pairs[r+h],m=this.pairs[r+a+h];if(u[0]!==m[0]||u[1]!==m[1]){l=!1;break}}if(l)return[r,a]}return o.push(n),[]}}function $t(){return this.bounded=!0,this.phase1(),this.feasible===!0&&this.phase2(),this}function Dt(){const s=this.matrix,t=this.width,e=this.rhsColumn,i=t-1,n=this.height-1,r=-this.precision;let a=0;const l=1e4;for(;a<l;){let h=0,u=r;for(let d=1;d<=n;d++){const p=s[d*t+e];p<u&&(u=p,h=d)}if(h===0)return this.feasible=!0,this.setEvaluation(),a;let m=0,c=1/0;const f=h*t;for(let d=1;d<=i;d++){const p=s[f+d];if(p<r){const v=s[d];if(v>=r){const g=v/-p;g<c&&(c=g,m=d)}}}if(m===0)return this.feasible=!1,-1;this.pivot(h,m),a++}return this.feasible=!1,a}function qt(){const t=this.model.checkForCycles?new Rt:null,e=this.matrix,i=this.width,n=this.rhsColumn,o=this.width-1,r=this.height-1,l=-this.precision,h=this.unrestrictedVars,u=this.varIndexByRow,m=this.varIndexByCol;let c,f=0;for(;;){let d=0,p=l;for(let y=1;y<=r;y++){const x=e[y*i+n];x<p&&(p=x,d=y)}if(d===0)return this.feasible=!0,f;let v=0,g=-1/0;const w=d*i;for(let y=1;y<=o;y++){const x=e[w+y];if(c=h[m[y]]===!0,c||x<l){const b=-e[y]/x;g<b&&(g=b,v=y)}}if(v===0)return this.feasible=!1,f;if(t){const y=t.add(u[d],m[v]);if(y.length>0)return this.model.messages.push("Cycle in phase 1"),this.model.messages.push("Start :"+y[0]),this.model.messages.push("Length :"+y[1]),this.feasible=!1,f}this.pivot(d,v),f+=1}}function Ut(){const t=this.model.checkForCycles?new Rt:null,e=this.matrix,i=this.width,n=this.rhsColumn,o=this.width-1,r=this.height-1,a=this.precision,l=-a,h=this.optionalObjectives.length;let u=null;const m=this.unrestrictedVars,c=this.varIndexByCol,f=this.varIndexByRow;let d=0,p,v;const g=o,w=this.pricingBatchSize>0?this.pricingBatchSize:Math.min(500,Math.max(50,Math.floor(Math.sqrt(g)))),y=g>w*2;for(;;){h>0&&(u=[]);let x=0,b=a,I=!1;if(y){const B=this.pricingBatchStart;let A=0;const S=Math.ceil(g/w);for(;x===0&&A<S;){const O=this.pricingBatchStart,P=Math.min(O+w-1,o);for(let E=O;E<=P;E++){if(p=e[E],v=m[c[E]]===!0,h>0&&l<p&&p<a){u?.push(E);continue}if(v&&p<0){-p>b&&(b=-p,x=E,I=!0);continue}p>b&&(b=p,x=E,I=!1)}this.pricingBatchStart=P>=o?1:P+1,A++}x!==0&&(this.pricingBatchStart=B)}else for(let B=1;B<=o;B++){if(p=e[B],v=m[c[B]]===!0,h>0&&l<p&&p<a){u?.push(B);continue}if(v&&p<0){-p>b&&(b=-p,x=B,I=!0);continue}p>b&&(b=p,x=B,I=!1)}if(h>0){let B=0;for(;x===0&&u&&u.length>0&&B<h;){const A=[],S=this.optionalObjectives[B].reducedCosts;b=a;for(let O=0;O<u.length;O++){const P=u[O];if(p=S[P],v=m[c[P]]===!0,l<p&&p<a){A.push(P);continue}if(v&&p<0){-p>b&&(b=-p,x=P,I=!0);continue}p>b&&(b=p,x=P,I=!1)}u=A,B+=1}}if(x===0)return this.setEvaluation(),this.simplexIters+=1,d;let C=0,V=1/0;for(let B=1;B<=r;B++){const A=B*i,S=e[A+n],O=e[A+x];if(l<O&&O<a)continue;if(O>0&&a>S&&S>l){V=0,C=B;break}const P=I?-S/O:S/O;P>a&&V>P&&(V=P,C=B)}if(V===1/0)return this.evaluation=-1/0,this.bounded=!1,this.unboundedVarIndex=c[x],d;if(t){const B=t.add(f[C],c[x]);if(B.length>0)return this.model.messages.push("Cycle in phase 2"),this.model.messages.push("Start :"+B[0]),this.model.messages.push("Length :"+B[1]),this.feasible=!1,d}this.pivot(C,x),d+=1}}let H=new Int32Array(1024),ot=new Float64Array(1024);function Wt(s,t){const e=this.matrix,i=this.width;i>H.length&&(H=new Int32Array(i*2),ot=new Float64Array(i*2));const n=s*i,o=e[n+t],r=1/o,a=this.height,l=this.varIndexByRow[s],h=this.varIndexByCol[t];this.varIndexByRow[s]=h,this.varIndexByCol[t]=l,this.rowByVarIndex[h]=s,this.rowByVarIndex[l]=-1,this.colByVarIndex[h]=-1,this.colByVarIndex[l]=t;let u=0;for(let f=0;f<i;f++){const d=n+f,p=e[d];if(p>=-1e-16&&p<=1e-16)e[d]=0;else{const v=p/o;e[d]=v,H[u]=f,ot[u]=v,u++}}e[n+t]=r;for(let f=0;f<a;f++)if(f!==s){const d=f*i,p=e[d+t];if(!(p>=-1e-16&&p<=1e-16)){const v=p;if(v>=-1e-16&&v<=1e-16)v!==0&&(e[d+t]=0);else{for(let g=0;g<u;g++){const w=H[g],y=ot[g];y>=-1e-16&&y<=1e-16?y!==0&&(e[n+w]=0):e[d+w]-=v*y}e[d+t]=-v/o}}}const m=this.optionalObjectives,c=m.length;if(c>0)for(let f=0;f<c;f++){const d=m[f].reducedCosts,p=d[t];if(p!==0){for(let v=0;v<u;v++){const g=H[v];d[g]-=p*ot[v]}d[t]=-p*r}}}function Ht(s){for(let t=0;t<s.length-1;t++)for(let e=t+1;e<s.length;e++){const i=s[t],n=s[e];if(i[0]===n[0]&&i[1]===n[1]){if(e-t>s.length-e)break;let o=!0;for(let r=1;r<e-t;r++){const a=s[t+r],l=s[e+r];if(a[0]!==l[0]||a[1]!==l[1]){o=!1;break}}if(o)return[t,e-t]}}return[]}class lt{constructor(t,e,i=1e-12){this.nRows=t,this.nCols=e,this.precision=i,this.values=[],this.rowIndices=[],this.colPointers=new Array(e+1).fill(0),this.workVector=new Float64Array(Math.max(t,e)),this.workIndices=[]}static fromDense(t,e,i,n=1e-12){const o=new lt(i,e,n),r=[],a=[],l=[0];for(let h=0;h<e;h++){for(let u=0;u<i;u++){const m=t[u*e+h];(m<-n||m>n)&&(r.push(m),a.push(u))}l.push(r.length)}return o.values=r,o.rowIndices=a,o.colPointers=l,o}toDense(){const t=new Float64Array(this.nRows*this.nCols);for(let e=0;e<this.nCols;e++){const i=this.colPointers[e],n=this.colPointers[e+1];for(let o=i;o<n;o++){const r=this.rowIndices[o];t[r*this.nCols+e]=this.values[o]}}return t}get(t,e){const i=this.colPointers[e],n=this.colPointers[e+1];let o=i,r=n;for(;o<r;){const a=o+r>>>1;this.rowIndices[a]<t?o=a+1:r=a}return o<n&&this.rowIndices[o]===t?this.values[o]:0}set(t,e,i){const n=this.colPointers[e],o=this.colPointers[e+1],r=i>=-this.precision&&i<=this.precision;let a=n,l=o;for(;a<l;){const u=a+l>>>1;this.rowIndices[u]<t?a=u+1:l=u}if(a<o&&this.rowIndices[a]===t)if(r){this.values.splice(a,1),this.rowIndices.splice(a,1);for(let u=e+1;u<=this.nCols;u++)this.colPointers[u]--}else this.values[a]=i;else if(!r){this.values.splice(a,0,i),this.rowIndices.splice(a,0,t);for(let u=e+1;u<=this.nCols;u++)this.colPointers[u]++}}getColumn(t){const e=this.colPointers[t],i=this.colPointers[t+1],n=i-e;return{indices:this.rowIndices.slice(e,i),values:this.values.slice(e,i),length:n}}getRow(t){const e=[],i=[];for(let n=0;n<this.nCols;n++){const o=this.get(t,n);o!==0&&(e.push(n),i.push(o))}return{indices:e,values:i,length:e.length}}getRowDense(t,e){const i=[];e.fill(0,0,this.nCols);for(let n=0;n<this.nCols;n++){const o=this.colPointers[n],r=this.colPointers[n+1];let a=o,l=r;for(;a<l;){const h=a+l>>>1;this.rowIndices[h]<t?a=h+1:l=h}a<r&&this.rowIndices[a]===t&&(e[n]=this.values[a],i.push(n))}return i}addRow(){this.nRows++,this.workVector.length<this.nRows&&(this.workVector=new Float64Array(this.nRows*2))}addColumn(){this.colPointers.push(this.colPointers[this.nCols]),this.nCols++,this.workVector.length<this.nCols&&(this.workVector=new Float64Array(this.nCols*2))}setColumn(t,e){const i=this.colPointers[t],n=this.colPointers[t+1],o=n-i,r=e.length,a=r-o;if(a!==0){if(a>0)for(let h=0;h<a;h++)this.values.splice(n,0,0),this.rowIndices.splice(n,0,0);else this.values.splice(i,-a),this.rowIndices.splice(i,-a);for(let h=t+1;h<=this.nCols;h++)this.colPointers[h]+=a}const l=this.colPointers[t];for(let h=0;h<r;h++)this.values[l+h]=e.values[h],this.rowIndices[l+h]=e.indices[h]}get nnz(){return this.values.length}get density(){return this.nnz/(this.nRows*this.nCols)}scaleRow(t,e){for(let i=0;i<this.nCols;i++){const n=this.colPointers[i],o=this.colPointers[i+1];for(let r=n;r<o;r++)if(this.rowIndices[r]===t){this.values[r]*=e;break}}}addScaledRow(t,e,i){if(i>=-this.precision&&i<=this.precision)return;const n=this.getRowDense(e,this.workVector);for(const o of n){const r=this.workVector[o],a=this.get(t,o)+i*r;this.set(t,o,a)}}pivot(t,e){const i=this.get(t,e);if(i===0)throw new Error("Cannot pivot on zero element");const n=1/i,o=this.getRowDense(t,this.workVector);for(const a of o)this.workVector[a]*=n;this.workVector[e]=n;for(const a of o)this.set(t,a,this.workVector[a]);this.set(t,e,n);const r=this.getColumn(e);for(let a=0;a<r.length;a++){const l=r.indices[a];if(l===t)continue;const h=r.values[a];if(!(h>=-this.precision&&h<=this.precision)){for(const u of o){if(u===e)continue;const m=this.workVector[u];if(m>=-this.precision&&m<=this.precision)continue;const c=this.get(l,u)-h*m;this.set(l,u,c)}this.set(l,e,-h*n)}}return o}clone(){const t=new lt(this.nRows,this.nCols,this.precision);return t.values=this.values.slice(),t.rowIndices=this.rowIndices.slice(),t.colPointers=this.colPointers.slice(),t}}function Zt(){const s=lt.fromDense(this.matrix,this.width,this.height,this.precision);this.bounded=!0,Yt.call(this,s),this.feasible===!0&&Jt.call(this,s);const t=s.toDense();return this.matrix.set(t),this}function Yt(s){const t=this.model.checkForCycles,e=[],i=this.rhsColumn,n=this.width-1,o=this.height-1,r=this.precision;let a,l=0;for(;;){let h=0,u=-r;for(let d=1;d<=o;d++){const p=s.get(d,i);p<u&&(u=p,h=d)}if(h===0)return this.feasible=!0,l;let m=0,c=-1/0;const f=s.getRow(h);for(let d=0;d<f.length;d++){const p=f.indices[d];if(p===0||p===i)continue;const v=f.values[d];if(a=this.unrestrictedVars[this.varIndexByCol[p]]===!0,a||v<-r){const w=-s.get(0,p)/v;c<w&&(c=w,m=p)}}for(let d=1;d<=n;d++){if(d===i)continue;const p=s.get(h,d);if(a=this.unrestrictedVars[this.varIndexByCol[d]]===!0,a||p<-r){const g=-s.get(0,d)/p;c<g&&(c=g,m=d)}}if(m===0)return this.feasible=!1,l;if(t&&(e.push([this.varIndexByRow[h],this.varIndexByCol[m]]),this.checkForCycles(e).length>0))return this.model.messages.push("Cycle in phase 1"),this.feasible=!1,l;At.call(this,s,h,m),l+=1}}function Jt(s){const t=this.model.checkForCycles,e=[],i=this.rhsColumn,n=this.width-1;this.height-1;const o=this.precision;this.optionalObjectives.length;let r=0,a,l;const h=Math.min(500,Math.max(50,Math.floor(Math.sqrt(n))));let u=1;for(;;){let c=0,f=o,d=!1,p=0;const v=Math.ceil(n/h);for(;c===0&&p<v;){const x=Math.min(u+h-1,n);for(let b=u;b<=x;b++)if(b!==i){if(a=s.get(0,b),l=this.unrestrictedVars[this.varIndexByCol[b]]===!0,l&&a<0){-a>f&&(f=-a,c=b,d=!0);continue}a>f&&(f=a,c=b,d=!1)}u=x>=n?1:x+1,p++}if(c===0)return this.setEvaluation(),this.simplexIters+=1,r;let g=0,w=1/0;const y=s.getColumn(c);for(let x=0;x<y.length;x++){const b=y.indices[x];if(b===0)continue;const I=y.values[x];if(I>=-o&&I<=o)continue;const C=s.get(b,i);if(I>0&&o>C&&C>-o){w=0,g=b;break}const V=d?-C/I:C/I;V>o&&w>V&&(w=V,g=b)}if(w===1/0)return this.evaluation=-1/0,this.bounded=!1,this.unboundedVarIndex=this.varIndexByCol[c],r;if(t&&(e.push([this.varIndexByRow[g],this.varIndexByCol[c]]),this.checkForCycles(e).length>0))return this.model.messages.push("Cycle in phase 2"),this.feasible=!1,r;At.call(this,s,g,c),r+=1}}function At(s,t,e){const i=this.varIndexByRow[t],n=this.varIndexByCol[e];this.varIndexByRow[t]=n,this.varIndexByCol[e]=i,this.rowByVarIndex[n]=t,this.rowByVarIndex[i]=-1,this.colByVarIndex[n]=-1,this.colByVarIndex[i]=e,s.pivot(t,e);const o=this.optionalObjectives,r=o.length;if(r>0){const a=s.get(t,e),l=s.getRow(t);for(let h=0;h<r;h++){const u=o[h].reducedCosts,m=u[e];if(m!==0){for(let c=0;c<l.length;c++){const f=l.indices[c],d=l.values[c];d!==0&&(u[f]=u[f]-m*d)}u[e]=-m*a}}}}const Kt=1/0,Qt=.1;function Gt(s){if(s.width*s.height<Kt)return!1;const e=s.matrix,i=s.width,n=1,o=Math.min(20,s.height-1);let r=0;for(let l=n;l<n+o;l++){const h=l*i;for(let u=0;u<i;u++)e[h+u]!==0&&r++}return r/(o*i)<Qt}class ct{constructor(t,e,i,n){this.id=t,this.cost=e,this.index=i,this.value=0,this.priority=n}}class Xt extends ct{constructor(t,e,i,n){super(t,e,i,n),this.isInteger=!0}}class ht extends ct{constructor(t,e){super(t,0,e,0),this.isSlack=!0}}class Mt{constructor(t,e){this.variable=t,this.coefficient=e}}function Pt(s,t,e){if(e===0||e==="required")return null;const i=t===void 0?1:t,n=e===void 0?1:e,o=s.isMinimization===!1?-i:i;return s.addVariable(o,"r"+s.relaxationIndex++,!1,!1,n)}class J{constructor(t,e,i,n){this.slack=new ht("s"+i,i),this.index=i,this.model=n,this.rhs=t,this.isUpperBound=e,this.terms=[],this.termsByVarIndex={},this.relaxation=null}addTerm(t,e){const i=e.index,n=this.termsByVarIndex[i];if(n===void 0){const o=new Mt(e,t);this.termsByVarIndex[i]=o,this.terms.push(o);const r=this.isUpperBound===!0?-t:t;this.model.updateConstraintCoefficient(this,e,r)}else{const o=n.coefficient+t;this.setVariableCoefficient(o,e)}return this}removeTerm(t){return this}setRightHandSide(t){if(t!==this.rhs){let e=t-this.rhs;this.isUpperBound===!0&&(e=-e),this.rhs=t,this.model.updateRightHandSide(this,e)}return this}setVariableCoefficient(t,e){const i=e.index;if(i===-1){console.warn("[Constraint.setVariableCoefficient] Trying to change coefficient of inexistant variable.");return}const n=this.termsByVarIndex[i];if(n===void 0)this.addTerm(t,e);else if(t!==n.coefficient){let o=t-n.coefficient;this.isUpperBound===!0&&(o=-o),n.coefficient=t,this.model.updateConstraintCoefficient(this,e,o)}return this}relax(t,e){this.relaxation=Pt(this.model,t,e),this._relax(this.relaxation)}_relax(t){t!==null&&(this.isUpperBound?this.setVariableCoefficient(-1,t):this.setVariableCoefficient(1,t))}}class yt{constructor(t,e){this.isEquality=!0,this.upperBound=t,this.lowerBound=e,this.model=t.model,this.rhs=t.rhs,this.relaxation=null}addTerm(t,e){return this.upperBound.addTerm(t,e),this.lowerBound.addTerm(t,e),this}removeTerm(t){return this.upperBound.removeTerm(t),this.lowerBound.removeTerm(t),this}setRightHandSide(t){this.upperBound.setRightHandSide(t),this.lowerBound.setRightHandSide(t),this.rhs=t}relax(t,e){this.relaxation=Pt(this.model,t,e),this.upperBound.relaxation=this.relaxation,this.upperBound._relax(this.relaxation),this.lowerBound.relaxation=this.relaxation,this.lowerBound._relax(this.relaxation)}}class te{constructor(t){this.value=t}}function ee(s){const t=s.length,e=this.height,i=e+t,n=this.width,o=n-1,r=this.matrix,a=i*n;if(r.length<a){const h=Math.ceil(a*1.5),u=new Float64Array(h);u.set(r),this.matrix=u}const l=this.matrix;this.height=i,this.nVars=this.width+this.height-2;for(let h=0;h<t;h+=1){const u=s[h],m=e+h,c=m*n,f=u.type==="min"?-1:1,d=u.varIndex;let p=this.rowByVarIndex[d];if(p===-1){l[c+this.rhsColumn]=f*u.value;for(let v=1;v<=o;v+=1)l[c+v]=0;l[c+this.colByVarIndex[d]]=f}else{const v=p*n,g=l[v+this.rhsColumn];l[c+this.rhsColumn]=f*(u.value-g);for(let w=1;w<=o;w+=1)l[c+w]=-f*l[v+w]}p=this.getNewElementIndex(),this.varIndexByRow[m]=p,this.rowByVarIndex[p]=m,this.colByVarIndex[p]=-1,this.variablesPerIndex[p]=new ht("s"+p,p),this.nVars+=1}}function ie(s){if(s===this.costRowIndex)return!1;const t=this.width,e=this.matrix,i=s*t,n=this.variablesPerIndex[this.varIndexByRow[s]];if(n===void 0||!n.isInteger)return!1;const o=e[i+this.rhsColumn],r=o-Math.floor(o);if(r<this.precision||r>1-this.precision)return!1;const a=this.height,l=a*t,h=(a+1)*t;if(e.length<h){const c=Math.ceil(h*1.5),f=new Float64Array(c);f.set(e),this.matrix=f}const u=this.matrix;this.height+=1,this.nVars+=1;const m=this.getNewElementIndex();this.varIndexByRow[a]=m,this.rowByVarIndex[m]=a,this.colByVarIndex[m]=-1,this.variablesPerIndex[m]=new ht("s"+m,m),u[l+this.rhsColumn]=Math.floor(o);for(let c=1;c<this.varIndexByCol.length;c+=1){const f=this.variablesPerIndex[this.varIndexByCol[c]],d=u[i+c];if(f!==void 0&&f.isInteger){const p=Math.floor(d)+Math.max(0,d-Math.floor(d)-r)/(1-r);u[l+c]=p}else u[l+c]=Math.min(0,d/(1-r))}for(let c=0;c<t;c+=1)u[l+c]-=u[i+c];return!0}function ne(s){if(s===this.costRowIndex)return!1;const t=this.width,e=this.matrix,i=s*t,n=this.variablesPerIndex[this.varIndexByRow[s]];if(n===void 0||!n.isInteger)return!1;const o=e[i+this.rhsColumn],r=o-Math.floor(o);if(r<this.precision||r>1-this.precision)return!1;const a=this.height,l=a*t,h=(a+1)*t;if(e.length<h){const c=Math.ceil(h*1.5),f=new Float64Array(c);f.set(e),this.matrix=f}const u=this.matrix;this.height+=1,this.nVars+=1;const m=this.getNewElementIndex();this.varIndexByRow[a]=m,this.rowByVarIndex[m]=a,this.colByVarIndex[m]=-1,this.variablesPerIndex[m]=new ht("s"+m,m),u[l+this.rhsColumn]=-r;for(let c=1;c<this.varIndexByCol.length;c+=1){const f=this.variablesPerIndex[this.varIndexByCol[c]],d=u[i+c],p=d-Math.floor(d);f!==void 0&&f.isInteger?u[l+c]=p<=r?-p:-(1-p)*r/p:u[l+c]=d>=0?-d:d*r/(1-r)}return!0}function se(){const s=this.height;let t=0;const e=10;for(let i=1;i<s&&t<e;i++)this.addLowerBoundMIRCut(i)&&t++}function oe(s){const t=this.width;let e=this.rowByVarIndex[s];if(e===-1){const i=this.colByVarIndex[s];for(let n=1;n<this.height;n+=1){const o=this.matrix[n*t+i];if(o<-this.precision||this.precision<o){e=n;break}}this.pivot(e,i)}return e}function re(s){const t=this.width;let e=this.colByVarIndex[s];if(e===-1){const i=this.rowByVarIndex[s],n=i*t;for(let o=1;o<this.height;o+=1){const r=this.matrix[n+o];if(r<-this.precision||this.precision<r){e=o;break}}this.pivot(i,e)}return e}function ae(){const s=this.width,t=this.matrix,e=this.rhsColumn,i=this.variables.length,n=Math.round(1/this.precision);for(let o=0;o<i;o+=1){const r=this.variables[o],a=r.index,l=this.rowByVarIndex[a];if(l===-1)r.value=0;else{const h=t[l*s+e];r.value=Math.round((h+Number.EPSILON)*n)/n}}}function le(s,t){const e=this.width,i=this.matrix,n=this.rhsColumn,o=this.height-1,r=this.rowByVarIndex[s.index];if(r===-1){const a=this.colByVarIndex[s.index];for(let h=0;h<=o;h+=1){const u=h*e;i[u+n]-=t*i[u+a]}const l=this.optionalObjectives.length;if(l>0)for(let h=0;h<l;h+=1){const u=this.optionalObjectives[h].reducedCosts;u[n]-=t*u[a]}}else i[r*e+n]-=t}function ce(s,t,e){if(s.index===t.index)throw new Error("[Tableau.updateConstraintCoefficient] constraint index should not be equal to variable index !");const i=this.width,n=this.matrix,r=this.putInBase(s.index)*i,a=this.colByVarIndex[t.index];if(a===-1){const h=this.rowByVarIndex[t.index]*i;for(let u=0;u<i;u+=1)n[r+u]+=e*n[h+u]}else n[r+a]-=e}function he(s,t){const e=this.width,i=this.matrix,n=s.index,o=e-1,r=this.colByVarIndex[n];if(r===-1){const a=this.rowByVarIndex[n]*e;if(s.priority===0)for(let l=0;l<=o;l+=1)i[l]+=t*i[a+l];else{const l=this.objectivesByPriority[s.priority].reducedCosts;for(let h=0;h<=o;h+=1)l[h]+=t*i[a+h]}}else i[r]-=t}function ue(s){const t=s.isUpperBound?1:-1,e=this.height,i=this.width,n=i-1,r=(e+1)*i;if(this.matrix.length<r){const c=this.matrix.length,f=Math.max(i*16,Math.floor(c*.5)),d=c+f,p=this.matrix,v=new Float64Array(d);v.set(p),this.matrix=v}const a=this.matrix,l=e*i;for(let c=0;c<=n;c+=1)a[l+c]=0;a[l+this.rhsColumn]=t*s.rhs;const h=s.terms,u=h.length;for(let c=0;c<u;c+=1){const f=h[c],d=f.coefficient,p=f.variable.index,v=this.rowByVarIndex[p];if(v===-1)a[l+this.colByVarIndex[p]]+=t*d;else{const g=v*i;for(let w=0;w<=n;w+=1)a[l+w]-=t*d*a[g+w]}}const m=s.index;this.varIndexByRow[e]=m,this.rowByVarIndex[m]=e,this.colByVarIndex[m]=-1,this.height+=1}function fe(s){const t=s.index,e=this.height-1,i=this.width,n=this.matrix,o=this.putInBase(t),r=o*i,a=e*i;for(let l=0;l<i;l++){const h=n[a+l];n[a+l]=n[r+l],n[r+l]=h}this.varIndexByRow[o]=this.varIndexByRow[e],this.varIndexByRow[e]=-1,this.rowByVarIndex[t]=-1,this.availableIndexes[this.availableIndexes.length]=t,s.slack.index=-1,this.height-=1}function de(s){this.height-1;const t=this.width,e=t+1,i=this.height,n=this.model.isMinimization===!0?-s.cost:s.cost,o=s.priority,r=this.matrix,a=new Float64Array(i*e);for(let u=0;u<i;u++){const m=u*t,c=u*e;for(let f=0;f<t;f++)a[c+f]=r[m+f]}this.matrix=a,this.width=e;const l=e-1,h=this.optionalObjectives.length;if(h>0)for(let u=0;u<h;u+=1)this.optionalObjectives[u].reducedCosts[l]=0;o===0?a[l]=n:(this.setOptionalObjective(o,l,n),a[l]=0),this.colByVarIndex[s.index]=l,this.varIndexByCol[l]=s.index}function pe(s){const t=s.index,e=this.width,i=this.matrix,n=e-1,o=this.takeOutOfBase(t),r=this.height-1;for(let a=0;a<=r;a+=1){const l=a*e;i[l+o]=i[l+n]}this.varIndexByCol[o]=this.varIndexByCol[n],this.rowByVarIndex[t]=-1,this.colByVarIndex[t]=-1,this.availableIndexes[this.availableIndexes.length]=t,this.width-=1}function ve(){const s=new this.constructor(this.precision,this.branchAndCutService);s.width=this.width,s.height=this.height,s.nVars=this.nVars,s.model=this.model,s.variables=this.variables,s.variablesPerIndex=this.variablesPerIndex,s.unrestrictedVars=this.unrestrictedVars,s.lastElementIndex=this.lastElementIndex,s.varIndexByRow=this.varIndexByRow.slice(),s.varIndexByCol=this.varIndexByCol.slice(),s.rowByVarIndex=this.rowByVarIndex.slice(),s.colByVarIndex=this.colByVarIndex.slice(),s.availableIndexes=this.availableIndexes.slice();const t=[];for(let e=0;e<this.optionalObjectives.length;e++)t[e]=this.optionalObjectives[e].copy();return s.optionalObjectives=t,s.objectivesByPriority={...this.objectivesByPriority},s.optionalObjectivePerPriority={...this.optionalObjectivePerPriority},s.matrix=new Float64Array(this.matrix),s}function me(){this.savedState=this.copy()}function ge(){if(this.savedState===null)return;const s=this.savedState;this.nVars=s.nVars,this.model=s.model,this.variables=s.variables,this.variablesPerIndex=s.variablesPerIndex,this.unrestrictedVars=s.unrestrictedVars,this.lastElementIndex=s.lastElementIndex,this.width=s.width,this.height=s.height,this.matrix.set(s.matrix);const t=s.varIndexByRow,e=this.height;for(let a=0;a<e;a+=1)this.varIndexByRow[a]=t[a];this.varIndexByRow.length=e;const i=s.varIndexByCol,n=this.width;for(let a=0;a<n;a+=1)this.varIndexByCol[a]=i[a];this.varIndexByCol.length=n;const o=s.rowByVarIndex,r=s.colByVarIndex;for(let a=0;a<this.nVars;a+=1)this.rowByVarIndex[a]=o[a],this.colByVarIndex[a]=r[a];if(s.optionalObjectives.length>0&&this.optionalObjectives.length>0){this.optionalObjectives=[],this.optionalObjectivePerPriority={};for(let a=0;a<s.optionalObjectives.length;a++){const l=s.optionalObjectives[a].copy();this.optionalObjectives[a]=l,this.optionalObjectivePerPriority[l.priority]=l,this.objectivesByPriority[l.priority]=l}}}function ye(){let s=0;const t=this.width,e=this.matrix,i=this.rhsColumn;for(let n=1;n<this.height;n+=1){const o=this.variablesPerIndex[this.varIndexByRow[n]];if(o!==void 0&&o.isInteger){const r=e[n*t+i],a=r-Math.floor(r);a<this.precision&&-a<this.precision&&(s+=1)}}return s}function we(){const s=this.width,t=this.matrix,e=this.rhsColumn,i=this.model.integerVariables,n=i.length;for(let o=0;o<n;o++){const r=i[o].index,a=this.rowByVarIndex[r];if(a!==-1){const l=t[a*s+e];if(Math.abs(l-Math.round(l))>this.precision)return!1}}return!0}function xe(s){let t=-1;const e=this.width,i=this.matrix,n=this.rhsColumn;for(let o=1;o<this.height;o+=1){const r=this.variablesPerIndex[this.varIndexByRow[o]];if(r!==void 0&&r.isInteger){const a=i[o*e+n],l=Math.abs(a);if(Math.min(l-Math.floor(l),Math.floor(l+1))<this.precision){if(s!==!0)return 0}else t===-1?t=l:t*=l}}return t===-1?0:t}function be(){let s=0,t=null,e=0;const i=this.width,n=this.matrix,o=this.rhsColumn,r=this.model.integerVariables,a=r.length;for(let l=0;l<a;l+=1){const h=r[l].index,u=this.rowByVarIndex[h];if(u!==-1){const m=n[u*i+o],c=Math.abs(m-Math.round(m));c>s&&(s=c,t=h,e=m)}}return{index:t,value:e}}function Ie(){let s=1/0,t=null,e=null;const i=this.width,n=this.matrix,o=this.rhsColumn,r=this.model.integerVariables,a=r.length;for(let l=0;l<a;l+=1){const h=r[l],u=h.index,m=this.rowByVarIndex[u];if(m!==-1){const c=n[m*i+o];Math.abs(c-Math.round(c))>this.precision&&h.cost<s&&(s=h.cost,t=u,e=c)}}return{index:t,value:e}}function Ce(s,t){if(!t)return this;console.log("****",s,"****"),console.log("Nb Variables",this.width-1),console.log("Nb Constraints",this.height-1),console.log("Basic Indexes",this.varIndexByRow),console.log("Non Basic Indexes",this.varIndexByCol),console.log("Rows",this.rowByVarIndex),console.log("Cols",this.colByVarIndex);const e=5,i=this.matrix,n=this.width;let o="";const r=[" "];let a,l,h,u,m,c,f;for(l=1;l<this.width;l+=1){h=this.varIndexByCol[l];const w=this.variablesPerIndex[h];w===void 0?u="c"+h:u=w.id,m=u.length,c=" ",f="	",m>5?c+=" ":f+="	",r[l]=c,o+=f+u}console.log(o);let d;const p=this.costRowIndex*n;let v="	";for(a=1;a<this.width;a+=1)d="	",v+=d,v+=r[a],v+=i[p+a].toFixed(e);d="	",v+=d+r[0]+i[p].toFixed(e),console.log(v+"	Z");for(let w=1;w<this.height;w+=1){const y=w*n;let x="	";for(l=1;l<this.width;l+=1)d="	",x+=d+r[l]+i[y+l].toFixed(e);d="	",x+=d+r[0]+i[y].toFixed(e),h=this.varIndexByRow[w];const b=this.variablesPerIndex[h];b===void 0?u="c"+h:u=b.id,console.log(x+"	"+u)}console.log("");const g=this.optionalObjectives.length;if(g>0){console.log("    Optional objectives:");for(let w=0;w<g;w+=1){const y=this.optionalObjectives[w].reducedCosts;let x="";for(a=1;a<this.width;a+=1)d=y[a]<0?"":" ",x+=d,x+=r[a],x+=y[a].toFixed(e);d=y[0]<0?"":" ",x+=d+r[0]+y[0].toFixed(e),console.log(x+" z"+w)}}return console.log("Feasible?",this.feasible),console.log("evaluation",this.evaluation),this}function _t(s,t,e){return{priority:s,reducedCosts:e?e.slice():new Array(t).fill(0),copy(){return _t(this.priority,this.reducedCosts.length,this.reducedCosts)}}}class Et{constructor(t=1e-8,e){this.model=null,this.matrix=new Float64Array(0),this.width=0,this.height=0,this.costRowIndex=0,this.rhsColumn=0,this.variablesPerIndex=[],this.unrestrictedVars={},this.feasible=!0,this.evaluation=0,this.simplexIters=0,this.varIndexByRow=[],this.varIndexByCol=[],this.rowByVarIndex=[],this.colByVarIndex=[],this.optionalObjectives=[],this.objectivesByPriority={},this.optionalObjectivePerPriority={},this.savedState=null,this.availableIndexes=[],this.lastElementIndex=0,this.variables=[],this.nVars=0,this.bounded=!0,this.unboundedVarIndex=null,this.branchAndCutIterations=0,this.bestPossibleEval=0,this.pricingBatchStart=1,this.pricingBatchSize=0,this.precision=t,this.branchAndCutService=e??pt()}simplex(){return Gt(this)?Zt.call(this):$t.call(this),this}phase1(){return qt.call(this)}phase2(){return Ut.call(this)}dualSimplex(){return Dt.call(this)}pivot(t,e){Wt.call(this,t,e)}checkForCycles(t){return Ht.call(this,t)}countIntegerValues(){return ye.call(this)}isIntegral(){return we.call(this)}computeFractionalVolume(t){return xe.call(this,t)}addCutConstraints(t){ee.call(this,t)}applyMIRCuts(){se.call(this)}addLowerBoundMIRCut(t){return ie.call(this,t)}addUpperBoundMIRCut(t){return ne.call(this,t)}getMostFractionalVar(){return be.call(this)}getFractionalVarWithLowestCost(){return Ie.call(this)}putInBase(t){return oe.call(this,t)}takeOutOfBase(t){return re.call(this,t)}updateVariableValues(){ae.call(this)}updateRightHandSide(t,e){le.call(this,t,e)}updateConstraintCoefficient(t,e,i){ce.call(this,t,e,i)}updateCost(t,e){he.call(this,t,e)}addConstraint(t){ue.call(this,t)}removeConstraint(t){fe.call(this,t)}addVariable(t){de.call(this,t)}removeVariable(t){pe.call(this,t)}copy(){return ve.call(this)}save(){me.call(this)}restore(){ge.call(this)}log(t){return Ce.call(this,t),this}applyCuts(t){this.branchAndCutService.applyCuts(this,t)}branchAndCut(){this.branchAndCutService.branchAndCut(this)}solve(){var t,e;return((e=(t=this.model)===null||t===void 0?void 0:t.getNumberOfIntegerVariables())!==null&&e!==void 0?e:0)>0?this.branchAndCut():this.simplex(),this.updateVariableValues(),this.getSolution()}getSolution(){var t,e,i;const n=((t=this.model)===null||t===void 0?void 0:t.isMinimization)===!0?this.evaluation:-this.evaluation;return((i=(e=this.model)===null||e===void 0?void 0:e.getNumberOfIntegerVariables())!==null&&i!==void 0?i:0)>0?new Lt(this,n,this.feasible,this.bounded,this.branchAndCutIterations):new Ot(this,n,this.feasible,this.bounded)}setOptionalObjective(t,e,i){let n=this.objectivesByPriority[t];if(n===void 0){const o=Math.max(this.width,e+1);n=_t(t,o),this.objectivesByPriority[t]=n,this.optionalObjectivePerPriority[t]=n,this.optionalObjectives.push(n),this.optionalObjectives.sort((r,a)=>r.priority-a.priority)}n.reducedCosts[e]=i}initialize(t,e,i,n){this.variables=i,this.unrestrictedVars=n,this.width=t,this.height=e,this.matrix=new Float64Array(t*e),this.varIndexByRow=new Array(this.height),this.varIndexByCol=new Array(this.width),this.varIndexByRow[0]=-1,this.varIndexByCol[0]=-1,this.nVars=t+e-2,this.rowByVarIndex=new Array(this.nVars),this.colByVarIndex=new Array(this.nVars),this.lastElementIndex=this.nVars}_resetMatrix(){if(this.model===null)throw new Error("[Tableau._resetMatrix] Model not set");const t=this.matrix,e=this.width,i=this.model.variables,n=this.model.constraints,o=i.length,r=n.length,a=this.model.isMinimization===!0?-1:1;for(let h=0;h<o;h+=1){const u=i[h],m=u.priority,c=a*u.cost;m===0?t[h+1]=c:this.setOptionalObjective(m,h+1,c);const f=i[h].index;this.rowByVarIndex[f]=-1,this.colByVarIndex[f]=h+1,this.varIndexByCol[h+1]=f}let l=1;for(let h=0;h<r;h+=1){const u=n[h],m=u.index;this.rowByVarIndex[m]=l,this.colByVarIndex[m]=-1,this.varIndexByRow[l]=m;const c=u.terms,f=c.length,d=l*e;if(l++,u.isUpperBound){for(let p=0;p<f;p+=1){const v=c[p],g=this.colByVarIndex[v.variable.index];t[d+g]=v.coefficient}t[d]=u.rhs}else{for(let p=0;p<f;p+=1){const v=c[p],g=this.colByVarIndex[v.variable.index];t[d+g]=-v.coefficient}t[d]=-u.rhs}}}setModel(t){this.model=t;const e=t.nVariables+1,i=t.nConstraints+1;return this.initialize(e,i,t.variables,t.unrestrictedVariables),this._resetMatrix(),this}getNewElementIndex(){if(this.availableIndexes.length>0)return this.availableIndexes.pop();const t=this.lastElementIndex;return this.lastElementIndex+=1,t}density(){let t=0;const e=this.matrix,i=this.width;for(let n=0;n<this.height;n++){const o=n*i;for(let r=0;r<i;r++)e[o+r]!==0&&(t+=1)}return t/(this.height*this.width)}setEvaluation(){const t=Math.round(1/this.precision),e=this.matrix[this.costRowIndex*this.width+this.rhsColumn],i=Math.round((Number.EPSILON+e)*t)/t;this.evaluation=i,this.simplexIters===0&&(this.bestPossibleEval=i)}}function Ve(s,t){var e,i,n,o,r,a,l;let h=!1;for(const u of s.constraints){if(t.removedConstraints.has(u)||!u.isUpperBound)continue;let m=0;for(const f of u.terms)if(t.fixedVariables.has(f.variable))m+=f.coefficient*t.fixedVariables.get(f.variable);else{const d=(e=t.tightenedBounds.get(f.variable))!==null&&e!==void 0?e:{},p=(i=d.lower)!==null&&i!==void 0?i:0;if(f.coefficient>0)m+=f.coefficient*p;else{const v=(n=d.upper)!==null&&n!==void 0?n:1/0;m+=f.coefficient*v}}const c=u.rhs-m;if(!(c<0))for(const f of u.terms){if(t.fixedVariables.has(f.variable)||!f.variable.isInteger||f.coefficient<=0)continue;const d=(o=t.tightenedBounds.get(f.variable))!==null&&o!==void 0?o:{},p=(r=d.lower)!==null&&r!==void 0?r:0,v=(a=d.upper)!==null&&a!==void 0?a:1;if(p>=-.5&&v<=1.5&&f.coefficient*(v-p)>c+1e-6){const w=p+c/f.coefficient;if(w<v-1e-6){const y=(l=t.tightenedBounds.get(f.variable))!==null&&l!==void 0?l:{};(!y.upper||w<y.upper)&&(t.tightenedBounds.set(f.variable,{...y,upper:w}),t.stats.boundsTightened++,h=!0)}}}}return h}function Be(s,t){var e,i,n;let o=!1;for(const r of s.constraints){if(t.removedConstraints.has(r))continue;let a=0,l=0;for(const h of r.terms){const u=t.fixedVariables.get(h.variable);if(u!==void 0){a+=h.coefficient*u,l+=h.coefficient*u;continue}const m=(e=t.tightenedBounds.get(h.variable))!==null&&e!==void 0?e:{},c=(i=m.lower)!==null&&i!==void 0?i:0,f=(n=m.upper)!==null&&n!==void 0?n:1/0;h.coefficient>0?(a+=h.coefficient*c,l+=h.coefficient*(f===1/0?1e10:f)):(a+=h.coefficient*(f===1/0?1e10:f),l+=h.coefficient*c)}if(r.isUpperBound){if(l<=r.rhs+1e-6&&(t.removedConstraints.add(r),t.stats.constraintsRemoved++,o=!0),a>r.rhs+1e-6)return t.isInfeasible=!0,!1}else if(a>=r.rhs-1e-6&&(t.removedConstraints.add(r),t.stats.constraintsRemoved++,o=!0),l<r.rhs-1e-6)return t.isInfeasible=!0,!1}return o}function Se(s){var t,e;const i={fixedVariables:new Map,removedConstraints:new Set,tightenedBounds:new Map,isInfeasible:!1,stats:{variablesFixed:0,constraintsRemoved:0,boundsTightened:0}};let n=!0,o=0;const r=5;for(;n&&o<r;){n=!1,o++;for(const a of s.constraints){if(i.removedConstraints.has(a))continue;const l=a.terms.filter(h=>!i.fixedVariables.has(h.variable));if(l.length===0){let h=0;for(const m of a.terms){const c=i.fixedVariables.get(m.variable);c!==void 0&&(h+=m.coefficient*c)}if(!(a.isUpperBound?h<=a.rhs+1e-6:h>=a.rhs-1e-6))return i.isInfeasible=!0,i;i.removedConstraints.add(a),i.stats.constraintsRemoved++,n=!0}else if(l.length===1){const h=l[0],u=h.variable,m=h.coefficient;let c=a.rhs;for(const d of a.terms)if(d.variable!==u){const p=i.fixedVariables.get(d.variable);p!==void 0&&(c-=d.coefficient*p)}const f=c/m;if(a.isUpperBound)if(m>0){const d=i.tightenedBounds.get(u);(!d?.upper||f<d.upper)&&(i.tightenedBounds.set(u,{...d,upper:f}),i.stats.boundsTightened++,n=!0)}else{const d=i.tightenedBounds.get(u);(!d?.lower||f>d.lower)&&(i.tightenedBounds.set(u,{...d,lower:f}),i.stats.boundsTightened++,n=!0)}i.removedConstraints.add(a),i.stats.constraintsRemoved++}}for(const[a,l]of i.tightenedBounds)if(!i.fixedVariables.has(a)){if(l.lower!==void 0&&l.upper!==void 0){if(l.lower>l.upper+1e-6)return i.isInfeasible=!0,i;if(Math.abs(l.lower-l.upper)<1e-6){let h=l.lower;a.isInteger&&(h=Math.round(h)),i.fixedVariables.set(a,h),i.stats.variablesFixed++,n=!0}}a.isInteger&&l.lower!==void 0&&l.lower>=.5&&((t=l.upper)!==null&&t!==void 0?t:1/0)<=1.5&&(i.fixedVariables.set(a,1),i.stats.variablesFixed++,n=!0),a.isInteger&&l.upper!==void 0&&l.upper<=.5&&((e=l.lower)!==null&&e!==void 0?e:0)>=-.5&&(i.fixedVariables.set(a,0),i.stats.variablesFixed++,n=!0)}if(Be(s,i)&&(n=!0),i.isInfeasible)return i;Ve(s,i)&&(n=!0)}return i}class ft{constructor(t,e,i){this.tableau=new Et(t,i),this.name=e,this.variables=[],this.integerVariables=[],this.unrestrictedVariables={},this.constraints=[],this.nConstraints=0,this.nVariables=0,this.isMinimization=!0,this.tableauInitialized=!1,this.relaxationIndex=1,this.useMIRCuts=!1,this.checkForCycles=!0,this.messages=[],this.availableIndexes=[],this.lastElementIndex=0,this.usePresolve=!0,this.presolveResult=null}minimize(){return this.isMinimization=!0,this}maximize(){return this.isMinimization=!1,this}_getNewElementIndex(){if(this.availableIndexes.length>0)return this.availableIndexes.pop();const t=this.lastElementIndex;return this.lastElementIndex+=1,t}_addConstraint(t){const e=t.slack;this.tableau.variablesPerIndex[e.index]=e,this.constraints.push(t),this.nConstraints+=1,this.tableauInitialized===!0&&this.tableau.addConstraint(t)}smallerThan(t){const e=new J(t,!0,this.tableau.getNewElementIndex(),this);return this._addConstraint(e),e}greaterThan(t){const e=new J(t,!1,this.tableau.getNewElementIndex(),this);return this._addConstraint(e),e}equal(t){const e=new J(t,!0,this.tableau.getNewElementIndex(),this);this._addConstraint(e);const i=new J(t,!1,this.tableau.getNewElementIndex(),this);return this._addConstraint(i),new yt(e,i)}addVariable(t,e,i,n,o){if(typeof o=="string")switch(o){case"required":o=0;break;case"strong":o=1;break;case"medium":o=2;break;case"weak":o=3;break;default:o=0;break}const r=this.tableau.getNewElementIndex(),a=e??"v"+r,l=t??0,h=o??0;let u;if(i){const m=new Xt(a,l,r,h);this.integerVariables.push(m),u=m}else u=new ct(a,l,r,h);return this.variables.push(u),this.tableau.variablesPerIndex[r]=u,n&&(this.unrestrictedVariables[r]=!0),this.nVariables+=1,this.tableauInitialized===!0&&this.tableau.addVariable(u),u}_removeConstraint(t){const e=this.constraints.indexOf(t);if(e===-1){console.warn("[Model.removeConstraint] Constraint not present in model");return}this.constraints.splice(e,1),this.nConstraints-=1,this.tableauInitialized===!0&&this.tableau.removeConstraint(t),t.relaxation&&this.removeVariable(t.relaxation)}removeConstraint(t){if(t.isEquality){const e=t;this._removeConstraint(e.upperBound),this._removeConstraint(e.lowerBound)}else this._removeConstraint(t);return this}removeVariable(t){const e=this.variables.indexOf(t);if(e===-1){console.warn("[Model.removeVariable] Variable not present in model");return}return this.variables.splice(e,1),this.tableauInitialized===!0&&this.tableau.removeVariable(t),this}updateRightHandSide(t,e){return this.tableauInitialized===!0&&this.tableau.updateRightHandSide(t,e),this}updateConstraintCoefficient(t,e,i){return this.tableauInitialized===!0&&this.tableau.updateConstraintCoefficient(t,e,i),this}setCost(t,e){let i=t-e.cost;return this.isMinimization===!1&&(i=-i),e.cost=t,this.tableau.updateCost(e,i),this}loadJson(t){this.isMinimization=t.opType!=="max";const e=t.variables,i=t.constraints,n={},o={},r=Object.keys(i),a=r.length;for(let d=0;d<a;d+=1){const p=r[d],v=i[p],g=v.equal,w=v.weight,y=v.priority,x=w!==void 0||y!==void 0;let b,I;if(g===void 0){const C=v.min;C!==void 0&&(b=this.greaterThan(C),n[p]=b,x&&b.relax(w,y));const V=v.max;V!==void 0&&(I=this.smallerThan(V),o[p]=I,x&&I.relax(w,y))}else{b=this.greaterThan(g),n[p]=b,I=this.smallerThan(g),o[p]=I;const C=new yt(b,I);x&&C.relax(w,y)}}const l=Object.keys(e),h=l.length;this.tolerance=t.tolerance||0,t.timeout&&(this.timeout=t.timeout),t.options&&(t.options.timeout&&(this.timeout=t.options.timeout),this.tolerance===0&&(this.tolerance=t.options.tolerance||0),t.options.useMIRCuts&&(this.useMIRCuts=t.options.useMIRCuts),typeof t.options.exitOnCycles>"u"?this.checkForCycles=!0:this.checkForCycles=t.options.exitOnCycles,t.options.keep_solutions?this.keep_solutions=t.options.keep_solutions:this.keep_solutions=!1,t.options.presolve!==void 0&&(this.usePresolve=t.options.presolve));const u=t.ints||{},m=t.binaries||{},c=t.unrestricted||{},f=t.optimize;for(let d=0;d<h;d+=1){const p=l[d],v=e[p],g=v[f]||0,w=!!m[p],y=!!u[p]||w,x=!!c[p],b=this.addVariable(g,p,y,x);w&&this.smallerThan(1).addTerm(1,b);const I=Object.keys(v);for(let C=0;C<I.length;C+=1){const V=I[C];if(V===f)continue;const B=v[V],A=n[V];A!==void 0&&A.addTerm(B,b);const S=o[V];S!==void 0&&S.addTerm(B,b)}}return this}getNumberOfIntegerVariables(){return this.integerVariables.length}solve(){if(this.usePresolve&&this.presolveResult===null){if(this.presolveResult=Se(this),this.presolveResult.isInfeasible)return this.tableau.feasible=!1,this.tableau.getSolution();this.applyPresolveReductions(this.presolveResult)}return this.tableauInitialized===!1&&(this.tableau.setModel(this),this.tableauInitialized=!0),this.tableau.solve()}applyPresolveReductions(t){for(const[e,i]of t.fixedVariables)e.value=i,e.cost=0}isFeasible(){return this.tableau.feasible}save(){this.tableau.save()}restore(){this.tableau.restore()}activateMIRCuts(t){this.useMIRCuts=t}debug(t){this.checkForCycles=t}log(t){return this.tableau.log(t)}}const dt={optype:"opType",OpType:"opType",op_type:"opType",type:"opType",optimise:"optimize",Optimize:"optimize",objective:"optimize",constraint:"constraints",Constraints:"constraints",variable:"variables",Variables:"variables",vars:"variables",int:"ints",integers:"ints",Ints:"ints",binary:"binaries",Binaries:"binaries"},Oe={minimum:"min",maximum:"max",Min:"min",Max:"max",eq:"equal",equals:"equal",Equal:"equal"};function Re(s){const t=Object.keys(s);for(const e of t){const i=dt[e];i&&console.warn(`[jsLPSolver] Warning: Model has '${e}' but expected '${i}'. This may cause unexpected behavior.`)}if(!s.optimize&&!t.some(e=>dt[e]==="optimize")&&console.warn("[jsLPSolver] Warning: Model is missing 'optimize' property. The solver needs to know which attribute to optimize."),!s.opType&&!t.some(e=>dt[e]==="opType")&&console.warn(`[jsLPSolver] Warning: Model is missing 'opType' property. Defaulting to 'max'. Use 'opType: "max"' or 'opType: "min"' to be explicit.`),s.constraints){for(const[e,i]of Object.entries(s.constraints))if(typeof i=="object"&&i!==null)for(const n of Object.keys(i)){const o=Oe[n];o&&console.warn(`[jsLPSolver] Warning: Constraint '${e}' has '${n}' but expected '${o}'.`)}}return s}function Ae(s){let t,e,i;if(typeof s.optimize=="string"){if(s.constraints[s.optimize]){t=Math.random();for(e in s.variables)s.variables[e][s.optimize]&&(s.variables[e][t]=s.variables[e][s.optimize]);return s.constraints[t]=s.constraints[s.optimize],delete s.constraints[s.optimize],s}return s}else{for(i in s.optimize)if(s.constraints[i])if(s.constraints[i]==="equal")delete s.optimize[i];else{t=Math.random();for(e in s.variables)s.variables[e][i]&&(s.variables[e][t]=s.variables[e][i]);s.constraints[t]=s.constraints[i],delete s.constraints[i]}return s}}var wt=Object.freeze({__proto__:null,CleanObjectiveAttributes:Ae,WarnOnTypos:Re});const rt={};function Me(s){return JSON.parse(JSON.stringify(s))}function xt(s){if(s&&typeof s=="object")return s;throw new Error("Polyopt requires the solver to return an object result.")}function Pe(s,t,e){for(const i of e)if(!t.variables[i]){typeof s[i]!="number"&&(s[i]=0);for(const[n,o]of Object.entries(t.variables)){const r=o[i],a=s[n];typeof r=="number"&&typeof a=="number"&&(s[i]+=a*r)}}}function _e(s,t){return`base-${t.map(i=>{const n=s[i];return typeof n=="number"?Math.round(n*1e3)/1e3:0}).join("-")}`}function Ee(s){var t;const e={};for(const i of s)for(const[n,o]of Object.entries(i)){if(typeof o!="number")continue;const r=(t=e[n])!==null&&t!==void 0?t:{min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};e[n]={min:Math.min(r.min,o),max:Math.max(r.max,o)}}for(const i of s)for(const n of Object.keys(e))typeof i[n]!="number"&&(i[n]=0),e[n].min=Math.min(e[n].min,i[n]),e[n].max=Math.max(e[n].max,i[n]);for(const[i,n]of Object.entries(e))Number.isFinite(n.min)||(e[i]={min:0,max:0});return e}function bt(s,t){const e=Me(t),i=e.optimize,n=Object.keys(i);if(n.length===0)throw new Error("Multi-objective solve requires at least one objective definition.");const o=e;delete o.optimize,delete o.opType;const r={},a=new Set,l=[];for(const c of n)r[c]=0;for(const c of n){e.optimize=c,e.opType=i[c];const f=xt(s.Solve(e,void 0,void 0,!0));Pe(f,e,n);const d=_e(f,n);if(a.has(d))continue;a.add(d);for(const y of n){const x=f[y];typeof x=="number"&&(r[y]+=x)}const{feasible:p,result:v,bounded:g,...w}=f;l.push(w)}for(const c of n)e.constraints[c]={equal:r[c]/a.size};const h=`cheater-${Math.random()}`;e.optimize=h,e.opType="max";for(const c of Object.values(e.variables))c[h]=1;const u=Ee(l);return{midpoint:xt(s.Solve(e,void 0,void 0,!0)),vertices:l,ranges:u}}function Te(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}function ke(s){var t={is_objective:/(max|min)(imize){0,}\:/i,is_int:/^(?!\/\*)\W{0,}int/i,is_bin:/^(?!\/\*)\W{0,}bin/i,is_constraint:/(\>|\<){0,}\=/i,is_unrestricted:/^\S{0,}unrestricted/i,parse_lhs:/(\-|\+){0,1}\s{0,1}\d{0,}\.{0,}\d{0,}\s{0,}[A-Za-z]\S{0,}/gi,parse_rhs:/(\-|\+){0,1}\d{1,}\.{0,}\d{0,}\W{0,}\;{0,1}$/i,parse_dir:/(\>|\<){0,}\=/gi,parse_int:/[^\s|^\,]+/gi,parse_bin:/[^\s|^\,]+/gi,get_num:/(\-|\+){0,1}(\W|^)\d+\.{0,1}\d{0,}/g,get_word:/[A-Za-z].*/},e={opType:"",optimize:"_obj",constraints:{},variables:{}},i={">=":"min","<=":"max","=":"equal"},n="",o=null,r="",a="",l="",h=0;typeof s=="string"&&(s=s.split(`
`));for(var u=0;u<s.length;u++)if(l="__"+u,n=s[u],o=null,t.is_objective.test(n))e.opType=n.match(/(max|min)/gi)[0],o=n.match(t.parse_lhs).map(function(f){return f.replace(/\s+/,"")}).slice(1),o.forEach(function(f){r=f.match(t.get_num),r===null?f.substr(0,1)==="-"?r=-1:r=1:r=r[0],r=parseFloat(r),a=f.match(t.get_word)[0].replace(/\;$/,""),e.variables[a]=e.variables[a]||{},e.variables[a]._obj=r});else if(t.is_int.test(n))o=n.match(t.parse_int).slice(1),e.ints=e.ints||{},o.forEach(function(f){f=f.replace(";",""),e.ints[f]=1});else if(t.is_bin.test(n))o=n.match(t.parse_bin).slice(1),e.binaries=e.binaries||{},o.forEach(function(f){f=f.replace(";",""),e.binaries[f]=1});else if(t.is_constraint.test(n)){var m=n.indexOf(":"),c=m===-1?n:n.slice(m+1);o=c.match(t.parse_lhs).map(function(f){return f.replace(/\s+/,"")}),o.forEach(function(f){r=f.match(t.get_num),r===null?f.substr(0,1)==="-"?r=-1:r=1:r=r[0],r=parseFloat(r),a=f.match(t.get_word)[0],e.variables[a]=e.variables[a]||{},e.variables[a][l]=r}),h=parseFloat(n.match(t.parse_rhs)[0]),n=i[n.match(t.parse_dir)[0]],e.constraints[l]=e.constraints[l]||{},e.constraints[l][n]=h}else t.is_unrestricted.test(n)&&(o=n.match(t.parse_int).slice(1),e.unrestricted=e.unrestricted||{},o.forEach(function(f){f=f.replace(";",""),e.unrestricted[f]=1}));return e}function Fe(s){if(!s)throw new Error("Solver requires a model to operate on");var t="",e={max:"<=",min:">=",equal:"="},i=new RegExp("[^A-Za-z0-9_[{}/.&#$%~'@^]","gi");if(s.opType){t+=s.opType+":";for(var n in s.variables)s.variables[n][n]=s.variables[n][n]?s.variables[n][n]:1,s.variables[n][s.optimize]&&(t+=" "+s.variables[n][s.optimize]+" "+n.replace(i,"_"))}else t+="max:";t+=`;

`;for(var o in s.constraints)for(var r in s.constraints[o])if(typeof e[r]<"u"){for(var a in s.variables)typeof s.variables[a][o]<"u"&&(t+=" "+s.variables[a][o]+" "+a.replace(i,"_"));t+=" "+e[r]+" "+s.constraints[o][r],t+=`;
`}if(s.ints){t+=`

`;for(var l in s.ints)t+="int "+l.replace(i,"_")+`;
`}if(s.unrestricted){t+=`

`;for(var h in s.unrestricted)t+="unrestricted "+h.replace(i,"_")+`;
`}return t}var ze=function(s){return s.length?ke(s):Fe(s)},je=Te(ze);function It(s,t,e){return{type:s,varIndex:t,value:e}}function Z(s,t,e,i,n,o,r){return{relaxedEvaluation:s,cuts:t,depth:e,branchVarIndex:i,branchDirection:n,branchFractionality:o,parentEvaluation:r}}function Ne(s={}){const{nodeSelection:t="hybrid",branching:e="pseudocost",useDiving:i=!0,strongBranchingCandidates:n=5}=s,o=new Map,r=c=>{let f=o.get(c);return f||(f={upSum:0,upCount:0,downSum:0,downCount:0},o.set(c,f)),f},a=(c,f,d,p)=>{const v=r(c),g=d/(f==="up"?1-p:p);f==="up"?(v.upSum+=g,v.upCount++):(v.downSum+=g,v.downCount++)},l=(c,f)=>{const d=r(c),p=d.upCount>0?d.upSum/d.upCount:1,v=d.downCount>0?d.downSum/d.downCount:1,g=p*(1-f),w=v*f;return Math.max(g,1e-6)*Math.max(w,1e-6)},h=(c,f)=>{const d=c.width,p=c.matrix,v=c.rhsColumn,g=c.model.integerVariables,w=c.precision;let y=[];for(const x of g){const b=x.index,I=c.rowByVarIndex[b];if(I!==-1){const C=p[I*d+v],V=Math.abs(C-Math.round(C));V>w&&y.push({index:b,value:C,fraction:V})}}if(y.length===0)return null;if(e==="most-fractional")return y.sort((x,b)=>b.fraction-x.fraction),{index:y[0].index,value:y[0].value};if(e==="pseudocost"){let x=-1/0,b=y[0];for(const I of y){const C=l(I.index,I.fraction);C>x&&(x=C,b=I)}return{index:b.index,value:b.value}}if(e==="strong"){y.sort((I,C)=>C.fraction-I.fraction),y=y.slice(0,n);let x=-1/0,b=y[0];for(const I of y){const C=r(I.index);if(C.upCount>=2&&C.downCount>=2){const V=l(I.index,I.fraction);V>x&&(x=V,b=I)}else{const V=I.fraction*(1-I.fraction);V>x&&(x=V,b=I)}}return{index:b.index,value:b.value}}return{index:y[0].index,value:y[0].value}},u=(c,f)=>{var d;if(c.restore(),c.addCutConstraints(f),c.simplex(),!((d=c.model)===null||d===void 0)&&d.useMIRCuts&&c.feasible){let p=!0,v=0;const g=3;for(;p&&v<g;){const w=c.computeFractionalVolume(!0);c.applyMIRCuts(),c.simplex();const y=c.computeFractionalVolume(!0);v++,y>=.9*w&&(p=!1)}}};return{applyCuts:u,branchAndCut:c=>{var f,d,p,v,g;const w=new vt,y=[];let x=0;const b=(d=(f=c.model)===null||f===void 0?void 0:f.tolerance)!==null&&d!==void 0?d:0;let I=!0,C=1e99;!((p=c.model)===null||p===void 0)&&p.timeout&&(C=Date.now()+c.model.timeout);let V=1/0,B=null;const A=[];for(let M=0;M<c.optionalObjectives.length;M+=1)A.push(1/0);const S=1;let O=0,P=t==="depth-first"||t==="hybrid";const E=Z(-1/0,[],0);let j;for(P?y.push(E):w.push(E);(P?y.length>0:!w.isEmpty())&&I===!0&&Date.now()<C;){!((v=c.model)===null||v===void 0)&&v.isMinimization?j=c.bestPossibleEval*(1+b):j=c.bestPossibleEval*(1-b),b>0&&V<j&&(I=!1);let M;if(P&&y.length>0)M=y.pop();else if(!w.isEmpty())M=w.pop();else break;if(M.relaxedEvaluation>V)continue;const k=M.cuts;if(c.evaluation,u(c,k),x++,!c.feasible)continue;const F=c.evaluation;if(!(F>V)){if(M.branchVarIndex!==void 0&&M.branchDirection!==void 0&&M.branchFractionality!==void 0&&M.parentEvaluation!==void 0){const _=Math.abs(F-M.parentEvaluation);a(M.branchVarIndex,M.branchDirection,_,M.branchFractionality)}if(F===V){let _=!0;for(let R=0;R<c.optionalObjectives.length&&!(c.optionalObjectives[R].reducedCosts[0]>A[R]);R++)if(c.optionalObjectives[R].reducedCosts[0]<A[R]){_=!1;break}if(_)continue}if(c.isIntegral()){if(c.__isIntegral=!0,O++,x===1){c.branchAndCutIterations=x;return}B=M,V=F;for(let _=0;_<c.optionalObjectives.length;_++)A[_]=c.optionalObjectives[_].reducedCosts[0];if(!((g=c.model)===null||g===void 0)&&g.keep_solutions){const _=c.model.tableau.getSolution(),R=_.generateSolutionSet();R.result=_.evaluation,c.model.solutions||(c.model.solutions=[]),c.model.solutions.push(R)}if(t==="hybrid"&&O>=S)for(P=!1;y.length>0;)w.push(y.pop())}else{x===1&&c.save();const _=h(c);if(!_)continue;const R=_.index,T=_.value,$=[],N=[],q=k.length;for(let U=0;U<q;U++){const z=k[U];z.varIndex===R?z.type==="min"?N.push(z):$.push(z):($.push(z),N.push(z))}const D=Math.ceil(T),tt=Math.floor(T),et=D-T,it=T-tt,nt=It("min",R,D);$.push(nt);const st=It("max",R,tt);N.push(st);const L=M.depth+1;P?(y.push(Z(F,N,L,R,"down",it,F)),y.push(Z(F,$,L,R,"up",et,F))):(w.push(Z(F,$,L,R,"up",et,F)),w.push(Z(F,N,L,R,"down",it,F)))}}}B!==null&&u(c,B.cuts),c.branchAndCutIterations=x}}}function Le(s){return{matrix:new Float64Array(s.matrix),width:s.width,height:s.height,nVars:s.nVars,varIndexByRow:s.varIndexByRow.slice(),varIndexByCol:s.varIndexByCol.slice(),rowByVarIndex:s.rowByVarIndex.slice(),colByVarIndex:s.colByVarIndex.slice(),availableIndexes:s.availableIndexes.slice(),lastElementIndex:s.lastElementIndex,evaluation:s.evaluation,feasible:s.feasible}}function $e(s,t){s.matrix.length>=t.matrix.length?s.matrix.set(t.matrix):s.matrix=new Float64Array(t.matrix),s.width=t.width,s.height=t.height,s.nVars=t.nVars;const e=t.height;for(let o=0;o<e;o++)s.varIndexByRow[o]=t.varIndexByRow[o];s.varIndexByRow.length=e;const i=t.width;for(let o=0;o<i;o++)s.varIndexByCol[o]=t.varIndexByCol[o];s.varIndexByCol.length=i;const n=t.nVars;for(let o=0;o<n;o++)s.rowByVarIndex[o]=t.rowByVarIndex[o],s.colByVarIndex[o]=t.colByVarIndex[o];s.availableIndexes=t.availableIndexes.slice(),s.lastElementIndex=t.lastElementIndex,s.evaluation=t.evaluation,s.feasible=t.feasible}function Ct(s,t,e){return{type:s,varIndex:t,value:e}}function Y(s,t,e,i,n){return{relaxedEvaluation:s,cuts:t,depth:e,parentCheckpoint:i,newCut:n}}function De(s={}){const{nodeSelection:t="hybrid",branching:e="pseudocost",maxCheckpoints:i=50}=s,n=new Map,o=c=>{let f=n.get(c);return f||(f={upSum:0,upCount:0,downSum:0,downCount:0},n.set(c,f)),f},r=(c,f,d,p)=>{const v=o(c),g=d/(f==="up"?1-p:p);f==="up"?(v.upSum+=g,v.upCount++):(v.downSum+=g,v.downCount++)},a=(c,f)=>{const d=o(c),p=d.upCount>0?d.upSum/d.upCount:1,v=d.downCount>0?d.downSum/d.downCount:1,g=p*(1-f),w=v*f;return Math.max(g,1e-6)*Math.max(w,1e-6)},l=c=>{const f=c.width,d=c.matrix,p=c.rhsColumn,v=c.model.integerVariables,g=c.precision,w=[];for(const b of v){const I=b.index,C=c.rowByVarIndex[I];if(C!==-1){const V=d[C*f+p],B=Math.abs(V-Math.round(V));B>g&&w.push({index:I,value:V,fraction:B})}}if(w.length===0)return null;if(e==="most-fractional")return w.sort((b,I)=>I.fraction-b.fraction),w[0];let y=-1/0,x=w[0];for(const b of w){const I=a(b.index,b.fraction);I>y&&(y=I,x=b)}return x},h=(c,f)=>{var d;if(c.restore(),c.addCutConstraints(f),c.simplex(),!((d=c.model)===null||d===void 0)&&d.useMIRCuts&&c.feasible){let p=!0,v=0;const g=3;for(;p&&v<g;){const w=c.computeFractionalVolume(!0);c.applyMIRCuts(),c.simplex();const y=c.computeFractionalVolume(!0);v++,y>=.9*w&&(p=!1)}}},u=(c,f)=>{var d;if(f.parentCheckpoint&&f.newCut?($e(c,f.parentCheckpoint),c.addCutConstraints([f.newCut]),c.simplex()):(c.restore(),c.addCutConstraints(f.cuts),c.simplex()),!((d=c.model)===null||d===void 0)&&d.useMIRCuts&&c.feasible){let p=!0,v=0;const g=3;for(;p&&v<g;){const w=c.computeFractionalVolume(!0);c.applyMIRCuts(),c.simplex();const y=c.computeFractionalVolume(!0);v++,y>=.9*w&&(p=!1)}}};return{applyCuts:h,branchAndCut:c=>{var f,d,p,v,g;const w=new vt,y=[];let x=0,b=0;const I=(d=(f=c.model)===null||f===void 0?void 0:f.tolerance)!==null&&d!==void 0?d:0;let C=!0,V=1e99;!((p=c.model)===null||p===void 0)&&p.timeout&&(V=Date.now()+c.model.timeout);let B=1/0,A=null;const S=[];for(let M=0;M<c.optionalObjectives.length;M++)S.push(1/0);const O=1;let P=0,E=t==="depth-first"||t==="hybrid";const j=Y(-1/0,[],0);for(E?y.push(j):w.push(j);(E?y.length>0:!w.isEmpty())&&C===!0&&Date.now()<V;){let M;!((v=c.model)===null||v===void 0)&&v.isMinimization?M=c.bestPossibleEval*(1+I):M=c.bestPossibleEval*(1-I),I>0&&B<M&&(C=!1);let k;if(E&&y.length>0)k=y.pop();else if(!w.isEmpty())k=w.pop();else break;if(k.relaxedEvaluation>B)continue;const F=c.evaluation;if(u(c,k),x++,!c.feasible)continue;const _=c.evaluation;if(!(_>B)){if(k.newCut&&F!==0){const R=Math.abs(_-F);r(k.newCut.varIndex,k.newCut.type==="min"?"up":"down",R,.5)}if(_===B){let R=!0;for(let T=0;T<c.optionalObjectives.length&&!(c.optionalObjectives[T].reducedCosts[0]>S[T]);T++)if(c.optionalObjectives[T].reducedCosts[0]<S[T]){R=!1;break}if(R)continue}if(c.isIntegral()){if(c.__isIntegral=!0,P++,x===1){c.branchAndCutIterations=x;return}A=k,B=_;for(let R=0;R<c.optionalObjectives.length;R++)S[R]=c.optionalObjectives[R].reducedCosts[0];if(!((g=c.model)===null||g===void 0)&&g.keep_solutions){const R=c.model.tableau.getSolution(),T=R.generateSolutionSet();T.result=R.evaluation,c.model.solutions||(c.model.solutions=[]),c.model.solutions.push(T)}if(t==="hybrid"&&P>=O)for(E=!1;y.length>0;)w.push(y.pop())}else{x===1&&c.save();const R=l(c);if(!R)continue;const T=R.index,$=R.value;let N;E&&b<i&&(N=Le(c),b++);const q=[],D=[],tt=k.cuts.length;for(let U=0;U<tt;U++){const z=k.cuts[U];z.varIndex===T?z.type==="min"?D.push(z):q.push(z):(q.push(z),D.push(z))}const et=Math.ceil($),it=Math.floor($),nt=Ct("min",T,et);q.push(nt);const st=Ct("max",T,it);D.push(st);const L=k.depth+1;E?(y.push(Y(_,D,L,N,st)),y.push(Y(_,q,L,N,nt))):(w.push(Y(_,q,L)),w.push(Y(_,D,L)))}}}A!==null&&h(c,A.cuts),c.branchAndCutIterations=x}}}class qe{constructor(){this.Model=ft,this.Tableau=Et,this.Constraint=J,this.Variable=ct,this.Numeral=te,this.Term=Mt,this.External=rt,this.ReformatLP=je,this.branchAndCutService=pt(),this.branchAndCut=t=>this.branchAndCutService.branchAndCut(t),this.lastSolvedModel=null}selectBranchAndCutService(t){var e,i,n,o;const r=t.options,a=r?.nodeSelection||r?.branching;return r?.useIncremental===!0?De({nodeSelection:(e=r?.nodeSelection)!==null&&e!==void 0?e:"hybrid",branching:(i=r?.branching)!==null&&i!==void 0?i:"pseudocost"}):a?Ne({nodeSelection:(n=r?.nodeSelection)!==null&&n!==void 0?n:"hybrid",branching:(o=r?.branching)!==null&&o!==void 0?o:"pseudocost",useDiving:!0}):pt()}Solve(t,e,i,n){if(n)for(const a in wt){const l=wt[a];typeof l=="function"&&(t=l(t))}if(!t)throw new Error("Solver requires a model to operate on");if(typeof t.optimize=="object"&&Object.keys(t.optimize).length>1)return bt(this,t);if(t.external)return this.solveWithExternalSolver(t);let o;if(t instanceof ft)o=t;else{const a=this.selectBranchAndCutService(t);o=new ft(e,void 0,a).loadJson(t)}const r=o.solve();return this.lastSolvedModel=o,r.solutionSet=r.generateSolutionSet(),i?r:this.buildSimplifiedResult(r)}solveWithExternalSolver(t){var e;const i=Object.keys(rt),n=JSON.stringify(i);if(!(!((e=t.external)===null||e===void 0)&&e.solver))throw new Error(`Model has 'external' object without solver attribute. Available: ${n}`);const o=t.external.solver;if(!rt[o])throw new Error(`Solver '${o}' not supported. Available: ${n}`);return rt[o].solve(t)}buildSimplifiedResult(t){const e={feasible:t.feasible,result:t.evaluation,bounded:t.bounded};t._tableau.__isIntegral&&(e.isIntegral=!0);for(const i of Object.keys(t.solutionSet)){const n=t.solutionSet[i];n!==0&&(e[i]=n)}return e}MultiObjective(t){return bt(this,t)}}const K=new qe;typeof define=="function"?define([],()=>K):typeof window=="object"?window.solver=K:typeof self=="object"&&(self.solver=K);W.setLevel("warn");const Vt=1,Bt="p_",St="o_";class Ue{constructor(t,e=!1){this.nodeId=t,this.isTerminal=e,this.playerActions=[],this.opponentActions=[],this.children=new Map,this.rewards=new Map,this.playerStrategy=new Map,this.opponentStrategy=new Map,this.playerValue=0,this.opponentValue=0}}class We{constructor(t){this.initialized=!1,this.gameTree=t,this.nodes=new Map,this.nodeMap=new Map,this.topologicalOrder=[]}buildInternalTree(){const t=this.gameTree.nodes[this.gameTree.root];return t?(this.collectAllNodes(t),this.buildLPNode(t)?(this.computeTopologicalOrder(),this.initialized=!0,!0):!1):(W.error(`Root node ${this.gameTree.root} not found in nodes map`),!1)}collectAllNodes(t){this.nodeMap.set(t.nodeId,t);for(const e of t.transitions)if(e.nextNodeId){const i=this.findNodeById(e.nextNodeId);i&&!this.nodeMap.has(i.nodeId)&&this.collectAllNodes(i)}}findNodeById(t){if(this.nodeMap.has(t))return this.nodeMap.get(t);const e=this.gameTree.nodes[t];if(e)return e}isTerminalNode(t){return t.playerReward!==void 0||t.opponentReward!==void 0}buildLPNode(t){if(this.nodes.has(t.nodeId))return this.nodes.get(t.nodeId);const e=this.isTerminalNode(t),i=new Ue(t.nodeId,e);t.playerActions&&(i.playerActions=t.playerActions.actions.map(n=>n.actionId)),t.opponentActions&&(i.opponentActions=t.opponentActions.actions.map(n=>n.actionId));for(const n of t.transitions){const o=`${n.playerActionId}-${n.opponentActionId}`;if(!n.nextNodeId)return W.error(`Transition in node "${t.nodeId}" (player action: ${n.playerActionId}, opponent action: ${n.opponentActionId}) has no nextNodeId`),null;const r=this.nodeMap.get(n.nextNodeId);if(!r)return W.error(`Transition in node "${t.nodeId}" references non-existent node "${n.nextNodeId}"`),null;if(this.isTerminalNode(r)){const l=r.playerReward?.value??0,h=r.opponentReward?.value??0;i.rewards.set(o,[l,h]);continue}const a=this.buildLPNode(r);if(!a)return null;i.children.set(o,a)}return this.nodes.set(t.nodeId,i),i}computeTopologicalOrder(){const t=new Set,e=new Set,i=[],n=o=>{if(e.has(o)||t.has(o))return;e.add(o);const r=this.nodes.get(o);if(r){const a=Array.from(r.children.values());for(const l of a)n(l.nodeId)}e.delete(o),t.add(o),i.push(o)};n(this.gameTree.root),this.topologicalOrder=i}solvePlayerLP(t){if(t.playerActions.length===0)return;if(t.playerActions.length===1){t.playerStrategy.set(t.playerActions[0],1),t.playerValue=this.calculateMinimaxValueForSinglePlayerAction(t);return}const e=[];for(const a of t.playerActions){const l=[];for(const h of t.opponentActions){const u=`${a}-${h}`,m=t.rewards.get(u),c=t.children.get(u);let f=0;m?f=m[0]:c&&(f=c.playerValue),l.push(f)}e.push(l)}let i=1/0;for(const a of e)for(const l of a)i=Math.min(i,l);const n=i<0?-i+Vt:0,o=this.buildPlayerLPModel(t,e,n),r=K.Solve(o);if(r.feasible){for(const a of t.playerActions){const l=`${Bt}${a}`,h=r[l]??0;t.playerStrategy.set(a,h)}t.playerValue=(r.v??0)-n}else{W.warn(`LP solver returned infeasible result for player at node "${t.nodeId}", using uniform strategy`);const a=1/t.playerActions.length;for(const l of t.playerActions)t.playerStrategy.set(l,a);t.playerValue=this.calculateExpectedValue(t,!0)}}buildPlayerLPModel(t,e,i){const n={optimize:"v",opType:"max",constraints:{},variables:{}};n.constraints.prob_sum={equal:1};for(let o=0;o<t.opponentActions.length;o++)n.constraints[`opp_${o}`]={min:0};n.variables.v={v:1};for(let o=0;o<t.opponentActions.length;o++)n.variables.v[`opp_${o}`]=-1;for(let o=0;o<t.playerActions.length;o++){const r=t.playerActions[o],a=`${Bt}${r}`;n.variables[a]={prob_sum:1};for(let l=0;l<t.opponentActions.length;l++){const h=e[o][l]+i;n.variables[a][`opp_${l}`]=h}}return n}solveOpponentLP(t){if(t.opponentActions.length===0)return;if(t.opponentActions.length===1){t.opponentStrategy.set(t.opponentActions[0],1),t.opponentValue=this.calculateMinimaxValueForSingleOpponentAction(t);return}const e=[];for(const a of t.playerActions){const l=[];for(const h of t.opponentActions){const u=`${a}-${h}`,m=t.rewards.get(u),c=t.children.get(u);let f=0;m?f=m[1]:c&&(f=c.opponentValue),l.push(f)}e.push(l)}let i=1/0;for(const a of e)for(const l of a)i=Math.min(i,l);const n=i<0?-i+Vt:0,o=this.buildOpponentLPModel(t,e,n),r=K.Solve(o);if(r.feasible){for(const a of t.opponentActions){const l=`${St}${a}`,h=r[l]??0;t.opponentStrategy.set(a,h)}t.opponentValue=(r.v??0)-n}else{W.warn(`LP solver returned infeasible result for opponent at node "${t.nodeId}", using uniform strategy`);const a=1/t.opponentActions.length;for(const l of t.opponentActions)t.opponentStrategy.set(l,a);t.opponentValue=this.calculateExpectedValue(t,!1)}}buildOpponentLPModel(t,e,i){const n={optimize:"v",opType:"max",constraints:{},variables:{}};n.constraints.prob_sum={equal:1};for(let o=0;o<t.playerActions.length;o++)n.constraints[`player_${o}`]={min:0};n.variables.v={v:1};for(let o=0;o<t.playerActions.length;o++)n.variables.v[`player_${o}`]=-1;for(let o=0;o<t.opponentActions.length;o++){const r=t.opponentActions[o],a=`${St}${r}`;n.variables[a]={prob_sum:1};for(let l=0;l<t.playerActions.length;l++){const h=e[l][o]+i;n.variables[a][`player_${l}`]=h}}return n}calculateMinimaxValueForSinglePlayerAction(t){const e=t.playerActions[0];let i=1/0;for(const n of t.opponentActions){const o=`${e}-${n}`,r=t.rewards.get(o),a=t.children.get(o);let l=0;r?l=r[0]:a&&(l=a.playerValue),i=Math.min(i,l)}return i===1/0?0:i}calculateMinimaxValueForSingleOpponentAction(t){const e=t.opponentActions[0];let i=1/0;for(const n of t.playerActions){const o=`${n}-${e}`,r=t.rewards.get(o),a=t.children.get(o);let l=0;r?l=r[1]:a&&(l=a.opponentValue),i=Math.min(i,l)}return i===1/0?0:i}calculateExpectedValue(t,e){let i=0;for(const n of t.playerActions){const o=t.playerStrategy.get(n)??1/t.playerActions.length;for(const r of t.opponentActions){const a=t.opponentStrategy.get(r)??1/t.opponentActions.length,l=`${n}-${r}`,h=t.rewards.get(l),u=t.children.get(l);let m=0;h?m=e?h[0]:h[1]:u&&(m=e?u.playerValue:u.opponentValue),i+=o*a*m}}return i}solve(t){if(!this.initialized&&!this.buildInternalTree())return!1;for(const e of this.topologicalOrder){const i=this.nodes.get(e);!i||i.isTerminal||(this.solvePlayerLP(i),this.solveOpponentLP(i))}return!0}getAverageStrategy(t){const e=this.nodes.get(t);if(!e)return null;if(e.playerStrategy.size===0&&e.playerActions.length>0){const i=new Map,n=1/e.playerActions.length;for(const o of e.playerActions)i.set(o,n);return i}return new Map(e.playerStrategy)}getAverageOpponentStrategy(t){const e=this.nodes.get(t);if(!e)return null;if(e.opponentStrategy.size===0&&e.opponentActions.length>0){const i=new Map,n=1/e.opponentActions.length;for(const o of e.opponentActions)i.set(o,n);return i}return new Map(e.opponentStrategy)}getRootStrategy(){return this.getAverageStrategy(this.gameTree.root)}}let Q=null,X=null;function G(s){self.postMessage(s)}function Tt(s){if(!Q||!X)return null;const t=X.nodes[s];if(!t)return W.warn(`Node not found in gameTree while getting strategy: ${s}`),null;const e=Q.getAverageStrategy(s),i=[];if(t.playerActions)for(const r of t.playerActions.actions){const a=e?.get(r.actionId)??0;i.push({actionId:r.actionId,probability:a})}const n=Q.getAverageOpponentStrategy(s),o=[];if(t.opponentActions)for(const r of t.opponentActions.actions){const a=n?.get(r.actionId)??0;o.push({actionId:r.actionId,probability:a})}return{nodeId:s,playerStrategy:i,opponentStrategy:o}}function kt(){if(!X)return{};const s={};for(const t of Object.keys(X.nodes)){const e=Tt(t);e&&(s[t]=e)}return s}async function He(s){if(X=s,Q=new We(s),!Q.solve()){G({type:"error",message:"Failed to build game tree for solver. Check console for details."});return}const t=kt();G({type:"complete",strategies:t})}self.onmessage=async s=>{const t=s.data;switch(t.type){case"start":try{await He(t.gameTree)}catch(e){G({type:"error",message:e instanceof Error?e.message:"Unknown error"})}break;case"pause":break;case"resume":break;case"getStrategy":{const e=Tt(t.nodeId);G({type:"strategy",nodeId:t.nodeId,data:e});break}case"getAllStrategies":G({type:"allStrategies",strategies:kt()});break}};
