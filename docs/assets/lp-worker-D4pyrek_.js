function Ft(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var at={exports:{}},kt=at.exports,vt;function Lt(){return vt||(vt=1,(function(n){(function(t,e){n.exports?n.exports=e():t.log=e()})(kt,function(){var t=function(){},e="undefined",i=typeof window!==e&&typeof window.navigator!==e&&/Trident\/|MSIE /.test(window.navigator.userAgent),s=["trace","debug","info","warn","error"],o={},r=null;function a(p,m){var v=p[m];if(typeof v.bind=="function")return v.bind(p);try{return Function.prototype.bind.call(v,p)}catch{return function(){return Function.prototype.apply.apply(v,[p,arguments])}}}function c(){console.log&&(console.log.apply?console.log.apply(console,arguments):Function.prototype.apply.apply(console.log,[console,arguments])),console.trace&&console.trace()}function h(p){return p==="debug"&&(p="log"),typeof console===e?!1:p==="trace"&&i?c:console[p]!==void 0?a(console,p):console.log!==void 0?a(console,"log"):t}function f(){for(var p=this.getLevel(),m=0;m<s.length;m++){var v=s[m];this[v]=m<p?t:this.methodFactory(v,p,this.name)}if(this.log=this.debug,typeof console===e&&p<this.levels.SILENT)return"No console available for logging"}function y(p){return function(){typeof console!==e&&(f.call(this),this[p].apply(this,arguments))}}function l(p,m,v){return h(p)||y.apply(this,arguments)}function u(p,m){var v=this,g,x,b,C="loglevel";typeof p=="string"?C+=":"+p:typeof p=="symbol"&&(C=void 0);function O(w){var M=(s[w]||"silent").toUpperCase();if(!(typeof window===e||!C)){try{window.localStorage[C]=M;return}catch{}try{window.document.cookie=encodeURIComponent(C)+"="+M+";"}catch{}}}function B(){var w;if(!(typeof window===e||!C)){try{w=window.localStorage[C]}catch{}if(typeof w===e)try{var M=window.document.cookie,P=encodeURIComponent(C),z=M.indexOf(P+"=");z!==-1&&(w=/^([^;]+)/.exec(M.slice(z+P.length+1))[1])}catch{}return v.levels[w]===void 0&&(w=void 0),w}}function S(){if(!(typeof window===e||!C)){try{window.localStorage.removeItem(C)}catch{}try{window.document.cookie=encodeURIComponent(C)+"=; expires=Thu, 01 Jan 1970 00:00:00 UTC"}catch{}}}function _(w){var M=w;if(typeof M=="string"&&v.levels[M.toUpperCase()]!==void 0&&(M=v.levels[M.toUpperCase()]),typeof M=="number"&&M>=0&&M<=v.levels.SILENT)return M;throw new TypeError("log.setLevel() called with invalid level: "+w)}v.name=p,v.levels={TRACE:0,DEBUG:1,INFO:2,WARN:3,ERROR:4,SILENT:5},v.methodFactory=m||l,v.getLevel=function(){return b??x??g},v.setLevel=function(w,M){return b=_(w),M!==!1&&O(b),f.call(v)},v.setDefaultLevel=function(w){x=_(w),B()||v.setLevel(w,!1)},v.resetLevel=function(){b=null,S(),f.call(v)},v.enableAll=function(w){v.setLevel(v.levels.TRACE,w)},v.disableAll=function(w){v.setLevel(v.levels.SILENT,w)},v.rebuild=function(){if(r!==v&&(g=_(r.getLevel())),f.call(v),r===v)for(var w in o)o[w].rebuild()},g=_(r?r.getLevel():"WARN");var I=B();I!=null&&(b=_(I)),f.call(v)}r=new u,r.getLogger=function(m){if(typeof m!="symbol"&&typeof m!="string"||m==="")throw new TypeError("You must supply a name when creating a logger.");var v=o[m];return v||(v=o[m]=new u(m,r.methodFactory)),v};var d=typeof window!==e?window.log:void 0;return r.noConflict=function(){return typeof window!==e&&window.log===r&&(window.log=d),r},r.getLoggers=function(){return o},r.default=r,r})})(at)),at.exports}var Nt=Lt(),F=Ft(Nt);class At{constructor(t,e,i,s){this.feasible=i,this.evaluation=e,this.bounded=s,this._tableau=t,this.solutionSet={}}generateSolutionSet(){const t={},e=this._tableau,i=e.varIndexByRow,s=e.variablesPerIndex,o=e.matrix,r=e.width,a=e.rhsColumn,c=e.height-1,h=Math.round(1/e.precision);for(let f=1;f<=c;f+=1){const y=i[f],l=s[y];if(l===void 0||l.isSlack===!0)continue;const u=o[f*r+a];t[l.id]=Math.round((Number.EPSILON+u)*h)/h}return t}}class $t extends At{constructor(t,e,i,s,o){super(t,e,i,s),this.iter=o}}class pt{constructor(t=64){this.heap=new Array(t),this.size=0,this.seqCounter=0,this.pool=new Array(64),this.poolSize=0}allocEntry(t,e){if(this.poolSize>0){const i=this.pool[--this.poolSize];return i.branch=t,i.seq=e,i}return{branch:t,seq:e}}freeEntry(t){this.poolSize<256&&(this.pool[this.poolSize++]=t)}get length(){return this.size}isEmpty(){return this.size===0}clear(){this.size=0,this.seqCounter=0}isBefore(t,e){return t.branch.relaxedEvaluation!==e.branch.relaxedEvaluation?t.branch.relaxedEvaluation<e.branch.relaxedEvaluation:t.seq>e.seq}push(t){const e=this.heap;let i=this.size;this.size++,i>=e.length&&(e.length=e.length*2);const s=this.allocEntry(t,this.seqCounter++);for(;i>0;){const o=i-1>>1,r=e[o];if(!this.isBefore(s,r))break;e[i]=r,i=o}e[i]=s}pop(){if(this.size===0)return;const t=this.heap,e=t[0],i=e.branch;if(this.size--,this.freeEntry(e),this.size===0)return i;const s=t[this.size];let o=0;const r=this.size>>1;for(;o<r;){let a=(o<<1)+1,c=t[a];const h=a+1;if(h<this.size&&this.isBefore(t[h],c)&&(a=h,c=t[h]),!this.isBefore(c,s))break;t[o]=c,o=a}return t[o]=s,i}peek(){return this.size>0?this.heap[0].branch:void 0}}function mt(n,t,e){return{type:n,varIndex:t,value:e}}function ht(n,t){return{relaxedEvaluation:n,cuts:t}}function ft(){const n=(e,i)=>{var s;if(e.restore(),e.addCutConstraints(i),e.simplex(),!((s=e.model)===null||s===void 0)&&s.useMIRCuts){let o=e.computeFractionalVolume(!0);for(;o>0;){e.applyMIRCuts(),e.simplex();const r=e.computeFractionalVolume(!0);if(r>=.9*o)break;o=r}}};return{applyCuts:n,branchAndCut:e=>{var i,s,o,r,a;const c=new pt;let h=0;const f=(s=(i=e.model)===null||i===void 0?void 0:i.tolerance)!==null&&s!==void 0?s:0;let y=!0,l=1e99;!((o=e.model)===null||o===void 0)&&o.timeout&&(l=Date.now()+e.model.timeout);let u=1/0,d=null;const p=[],m=e.optionalObjectives,v=m.length;for(let b=0;b<v;b+=1)p.push(1/0);const g=ht(-1/0,[]);let x;for(c.push(g);!c.isEmpty()&&y===!0&&Date.now()<l;){!((r=e.model)===null||r===void 0)&&r.isMinimization?x=e.bestPossibleEval*(1+f):x=e.bestPossibleEval*(1-f),f>0&&u<x&&(y=!1);const b=c.pop();if(b.relaxedEvaluation>=u)continue;const C=b.cuts;if(n(e,C),h++,e.feasible===!1)continue;const O=e.evaluation;if(!(O>u)){if(O===u){let B=!0;for(let S=0;S<v;S+=1){const _=m[S].reducedCosts[0],I=p[S];if(_>I)break;if(_<I){B=!1;break}}if(B)continue}if(e.isIntegral()===!0){if(e.__isIntegral=!0,h===1){e.branchAndCutIterations=h;return}d=b,u=O;for(let B=0;B<v;B+=1)p[B]=m[B].reducedCosts[0];if(!((a=e.model)===null||a===void 0)&&a.keep_solutions){const B=e.model.tableau.getSolution(),S=B.generateSolutionSet();S.result=B.evaluation,e.model.solutions||(e.model.solutions=[]),e.model.solutions.push(S)}}else{h===1&&e.save();const B=e.getMostFractionalVar(),S=B.index,_=B.value,I=[],w=[],M=C.length;for(let k=0;k<M;k+=1){const V=C[k];V.varIndex===S?V.type==="min"?w.push(V):I.push(V):(I.push(V),w.push(V))}const P=mt("min",S,Math.ceil(_));I.push(P);const z=mt("max",S,Math.floor(_));w.push(z),c.push(ht(O,I)),c.push(ht(O,w))}}}d!==null&&n(e,d.cuts),e.branchAndCutIterations=h}}}class _t{constructor(){this.pairs=[],this.positions=new Map}add(t,e){const i=`${t}_${e}`,s=this.pairs.length;this.pairs.push([t,e]);const o=this.positions.get(i);if(o===void 0)return this.positions.set(i,[s]),[];for(const r of o){const a=s-r;if(a>this.pairs.length-s)continue;let c=!0;for(let h=1;h<a&&r+a+h<this.pairs.length;h++){const f=this.pairs[r+h],y=this.pairs[r+a+h];if(f[0]!==y[0]||f[1]!==y[1]){c=!1;break}}if(c)return[r,a]}return o.push(s),[]}}function qt(){return this.bounded=!0,this.phase1(),this.feasible===!0&&this.phase2(),this}function Dt(){const n=this.matrix,t=this.width,e=this.rhsColumn,i=t-1,s=this.height-1,r=-this.precision;let a=0;const c=1e4;for(;a<c;){let h=0,f=r;for(let d=1;d<=s;d++){const p=n[d*t+e];p<f&&(f=p,h=d)}if(h===0)return this.feasible=!0,this.setEvaluation(),a;let y=0,l=1/0;const u=h*t;for(let d=1;d<=i;d++){const p=n[u+d];if(p<r){const m=n[d];if(m>=r){const v=m/-p;v<l&&(l=v,y=d)}}}if(y===0)return this.feasible=!1,-1;this.pivot(h,y),a++}return this.feasible=!1,a}function Wt(){const t=this.model.checkForCycles?new _t:null,e=this.matrix,i=this.width,s=this.rhsColumn,o=this.width-1,r=this.height-1,a=this.precision,c=-a,h=this.unrestrictedVars,f=this.varIndexByRow,y=this.varIndexByCol,l=10,u=Math.max(r,o);let d=0,p=!1,m=-1/0,v=null,g=null,x=null,b=null,C=null;for(;;){let O=0,B=c;for(let I=1;I<=r;I++){if(h[f[I]]===!0)continue;const w=e[I*i+s];w<B&&(B=w,O=I)}if(O===0)return this.feasible=!0,d;if(!p&&d>0&&B<=m&&(d>=l&&v===null&&(v=e.slice(),g=f.slice(),x=y.slice(),b=this.rowByVarIndex.slice(),C=this.colByVarIndex.slice()),d>=u&&(p=!0,v))){e.set(v);for(let I=0;I<g.length;I++)f[I]=g[I];for(let I=0;I<x.length;I++)y[I]=x[I];for(let I=0;I<b.length;I++)this.rowByVarIndex[I]=b[I];for(let I=0;I<C.length;I++)this.colByVarIndex[I]=C[I];d=0;continue}d===0&&(m=B);let S=0;const _=O*i;if(p){for(let I=1;I<=o;I++)if(e[_+I]<c){S=I;break}if(S===0)for(let I=1;I<=o;I++){const w=e[_+I];if(h[y[I]]===!0&&(w<c||w>a)){S=I;break}}}else{let I=-1/0;for(let w=1;w<=o;w++){const M=e[_+w];if(M<c){const P=-e[w]/M;I<P&&(I=P,S=w)}}if(S===0)for(let w=1;w<=o;w++){const M=e[_+w];if(h[y[w]]===!0&&(M<c||M>a)){S=w;break}}}if(S===0)return this.feasible=!1,d;if(t){const I=t.add(f[O],y[S]);if(I.length>0)return this.model.messages.push("Cycle in phase 1"),this.model.messages.push("Start :"+I[0]),this.model.messages.push("Length :"+I[1]),this.feasible=!1,d}this.pivot(O,S),d+=1}}function Ut(){const t=this.model.checkForCycles?new _t:null,e=this.matrix,i=this.width,s=this.rhsColumn,o=this.width-1,r=this.height-1,a=this.precision,c=-a,h=this.optionalObjectives.length;let f=null;const y=this.unrestrictedVars,l=this.varIndexByCol,u=this.varIndexByRow;let d=0,p,m;const v=100,g=5;let x=!1,b=e[s],C=0,O=0,B=0;const S=o,_=this.pricingBatchSize>0?this.pricingBatchSize:Math.min(500,Math.max(50,Math.floor(Math.sqrt(S)))),I=S>_*2;for(;;){if(h>0&&(f=[]),!x&&d>0&&d%v===0){const V=e[s],E=Math.abs(V-b),T=Math.max(1,Math.abs(b));E/T<1e-10?(C++,C>=g&&(x=!0,O=d,B=V)):C=0,b=V}if(x&&d-O>r){const V=e[s],E=Math.abs(V-B),T=Math.max(1,Math.abs(B));if(E/T<1e-10)return this.setEvaluation(),this.simplexIters+=1,d;O=d,B=V}let w=0,M=a,P=!1;if(x)for(let V=1;V<=o;V++){if(p=e[V],m=y[l[V]]===!0,m&&p<0){w=V,M=-p,P=!0;break}if(p>a){w=V,M=p,P=!1;break}}else if(I){const V=this.pricingBatchStart;let E=0;const T=Math.ceil(S/_);for(;w===0&&E<T;){const R=this.pricingBatchStart,A=Math.min(R+_-1,o);for(let j=R;j<=A;j++){if(p=e[j],m=y[l[j]]===!0,h>0&&c<p&&p<a){f?.push(j);continue}if(m&&p<0){-p>M&&(M=-p,w=j,P=!0);continue}p>M&&(M=p,w=j,P=!1)}this.pricingBatchStart=A>=o?1:A+1,E++}w!==0&&(this.pricingBatchStart=V)}else for(let V=1;V<=o;V++){if(p=e[V],m=y[l[V]]===!0,h>0&&c<p&&p<a){f?.push(V);continue}if(m&&p<0){-p>M&&(M=-p,w=V,P=!0);continue}p>M&&(M=p,w=V,P=!1)}if(h>0){let V=0;for(;w===0&&f&&f.length>0&&V<h;){const E=[],T=this.optionalObjectives[V].reducedCosts;M=a;for(let R=0;R<f.length;R++){const A=f[R];if(p=T[A],m=y[l[A]]===!0,c<p&&p<a){E.push(A);continue}if(m&&p<0){-p>M&&(M=-p,w=A,P=!0);continue}p>M&&(M=p,w=A,P=!1)}f=E,V+=1}}if(w===0)return this.setEvaluation(),this.simplexIters+=1,d;let z=0,k=1/0;for(let V=1;V<=r;V++){const E=V*i,T=e[E+s],R=e[E+w];if(c<R&&R<a)continue;if(R>0&&a>T&&T>c){k=0,z=V;break}const A=P?-T/R:T/R;A>a&&k>A&&(k=A,z=V)}if(k===1/0)return this.evaluation=-1/0,this.bounded=!1,this.unboundedVarIndex=l[w],d;if(t){const V=t.add(u[z],l[w]);if(V.length>0)return this.model.messages.push("Cycle in phase 2"),this.model.messages.push("Start :"+V[0]),this.model.messages.push("Length :"+V[1]),this.feasible=!1,d}this.pivot(z,w),d+=1}}let H=new Int32Array(1024),ot=new Float64Array(1024);function Ht(n,t){const e=this.matrix,i=this.width;i>H.length&&(H=new Int32Array(i*2),ot=new Float64Array(i*2));const s=n*i,o=e[s+t],r=1/o,a=this.height,c=this.varIndexByRow[n],h=this.varIndexByCol[t];this.varIndexByRow[n]=h,this.varIndexByCol[t]=c,this.rowByVarIndex[h]=n,this.rowByVarIndex[c]=-1,this.colByVarIndex[h]=-1,this.colByVarIndex[c]=t;let f=0;for(let u=0;u<i;u++){const d=s+u,p=e[d];if(p>=-1e-16&&p<=1e-16)e[d]=0;else{const m=p/o;e[d]=m,H[f]=u,ot[f]=m,f++}}e[s+t]=r;for(let u=0;u<a;u++)if(u!==n){const d=u*i,p=e[d+t];if(!(p>=-1e-16&&p<=1e-16)){const m=p;if(m>=-1e-16&&m<=1e-16)m!==0&&(e[d+t]=0);else{for(let v=0;v<f;v++){const g=H[v],x=ot[v];x>=-1e-16&&x<=1e-16?x!==0&&(e[s+g]=0):e[d+g]-=m*x}e[d+t]=-m/o}}}const y=this.optionalObjectives,l=y.length;if(l>0)for(let u=0;u<l;u++){const d=y[u].reducedCosts,p=d[t];if(p!==0){for(let m=0;m<f;m++){const v=H[m];d[v]-=p*ot[m]}d[t]=-p*r}}}function Jt(n){for(let t=0;t<n.length-1;t++)for(let e=t+1;e<n.length;e++){const i=n[t],s=n[e];if(i[0]===s[0]&&i[1]===s[1]){if(e-t>n.length-e)break;let o=!0;for(let r=1;r<e-t;r++){const a=n[t+r],c=n[e+r];if(a[0]!==c[0]||a[1]!==c[1]){o=!1;break}}if(o)return[t,e-t]}}return[]}class lt{constructor(t,e,i,s){this.id=t,this.cost=e,this.index=i,this.value=0,this.priority=s}}class Yt extends lt{constructor(t,e,i,s){super(t,e,i,s),this.isInteger=!0}}class ct extends lt{constructor(t,e){super(t,0,e,0),this.isSlack=!0}}class Rt{constructor(t,e){this.variable=t,this.coefficient=e}}function Pt(n,t,e){if(e===0||e==="required")return null;const i=t===void 0?1:t,s=e===void 0?1:e,o=n.isMinimization===!1?-i:i;return n.addVariable(o,"r"+n.relaxationIndex++,!1,!1,s)}class Z{constructor(t,e,i,s){this.slack=new ct("s"+i,i),this.index=i,this.model=s,this.rhs=t,this.isUpperBound=e,this.terms=[],this.termsByVarIndex={},this.relaxation=null}addTerm(t,e){const i=e.index,s=this.termsByVarIndex[i];if(s===void 0){const o=new Rt(e,t);this.termsByVarIndex[i]=o,this.terms.push(o);const r=this.isUpperBound===!0?-t:t;this.model.updateConstraintCoefficient(this,e,r)}else{const o=s.coefficient+t;this.setVariableCoefficient(o,e)}return this}removeTerm(t){return this}setRightHandSide(t){if(t!==this.rhs){let e=t-this.rhs;this.isUpperBound===!0&&(e=-e),this.rhs=t,this.model.updateRightHandSide(this,e)}return this}setVariableCoefficient(t,e){const i=e.index;if(i===-1){console.warn("[Constraint.setVariableCoefficient] Trying to change coefficient of inexistant variable.");return}const s=this.termsByVarIndex[i];if(s===void 0)this.addTerm(t,e);else if(t!==s.coefficient){let o=t-s.coefficient;this.isUpperBound===!0&&(o=-o),s.coefficient=t,this.model.updateConstraintCoefficient(this,e,o)}return this}relax(t,e){this.relaxation=Pt(this.model,t,e),this._relax(this.relaxation)}_relax(t){t!==null&&(this.isUpperBound?this.setVariableCoefficient(-1,t):this.setVariableCoefficient(1,t))}}class gt{constructor(t,e){this.isEquality=!0,this.upperBound=t,this.lowerBound=e,this.model=t.model,this.rhs=t.rhs,this.relaxation=null}addTerm(t,e){return this.upperBound.addTerm(t,e),this.lowerBound.addTerm(t,e),this}removeTerm(t){return this.upperBound.removeTerm(t),this.lowerBound.removeTerm(t),this}setRightHandSide(t){this.upperBound.setRightHandSide(t),this.lowerBound.setRightHandSide(t),this.rhs=t}relax(t,e){this.relaxation=Pt(this.model,t,e),this.upperBound.relaxation=this.relaxation,this.upperBound._relax(this.relaxation),this.lowerBound.relaxation=this.relaxation,this.lowerBound._relax(this.relaxation)}}class Zt{constructor(t){this.value=t}}function Kt(n){const t=n.length,e=this.height,i=e+t,s=this.width,o=s-1,r=this.matrix,a=i*s;if(r.length<a){const d=Math.ceil(a*1.5),p=new Float64Array(d);p.set(r),this.matrix=p}const c=this.matrix;this.height=i,this.nVars=this.width+this.height-2;const h=this.rhsColumn,f=this.rowByVarIndex,y=this.colByVarIndex,l=this.varIndexByRow,u=this.variablesPerIndex;for(let d=0;d<t;d+=1){const p=n[d],m=e+d,v=m*s,g=p.type==="min"?-1:1,x=p.varIndex;let b=f[x];if(b===-1){c[v+h]=g*p.value;for(let C=1;C<=o;C+=1)c[v+C]=0;c[v+y[x]]=g}else{const C=b*s,O=c[C+h];c[v+h]=g*(p.value-O);for(let B=1;B<=o;B+=1)c[v+B]=-g*c[C+B]}b=this.getNewElementIndex(),l[m]=b,f[b]=m,y[b]=-1,u[b]=new ct("s"+b,b),this.nVars+=1}}function Qt(n){if(n===this.costRowIndex)return!1;const t=this.width,e=this.matrix,i=n*t,s=this.variablesPerIndex[this.varIndexByRow[n]];if(s===void 0||!s.isInteger)return!1;const o=e[i+this.rhsColumn],r=o-Math.floor(o);if(r<this.precision||r>1-this.precision)return!1;const a=this.height,c=a*t,h=(a+1)*t;if(e.length<h){const v=Math.ceil(h*1.5),g=new Float64Array(v);g.set(e),this.matrix=g}const f=this.matrix;this.height+=1,this.nVars+=1;const y=this.getNewElementIndex();this.varIndexByRow[a]=y,this.rowByVarIndex[y]=a,this.colByVarIndex[y]=-1,this.variablesPerIndex[y]=new ct("s"+y,y);const l=this.rhsColumn;f[c+l]=Math.floor(o);const u=this.variablesPerIndex,d=this.varIndexByCol,p=d.length,m=1-r;for(let v=1;v<p;v+=1){const g=u[d[v]],x=f[i+v];if(g!==void 0&&g.isInteger){const b=Math.floor(x),C=b+Math.max(0,x-b-r)/m;f[c+v]=C}else f[c+v]=Math.min(0,x/m)}for(let v=0;v<t;v+=1)f[c+v]-=f[i+v];return!0}function Gt(n){if(n===this.costRowIndex)return!1;const t=this.width,e=this.matrix,i=n*t,s=this.variablesPerIndex[this.varIndexByRow[n]];if(s===void 0||!s.isInteger)return!1;const o=e[i+this.rhsColumn],r=o-Math.floor(o);if(r<this.precision||r>1-this.precision)return!1;const a=this.height,c=a*t,h=(a+1)*t;if(e.length<h){const v=Math.ceil(h*1.5),g=new Float64Array(v);g.set(e),this.matrix=g}const f=this.matrix;this.height+=1,this.nVars+=1;const y=this.getNewElementIndex();this.varIndexByRow[a]=y,this.rowByVarIndex[y]=a,this.colByVarIndex[y]=-1,this.variablesPerIndex[y]=new ct("s"+y,y);const l=this.rhsColumn;f[c+l]=-r;const u=this.variablesPerIndex,d=this.varIndexByCol,p=d.length,m=1-r;for(let v=1;v<p;v+=1){const g=u[d[v]],x=f[i+v],b=x-Math.floor(x);g!==void 0&&g.isInteger?f[c+v]=b<=r?-b:-(1-b)*r/b:f[c+v]=x>=0?-x:x*r/m}return!0}function Xt(){const n=this.height;let t=0;const e=10;for(let i=1;i<n&&t<e;i++)this.addLowerBoundMIRCut(i)&&t++}function te(n){const t=this.width;let e=this.rowByVarIndex[n];if(e===-1){const i=this.colByVarIndex[n];for(let s=1;s<this.height;s+=1){const o=this.matrix[s*t+i];if(o<-this.precision||this.precision<o){e=s;break}}this.pivot(e,i)}return e}function ee(n){const t=this.width;let e=this.colByVarIndex[n];if(e===-1){const i=this.rowByVarIndex[n],s=i*t;for(let o=1;o<this.height;o+=1){const r=this.matrix[s+o];if(r<-this.precision||this.precision<r){e=o;break}}this.pivot(i,e)}return e}function ie(){const n=this.width,t=this.matrix,e=this.rhsColumn,i=this.variables.length,s=Math.round(1/this.precision);for(let o=0;o<i;o+=1){const r=this.variables[o],a=r.index,c=this.rowByVarIndex[a];if(c===-1)r.value=0;else{const h=t[c*n+e];r.value=Math.round((h+Number.EPSILON)*s)/s}}}function ne(n,t){const e=this.width,i=this.matrix,s=this.rhsColumn,o=this.height-1,r=this.rowByVarIndex[n.index];if(r===-1){const a=this.colByVarIndex[n.index];for(let h=0;h<=o;h+=1){const f=h*e;i[f+s]-=t*i[f+a]}const c=this.optionalObjectives.length;if(c>0)for(let h=0;h<c;h+=1){const f=this.optionalObjectives[h].reducedCosts;f[s]-=t*f[a]}}else i[r*e+s]-=t}function se(n,t,e){if(n.index===t.index)throw new Error("[Tableau.updateConstraintCoefficient] constraint index should not be equal to variable index !");const i=this.width,s=this.matrix,r=this.putInBase(n.index)*i,a=this.colByVarIndex[t.index];if(a===-1){const h=this.rowByVarIndex[t.index]*i;for(let f=0;f<i;f+=1)s[r+f]+=e*s[h+f]}else s[r+a]-=e}function oe(n,t){const e=this.width,i=this.matrix,s=n.index,o=e-1,r=this.colByVarIndex[s];if(r===-1){const a=this.rowByVarIndex[s]*e;if(n.priority===0)for(let c=0;c<=o;c+=1)i[c]+=t*i[a+c];else{const c=this.objectivesByPriority[n.priority].reducedCosts;for(let h=0;h<=o;h+=1)c[h]+=t*i[a+h]}}else i[r]-=t}function re(n){const t=n.isUpperBound?1:-1,e=this.height,i=this.width,s=i-1,r=(e+1)*i;if(this.matrix.length<r){const l=this.matrix.length,u=Math.max(i*16,Math.floor(l*.5)),d=l+u,p=this.matrix,m=new Float64Array(d);m.set(p),this.matrix=m}const a=this.matrix,c=e*i;for(let l=0;l<=s;l+=1)a[c+l]=0;a[c+this.rhsColumn]=t*n.rhs;const h=n.terms,f=h.length;for(let l=0;l<f;l+=1){const u=h[l],d=u.coefficient,p=u.variable.index,m=this.rowByVarIndex[p];if(m===-1)a[c+this.colByVarIndex[p]]+=t*d;else{const v=m*i;for(let g=0;g<=s;g+=1)a[c+g]-=t*d*a[v+g]}}const y=n.index;this.varIndexByRow[e]=y,this.rowByVarIndex[y]=e,this.colByVarIndex[y]=-1,this.height+=1}function ae(n){const t=n.index,e=this.height-1,i=this.width,s=this.matrix,o=this.putInBase(t),r=o*i,a=e*i;for(let c=0;c<i;c++){const h=s[a+c];s[a+c]=s[r+c],s[r+c]=h}this.varIndexByRow[o]=this.varIndexByRow[e],this.varIndexByRow[e]=-1,this.rowByVarIndex[t]=-1,this.availableIndexes[this.availableIndexes.length]=t,n.slack.index=-1,this.height-=1}function le(n){this.height-1;const t=this.width,e=t+1,i=this.height,s=this.model.isMinimization===!0?-n.cost:n.cost,o=n.priority,r=this.matrix,a=new Float64Array(i*e);for(let f=0;f<i;f++){const y=f*t,l=f*e;for(let u=0;u<t;u++)a[l+u]=r[y+u]}this.matrix=a,this.width=e;const c=e-1,h=this.optionalObjectives.length;if(h>0)for(let f=0;f<h;f+=1)this.optionalObjectives[f].reducedCosts[c]=0;o===0?a[c]=s:(this.setOptionalObjective(o,c,s),a[c]=0),this.colByVarIndex[n.index]=c,this.varIndexByCol[c]=n.index}function ce(n){const t=n.index,e=this.width,i=this.matrix,s=e-1,o=this.takeOutOfBase(t),r=this.height-1;for(let a=0;a<=r;a+=1){const c=a*e;i[c+o]=i[c+s]}this.varIndexByCol[o]=this.varIndexByCol[s],this.rowByVarIndex[t]=-1,this.colByVarIndex[t]=-1,this.availableIndexes[this.availableIndexes.length]=t,this.width-=1}function he(){const n=new this.constructor(this.precision,this.branchAndCutService);n.width=this.width,n.height=this.height,n.nVars=this.nVars,n.model=this.model,n.variables=this.variables,n.variablesPerIndex=this.variablesPerIndex,n.unrestrictedVars=this.unrestrictedVars,n.lastElementIndex=this.lastElementIndex,n.varIndexByRow=this.varIndexByRow.slice(),n.varIndexByCol=this.varIndexByCol.slice(),n.rowByVarIndex=this.rowByVarIndex.slice(),n.colByVarIndex=this.colByVarIndex.slice(),n.availableIndexes=this.availableIndexes.slice();const t=[];for(let e=0;e<this.optionalObjectives.length;e++)t[e]=this.optionalObjectives[e].copy();return n.optionalObjectives=t,n.objectivesByPriority={...this.objectivesByPriority},n.optionalObjectivePerPriority={...this.optionalObjectivePerPriority},n.matrix=new Float64Array(this.matrix),n}function ue(){this.savedState=this.copy()}function de(){if(this.savedState===null)return;const n=this.savedState;this.nVars=n.nVars,this.model=n.model,this.variables=n.variables,this.variablesPerIndex=n.variablesPerIndex,this.unrestrictedVars=n.unrestrictedVars,this.lastElementIndex=n.lastElementIndex,this.width=n.width,this.height=n.height,this.matrix.set(n.matrix);const t=n.varIndexByRow,e=this.height;for(let a=0;a<e;a+=1)this.varIndexByRow[a]=t[a];this.varIndexByRow.length=e;const i=n.varIndexByCol,s=this.width;for(let a=0;a<s;a+=1)this.varIndexByCol[a]=i[a];this.varIndexByCol.length=s;const o=n.rowByVarIndex,r=n.colByVarIndex;for(let a=0;a<this.nVars;a+=1)this.rowByVarIndex[a]=o[a],this.colByVarIndex[a]=r[a];if(n.optionalObjectives.length>0&&this.optionalObjectives.length>0){this.optionalObjectives=[],this.optionalObjectivePerPriority={};for(let a=0;a<n.optionalObjectives.length;a++){const c=n.optionalObjectives[a].copy();this.optionalObjectives[a]=c,this.optionalObjectivePerPriority[c.priority]=c,this.objectivesByPriority[c.priority]=c}}}function fe(){let n=0;const t=this.width,e=this.matrix,i=this.rhsColumn;for(let s=1;s<this.height;s+=1){const o=this.variablesPerIndex[this.varIndexByRow[s]];if(o!==void 0&&o.isInteger){const r=e[s*t+i],a=r-Math.floor(r);a<this.precision&&-a<this.precision&&(n+=1)}}return n}function pe(){const n=this.width,t=this.matrix,e=this.rhsColumn,i=this.model.integerVariables,s=i.length,o=this.rowByVarIndex,r=this.precision;for(let a=0;a<s;a++){const c=i[a].index,h=o[c];if(h!==-1){const f=t[h*n+e];if(Math.abs(f-Math.round(f))>r)return!1}}return!0}function ve(n){let t=-1;const e=this.width,i=this.matrix,s=this.rhsColumn,o=this.height,r=this.variablesPerIndex,a=this.varIndexByRow,c=this.precision;for(let h=1;h<o;h+=1){const f=r[a[h]];if(f!==void 0&&f.isInteger){const y=i[h*e+s],l=Math.abs(y);if(Math.min(l-Math.floor(l),Math.floor(l+1))<c){if(n!==!0)return 0}else t===-1?t=l:t*=l}}return t===-1?0:t}function me(){let n=0,t=null,e=0;const i=this.width,s=this.matrix,o=this.rhsColumn,r=this.model.integerVariables,a=r.length,c=this.rowByVarIndex;for(let h=0;h<a;h+=1){const f=r[h].index,y=c[f];if(y!==-1){const l=s[y*i+o],u=Math.abs(l-Math.round(l));u>n&&(n=u,t=f,e=l)}}return{index:t,value:e}}function ge(){let n=1/0,t=null,e=null;const i=this.width,s=this.matrix,o=this.rhsColumn,r=this.model.integerVariables,a=r.length;for(let c=0;c<a;c+=1){const h=r[c],f=h.index,y=this.rowByVarIndex[f];if(y!==-1){const l=s[y*i+o];Math.abs(l-Math.round(l))>this.precision&&h.cost<n&&(n=h.cost,t=f,e=l)}}return{index:t,value:e}}function ye(n,t){if(!t)return this;console.log("****",n,"****"),console.log("Nb Variables",this.width-1),console.log("Nb Constraints",this.height-1),console.log("Basic Indexes",this.varIndexByRow),console.log("Non Basic Indexes",this.varIndexByCol),console.log("Rows",this.rowByVarIndex),console.log("Cols",this.colByVarIndex);const e=5,i=this.matrix,s=this.width;let o="";const r=[" "];let a,c,h,f,y,l,u;for(c=1;c<this.width;c+=1){h=this.varIndexByCol[c];const g=this.variablesPerIndex[h];g===void 0?f="c"+h:f=g.id,y=f.length,l=" ",u="	",y>5?l+=" ":u+="	",r[c]=l,o+=u+f}console.log(o);let d;const p=this.costRowIndex*s;let m="	";for(a=1;a<this.width;a+=1)d="	",m+=d,m+=r[a],m+=i[p+a].toFixed(e);d="	",m+=d+r[0]+i[p].toFixed(e),console.log(m+"	Z");for(let g=1;g<this.height;g+=1){const x=g*s;let b="	";for(c=1;c<this.width;c+=1)d="	",b+=d+r[c]+i[x+c].toFixed(e);d="	",b+=d+r[0]+i[x].toFixed(e),h=this.varIndexByRow[g];const C=this.variablesPerIndex[h];C===void 0?f="c"+h:f=C.id,console.log(b+"	"+f)}console.log("");const v=this.optionalObjectives.length;if(v>0){console.log("    Optional objectives:");for(let g=0;g<v;g+=1){const x=this.optionalObjectives[g].reducedCosts;let b="";for(a=1;a<this.width;a+=1)d=x[a]<0?"":" ",b+=d,b+=r[a],b+=x[a].toFixed(e);d=x[0]<0?"":" ",b+=d+r[0]+x[0].toFixed(e),console.log(b+" z"+g)}}return console.log("Feasible?",this.feasible),console.log("evaluation",this.evaluation),this}function Et(n,t,e){return{priority:n,reducedCosts:e?e.slice():new Array(t).fill(0),copy(){return Et(this.priority,this.reducedCosts.length,this.reducedCosts)}}}class Tt{constructor(t=1e-8,e){this.model=null,this.matrix=new Float64Array(0),this.width=0,this.height=0,this.costRowIndex=0,this.rhsColumn=0,this.variablesPerIndex=[],this.unrestrictedVars={},this.feasible=!0,this.evaluation=0,this.simplexIters=0,this.varIndexByRow=[],this.varIndexByCol=[],this.rowByVarIndex=[],this.colByVarIndex=[],this.optionalObjectives=[],this.objectivesByPriority={},this.optionalObjectivePerPriority={},this.savedState=null,this.availableIndexes=[],this.lastElementIndex=0,this.variables=[],this.nVars=0,this.bounded=!0,this.unboundedVarIndex=null,this.branchAndCutIterations=0,this.bestPossibleEval=0,this.pricingBatchStart=1,this.pricingBatchSize=0,this.precision=t,this.branchAndCutService=e??ft()}simplex(){return qt.call(this),this}phase1(){return Wt.call(this)}phase2(){return Ut.call(this)}dualSimplex(){return Dt.call(this)}pivot(t,e){Ht.call(this,t,e)}checkForCycles(t){return Jt.call(this,t)}countIntegerValues(){return fe.call(this)}isIntegral(){return pe.call(this)}computeFractionalVolume(t){return ve.call(this,t)}addCutConstraints(t){Kt.call(this,t)}applyMIRCuts(){Xt.call(this)}addLowerBoundMIRCut(t){return Qt.call(this,t)}addUpperBoundMIRCut(t){return Gt.call(this,t)}getMostFractionalVar(){return me.call(this)}getFractionalVarWithLowestCost(){return ge.call(this)}putInBase(t){return te.call(this,t)}takeOutOfBase(t){return ee.call(this,t)}updateVariableValues(){ie.call(this)}updateRightHandSide(t,e){ne.call(this,t,e)}updateConstraintCoefficient(t,e,i){se.call(this,t,e,i)}updateCost(t,e){oe.call(this,t,e)}addConstraint(t){re.call(this,t)}removeConstraint(t){ae.call(this,t)}addVariable(t){le.call(this,t)}removeVariable(t){ce.call(this,t)}copy(){return he.call(this)}save(){ue.call(this)}restore(){de.call(this)}log(t){return ye.call(this,t),this}applyCuts(t){this.branchAndCutService.applyCuts(this,t)}branchAndCut(){this.branchAndCutService.branchAndCut(this)}solve(){var t,e;return((e=(t=this.model)===null||t===void 0?void 0:t.getNumberOfIntegerVariables())!==null&&e!==void 0?e:0)>0?this.branchAndCut():this.simplex(),this.updateVariableValues(),this.getSolution()}getSolution(){var t,e,i;const s=((t=this.model)===null||t===void 0?void 0:t.isMinimization)===!0?this.evaluation:-this.evaluation;return((i=(e=this.model)===null||e===void 0?void 0:e.getNumberOfIntegerVariables())!==null&&i!==void 0?i:0)>0?new $t(this,s,this.feasible,this.bounded,this.branchAndCutIterations):new At(this,s,this.feasible,this.bounded)}setOptionalObjective(t,e,i){let s=this.objectivesByPriority[t];if(s===void 0){const o=Math.max(this.width,e+1);s=Et(t,o),this.objectivesByPriority[t]=s,this.optionalObjectivePerPriority[t]=s,this.optionalObjectives.push(s),this.optionalObjectives.sort((r,a)=>r.priority-a.priority)}s.reducedCosts[e]=i}initialize(t,e,i,s){this.variables=i,this.unrestrictedVars=s,this.width=t,this.height=e,this.matrix=new Float64Array(t*e),this.varIndexByRow=new Array(this.height),this.varIndexByCol=new Array(this.width),this.varIndexByRow[0]=-1,this.varIndexByCol[0]=-1,this.nVars=t+e-2,this.rowByVarIndex=new Array(this.nVars),this.colByVarIndex=new Array(this.nVars),this.lastElementIndex=this.nVars}_resetMatrix(){if(this.model===null)throw new Error("[Tableau._resetMatrix] Model not set");const t=this.matrix,e=this.width,i=this.model.variables,s=this.model.constraints,o=i.length,r=s.length,a=this.model.isMinimization===!0?-1:1;for(let h=0;h<o;h+=1){const f=i[h],y=f.priority,l=a*f.cost;y===0?t[h+1]=l:this.setOptionalObjective(y,h+1,l);const u=i[h].index;this.rowByVarIndex[u]=-1,this.colByVarIndex[u]=h+1,this.varIndexByCol[h+1]=u}let c=1;for(let h=0;h<r;h+=1){const f=s[h],y=f.index;this.rowByVarIndex[y]=c,this.colByVarIndex[y]=-1,this.varIndexByRow[c]=y;const l=f.terms,u=l.length,d=c*e;if(c++,f.isUpperBound){for(let p=0;p<u;p+=1){const m=l[p],v=this.colByVarIndex[m.variable.index];t[d+v]=m.coefficient}t[d]=f.rhs}else{for(let p=0;p<u;p+=1){const m=l[p],v=this.colByVarIndex[m.variable.index];t[d+v]=-m.coefficient}t[d]=-f.rhs}}}setModel(t){this.model=t;const e=t.nVariables+1,i=t.nConstraints+1;return this.initialize(e,i,t.variables,t.unrestrictedVariables),this._resetMatrix(),this}getNewElementIndex(){if(this.availableIndexes.length>0)return this.availableIndexes.pop();const t=this.lastElementIndex;return this.lastElementIndex+=1,t}density(){let t=0;const e=this.matrix,i=this.width;for(let s=0;s<this.height;s++){const o=s*i;for(let r=0;r<i;r++)e[o+r]!==0&&(t+=1)}return t/(this.height*this.width)}setEvaluation(){const t=Math.round(1/this.precision),e=this.matrix[this.costRowIndex*this.width+this.rhsColumn],i=Math.round((Number.EPSILON+e)*t)/t;this.evaluation=i,this.simplexIters===0&&(this.bestPossibleEval=i)}}function xe(n,t){var e,i,s,o,r,a,c;let h=!1;for(const f of n.constraints){if(t.removedConstraints.has(f)||!f.isUpperBound)continue;let y=0;for(const u of f.terms)if(t.fixedVariables.has(u.variable))y+=u.coefficient*t.fixedVariables.get(u.variable);else{const d=(e=t.tightenedBounds.get(u.variable))!==null&&e!==void 0?e:{},p=(i=d.lower)!==null&&i!==void 0?i:0;if(u.coefficient>0)y+=u.coefficient*p;else{const m=(s=d.upper)!==null&&s!==void 0?s:1/0;y+=u.coefficient*m}}const l=f.rhs-y;if(!(l<0))for(const u of f.terms){if(t.fixedVariables.has(u.variable)||!u.variable.isInteger||u.coefficient<=0)continue;const d=(o=t.tightenedBounds.get(u.variable))!==null&&o!==void 0?o:{},p=(r=d.lower)!==null&&r!==void 0?r:0,m=(a=d.upper)!==null&&a!==void 0?a:1;if(p>=-.5&&m<=1.5&&u.coefficient*(m-p)>l+1e-6){const g=p+l/u.coefficient;if(g<m-1e-6){const x=(c=t.tightenedBounds.get(u.variable))!==null&&c!==void 0?c:{};(!x.upper||g<x.upper)&&(t.tightenedBounds.set(u.variable,{...x,upper:g}),t.stats.boundsTightened++,h=!0)}}}}return h}function be(n,t){var e,i,s;let o=!1;for(const r of n.constraints){if(t.removedConstraints.has(r))continue;let a=0,c=0;for(const h of r.terms){const f=t.fixedVariables.get(h.variable);if(f!==void 0){a+=h.coefficient*f,c+=h.coefficient*f;continue}const y=(e=t.tightenedBounds.get(h.variable))!==null&&e!==void 0?e:{},l=(i=y.lower)!==null&&i!==void 0?i:0,u=(s=y.upper)!==null&&s!==void 0?s:1/0;h.coefficient>0?(a+=h.coefficient*l,c+=h.coefficient*(u===1/0?1e10:u)):(a+=h.coefficient*(u===1/0?1e10:u),c+=h.coefficient*l)}if(r.isUpperBound){if(c<=r.rhs+1e-6&&(t.removedConstraints.add(r),t.stats.constraintsRemoved++,o=!0),a>r.rhs+1e-6)return t.isInfeasible=!0,!1}else if(a>=r.rhs-1e-6&&(t.removedConstraints.add(r),t.stats.constraintsRemoved++,o=!0),c<r.rhs-1e-6)return t.isInfeasible=!0,!1}return o}function we(n){var t,e;const i={fixedVariables:new Map,removedConstraints:new Set,tightenedBounds:new Map,isInfeasible:!1,stats:{variablesFixed:0,constraintsRemoved:0,boundsTightened:0}};let s=!0,o=0;const r=5;for(;s&&o<r;){s=!1,o++;for(const a of n.constraints){if(i.removedConstraints.has(a))continue;const c=a.terms.filter(h=>!i.fixedVariables.has(h.variable));if(c.length===0){let h=0;for(const y of a.terms){const l=i.fixedVariables.get(y.variable);l!==void 0&&(h+=y.coefficient*l)}if(!(a.isUpperBound?h<=a.rhs+1e-6:h>=a.rhs-1e-6))return i.isInfeasible=!0,i;i.removedConstraints.add(a),i.stats.constraintsRemoved++,s=!0}else if(c.length===1){const h=c[0],f=h.variable,y=h.coefficient;let l=a.rhs;for(const d of a.terms)if(d.variable!==f){const p=i.fixedVariables.get(d.variable);p!==void 0&&(l-=d.coefficient*p)}const u=l/y;if(a.isUpperBound)if(y>0){const d=i.tightenedBounds.get(f);(!d?.upper||u<d.upper)&&(i.tightenedBounds.set(f,{...d,upper:u}),i.stats.boundsTightened++,s=!0)}else{const d=i.tightenedBounds.get(f);(!d?.lower||u>d.lower)&&(i.tightenedBounds.set(f,{...d,lower:u}),i.stats.boundsTightened++,s=!0)}i.removedConstraints.add(a),i.stats.constraintsRemoved++}}for(const[a,c]of i.tightenedBounds)if(!i.fixedVariables.has(a)){if(c.lower!==void 0&&c.upper!==void 0){if(c.lower>c.upper+1e-6)return i.isInfeasible=!0,i;if(Math.abs(c.lower-c.upper)<1e-6){let h=c.lower;a.isInteger&&(h=Math.round(h)),i.fixedVariables.set(a,h),i.stats.variablesFixed++,s=!0}}a.isInteger&&c.lower!==void 0&&c.lower>=.5&&((t=c.upper)!==null&&t!==void 0?t:1/0)<=1.5&&(i.fixedVariables.set(a,1),i.stats.variablesFixed++,s=!0),a.isInteger&&c.upper!==void 0&&c.upper<=.5&&((e=c.lower)!==null&&e!==void 0?e:0)>=-.5&&(i.fixedVariables.set(a,0),i.stats.variablesFixed++,s=!0)}if(be(n,i)&&(s=!0),i.isInfeasible)return i;xe(n,i)&&(s=!0)}return i}class ut{constructor(t,e,i){this.tableau=new Tt(t,i),this.name=e,this.variables=[],this.integerVariables=[],this.unrestrictedVariables={},this.constraints=[],this.nConstraints=0,this.nVariables=0,this.isMinimization=!0,this.tableauInitialized=!1,this.relaxationIndex=1,this.useMIRCuts=!1,this.checkForCycles=!0,this.messages=[],this.availableIndexes=[],this.lastElementIndex=0,this.usePresolve=!0,this.presolveResult=null}minimize(){return this.isMinimization=!0,this}maximize(){return this.isMinimization=!1,this}_getNewElementIndex(){if(this.availableIndexes.length>0)return this.availableIndexes.pop();const t=this.lastElementIndex;return this.lastElementIndex+=1,t}_addConstraint(t){const e=t.slack;this.tableau.variablesPerIndex[e.index]=e,this.constraints.push(t),this.nConstraints+=1,this.tableauInitialized===!0&&this.tableau.addConstraint(t)}smallerThan(t){const e=new Z(t,!0,this.tableau.getNewElementIndex(),this);return this._addConstraint(e),e}greaterThan(t){const e=new Z(t,!1,this.tableau.getNewElementIndex(),this);return this._addConstraint(e),e}equal(t){const e=new Z(t,!0,this.tableau.getNewElementIndex(),this);this._addConstraint(e);const i=new Z(t,!1,this.tableau.getNewElementIndex(),this);return this._addConstraint(i),new gt(e,i)}addVariable(t,e,i,s,o){if(typeof o=="string")switch(o){case"required":o=0;break;case"strong":o=1;break;case"medium":o=2;break;case"weak":o=3;break;default:o=0;break}const r=this.tableau.getNewElementIndex(),a=e??"v"+r,c=t??0,h=o??0;let f;if(i){const y=new Yt(a,c,r,h);this.integerVariables.push(y),f=y}else f=new lt(a,c,r,h);return this.variables.push(f),this.tableau.variablesPerIndex[r]=f,s&&(this.unrestrictedVariables[r]=!0),this.nVariables+=1,this.tableauInitialized===!0&&this.tableau.addVariable(f),f}_removeConstraint(t){const e=this.constraints.indexOf(t);if(e===-1){console.warn("[Model.removeConstraint] Constraint not present in model");return}this.constraints.splice(e,1),this.nConstraints-=1,this.tableauInitialized===!0&&this.tableau.removeConstraint(t),t.relaxation&&this.removeVariable(t.relaxation)}removeConstraint(t){if(t.isEquality){const e=t;this._removeConstraint(e.upperBound),this._removeConstraint(e.lowerBound)}else this._removeConstraint(t);return this}removeVariable(t){const e=this.variables.indexOf(t);if(e===-1){console.warn("[Model.removeVariable] Variable not present in model");return}return this.variables.splice(e,1),this.tableauInitialized===!0&&this.tableau.removeVariable(t),this}updateRightHandSide(t,e){return this.tableauInitialized===!0&&this.tableau.updateRightHandSide(t,e),this}updateConstraintCoefficient(t,e,i){return this.tableauInitialized===!0&&this.tableau.updateConstraintCoefficient(t,e,i),this}setCost(t,e){let i=t-e.cost;return this.isMinimization===!1&&(i=-i),e.cost=t,this.tableau.updateCost(e,i),this}loadJson(t){this.isMinimization=t.opType!=="max";const e=t.variables,i=t.constraints,s={},o={},r=Object.keys(i),a=r.length;for(let m=0;m<a;m+=1){const v=r[m],g=i[v],x=g.equal,b=g.weight,C=g.priority,O=b!==void 0||C!==void 0;let B,S;if(x===void 0){const _=g.min;_!==void 0&&(B=this.greaterThan(_),s[v]=B,O&&B.relax(b,C));const I=g.max;I!==void 0&&(S=this.smallerThan(I),o[v]=S,O&&S.relax(b,C))}else{B=this.greaterThan(x),s[v]=B,S=this.smallerThan(x),o[v]=S;const _=new gt(B,S);O&&_.relax(b,C)}}const c=Object.keys(e),h=c.length;this.tolerance=t.tolerance||0,t.timeout&&(this.timeout=t.timeout),t.options&&(t.options.timeout&&(this.timeout=t.options.timeout),this.tolerance===0&&(this.tolerance=t.options.tolerance||0),t.options.useMIRCuts&&(this.useMIRCuts=t.options.useMIRCuts),typeof t.options.exitOnCycles>"u"?this.checkForCycles=!0:this.checkForCycles=t.options.exitOnCycles,t.options.keep_solutions?this.keep_solutions=t.options.keep_solutions:this.keep_solutions=!1,t.options.presolve!==void 0&&(this.usePresolve=t.options.presolve));const f=t.ints||{},y=t.binaries||{},l=t.unrestricted||{},u=t.optimize,p=!c.some(m=>u in e[m])&&c.includes(u);for(let m=0;m<h;m+=1){const v=c[m],g=e[v],x=p?v===u?1:0:g[u]||0,b=!!y[v],C=!!f[v]||b,O=!!l[v],B=this.addVariable(x,v,C,O);b&&this.smallerThan(1).addTerm(1,B);const S=Object.keys(g);for(let _=0;_<S.length;_+=1){const I=S[_];if(I===u)continue;const w=g[I],M=s[I];M!==void 0&&M.addTerm(w,B);const P=o[I];P!==void 0&&P.addTerm(w,B)}}return this}getNumberOfIntegerVariables(){return this.integerVariables.length}solve(){if(this.usePresolve&&this.presolveResult===null){if(this.presolveResult=we(this),this.presolveResult.isInfeasible)return this.tableau.feasible=!1,this.tableau.getSolution();this.applyPresolveReductions(this.presolveResult)}return this.tableauInitialized===!1&&(this.tableau.setModel(this),this.tableauInitialized=!0),this.tableau.solve()}applyPresolveReductions(t){for(const[e,i]of t.fixedVariables)e.value=i,e.cost=0}isFeasible(){return this.tableau.feasible}save(){this.tableau.save()}restore(){this.tableau.restore()}activateMIRCuts(t){this.useMIRCuts=t}debug(t){this.checkForCycles=t}log(t){return this.tableau.log(t)}}const dt={optype:"opType",OpType:"opType",op_type:"opType",type:"opType",optimise:"optimize",Optimize:"optimize",objective:"optimize",constraint:"constraints",Constraints:"constraints",variable:"variables",Variables:"variables",vars:"variables",int:"ints",integers:"ints",Ints:"ints",binary:"binaries",Binaries:"binaries"},Ie={minimum:"min",maximum:"max",Min:"min",Max:"max",eq:"equal",equals:"equal",Equal:"equal"};function Ce(n){const t=Object.keys(n);for(const e of t){const i=dt[e];i&&console.warn(`[jsLPSolver] Warning: Model has '${e}' but expected '${i}'. This may cause unexpected behavior.`)}if(!n.optimize&&!t.some(e=>dt[e]==="optimize")&&console.warn("[jsLPSolver] Warning: Model is missing 'optimize' property. The solver needs to know which attribute to optimize."),!n.opType&&!t.some(e=>dt[e]==="opType")&&console.warn(`[jsLPSolver] Warning: Model is missing 'opType' property. Defaulting to 'max'. Use 'opType: "max"' or 'opType: "min"' to be explicit.`),n.constraints){for(const[e,i]of Object.entries(n.constraints))if(typeof i=="object"&&i!==null)for(const s of Object.keys(i)){const o=Ie[s];o&&console.warn(`[jsLPSolver] Warning: Constraint '${e}' has '${s}' but expected '${o}'.`)}}return n}function Ve(n){let t,e,i;if(typeof n.optimize=="string"){if(n.constraints[n.optimize]){t=Math.random();for(e in n.variables)n.variables[e][n.optimize]&&(n.variables[e][t]=n.variables[e][n.optimize]);return n.constraints[t]=n.constraints[n.optimize],delete n.constraints[n.optimize],n}return n}else{for(i in n.optimize)if(n.constraints[i])if(n.constraints[i]==="equal")delete n.optimize[i];else{t=Math.random();for(e in n.variables)n.variables[e][i]&&(n.variables[e][t]=n.variables[e][i]);n.constraints[t]=n.constraints[i],delete n.constraints[i]}return n}}var yt=Object.freeze({__proto__:null,CleanObjectiveAttributes:Ve,WarnOnTypos:Ce});const rt={};function Be(n){return JSON.parse(JSON.stringify(n))}function xt(n){if(n&&typeof n=="object")return n;throw new Error("Polyopt requires the solver to return an object result.")}function Se(n,t,e){for(const i of e)if(!t.variables[i]){typeof n[i]!="number"&&(n[i]=0);for(const[s,o]of Object.entries(t.variables)){const r=o[i],a=n[s];typeof r=="number"&&typeof a=="number"&&(n[i]+=a*r)}}}function Oe(n,t){return`base-${t.map(i=>{const s=n[i];return typeof s=="number"?Math.round(s*1e3)/1e3:0}).join("-")}`}function Me(n){var t;const e={};for(const i of n)for(const[s,o]of Object.entries(i)){if(typeof o!="number")continue;const r=(t=e[s])!==null&&t!==void 0?t:{min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};e[s]={min:Math.min(r.min,o),max:Math.max(r.max,o)}}for(const i of n)for(const s of Object.keys(e))typeof i[s]!="number"&&(i[s]=0),e[s].min=Math.min(e[s].min,i[s]),e[s].max=Math.max(e[s].max,i[s]);for(const[i,s]of Object.entries(e))Number.isFinite(s.min)||(e[i]={min:0,max:0});return e}function bt(n,t){const e=Be(t),i=e.optimize,s=Object.keys(i);if(s.length===0)throw new Error("Multi-objective solve requires at least one objective definition.");const o=e;delete o.optimize,delete o.opType;const r={},a=new Set,c=[];for(const l of s)r[l]=0;for(const l of s){e.optimize=l,e.opType=i[l];const u=xt(n.Solve(e,void 0,void 0,!0));Se(u,e,s);const d=Oe(u,s);if(a.has(d))continue;a.add(d);for(const x of s){const b=u[x];typeof b=="number"&&(r[x]+=b)}const{feasible:p,result:m,bounded:v,...g}=u;c.push(g)}for(const l of s)e.constraints[l]={equal:r[l]/a.size};const h=`cheater-${Math.random()}`;e.optimize=h,e.opType="max";for(const l of Object.values(e.variables))l[h]=1;const f=Me(c);return{midpoint:xt(n.Solve(e,void 0,void 0,!0)),vertices:c,ranges:f}}function Ae(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function _e(n){var t={is_objective:/(max|min)(imize){0,}\:/i,is_int:/^(?!\/\*)\W{0,}int/i,is_bin:/^(?!\/\*)\W{0,}bin/i,is_constraint:/(\>|\<){0,}\=/i,is_unrestricted:/^\S{0,}unrestricted/i,parse_lhs:/(\-|\+){0,1}\s{0,1}\d{0,}\.{0,}\d{0,}\s{0,}[A-Za-z]\S{0,}/gi,parse_rhs:/(\-|\+){0,1}\d{1,}\.{0,}\d{0,}\W{0,}\;{0,1}$/i,parse_dir:/(\>|\<){0,}\=/gi,parse_int:/[^\s|^\,]+/gi,parse_bin:/[^\s|^\,]+/gi,get_num:/(\-|\+){0,1}(\W|^)\d+\.{0,1}\d{0,}/g,get_word:/[A-Za-z].*/},e={opType:"",optimize:"_obj",constraints:{},variables:{}},i={">=":"min","<=":"max","=":"equal"},s="",o=null,r="",a="",c="",h=0;typeof n=="string"&&(n=n.split(`
`));for(var f=0;f<n.length;f++)if(c="__"+f,s=n[f],o=null,t.is_objective.test(s))e.opType=s.match(/(max|min)/gi)[0],o=s.match(t.parse_lhs).map(function(u){return u.replace(/\s+/,"")}).slice(1),o.forEach(function(u){r=u.match(t.get_num),r===null?u.substr(0,1)==="-"?r=-1:r=1:r=r[0],r=parseFloat(r),a=u.match(t.get_word)[0].replace(/\;$/,""),e.variables[a]=e.variables[a]||{},e.variables[a]._obj=r});else if(t.is_int.test(s))o=s.match(t.parse_int).slice(1),e.ints=e.ints||{},o.forEach(function(u){u=u.replace(";",""),e.ints[u]=1});else if(t.is_bin.test(s))o=s.match(t.parse_bin).slice(1),e.binaries=e.binaries||{},o.forEach(function(u){u=u.replace(";",""),e.binaries[u]=1});else if(t.is_constraint.test(s)){var y=s.indexOf(":"),l=y===-1?s:s.slice(y+1);o=l.match(t.parse_lhs).map(function(u){return u.replace(/\s+/,"")}),o.forEach(function(u){r=u.match(t.get_num),r===null?u.substr(0,1)==="-"?r=-1:r=1:r=r[0],r=parseFloat(r),a=u.match(t.get_word)[0],e.variables[a]=e.variables[a]||{},e.variables[a][c]=r}),h=parseFloat(s.match(t.parse_rhs)[0]),s=i[s.match(t.parse_dir)[0]],e.constraints[c]=e.constraints[c]||{},e.constraints[c][s]=h}else t.is_unrestricted.test(s)&&(o=s.match(t.parse_int).slice(1),e.unrestricted=e.unrestricted||{},o.forEach(function(u){u=u.replace(";",""),e.unrestricted[u]=1}));return e}function Re(n){if(!n)throw new Error("Solver requires a model to operate on");var t="",e={max:"<=",min:">=",equal:"="},i=new RegExp("[^A-Za-z0-9_[{}/.&#$%~'@^]","gi");if(n.opType){t+=n.opType+":";for(var s in n.variables)n.variables[s][s]=n.variables[s][s]?n.variables[s][s]:1,n.variables[s][n.optimize]&&(t+=" "+n.variables[s][n.optimize]+" "+s.replace(i,"_"))}else t+="max:";t+=`;

`;for(var o in n.constraints)for(var r in n.constraints[o])if(typeof e[r]<"u"){for(var a in n.variables)typeof n.variables[a][o]<"u"&&(t+=" "+n.variables[a][o]+" "+a.replace(i,"_"));t+=" "+e[r]+" "+n.constraints[o][r],t+=`;
`}if(n.ints){t+=`

`;for(var c in n.ints)t+="int "+c.replace(i,"_")+`;
`}if(n.unrestricted){t+=`

`;for(var h in n.unrestricted)t+="unrestricted "+h.replace(i,"_")+`;
`}return t}var Pe=function(n){return n.length?_e(n):Re(n)},Ee=Ae(Pe);function wt(n,t,e){return{type:n,varIndex:t,value:e}}function J(n,t,e,i,s,o,r){return{relaxedEvaluation:n,cuts:t,depth:e,branchVarIndex:i,branchDirection:s,branchFractionality:o,parentEvaluation:r}}function Te(n={}){const{nodeSelection:t="hybrid",branching:e="pseudocost",useDiving:i=!0,strongBranchingCandidates:s=5}=n,o=new Map,r=l=>{let u=o.get(l);return u||(u={upSum:0,upCount:0,downSum:0,downCount:0},o.set(l,u)),u},a=(l,u,d,p)=>{const m=r(l),v=d/(u==="up"?1-p:p);u==="up"?(m.upSum+=v,m.upCount++):(m.downSum+=v,m.downCount++)},c=(l,u)=>{const d=r(l),p=d.upCount>0?d.upSum/d.upCount:1,m=d.downCount>0?d.downSum/d.downCount:1,v=p*(1-u),g=m*u;return Math.max(v,1e-6)*Math.max(g,1e-6)},h=(l,u)=>{const d=l.width,p=l.matrix,m=l.rhsColumn,v=l.model.integerVariables,g=l.precision;let x=[];for(const b of v){const C=b.index,O=l.rowByVarIndex[C];if(O!==-1){const B=p[O*d+m],S=Math.abs(B-Math.round(B));S>g&&x.push({index:C,value:B,fraction:S})}}if(x.length===0)return null;if(e==="most-fractional")return x.sort((b,C)=>C.fraction-b.fraction),{index:x[0].index,value:x[0].value};if(e==="pseudocost"){let b=-1/0,C=x[0];for(const O of x){const B=c(O.index,O.fraction);B>b&&(b=B,C=O)}return{index:C.index,value:C.value}}if(e==="strong"){x.sort((O,B)=>B.fraction-O.fraction),x=x.slice(0,s);let b=-1/0,C=x[0];for(const O of x){const B=r(O.index);if(B.upCount>=2&&B.downCount>=2){const S=c(O.index,O.fraction);S>b&&(b=S,C=O)}else{const S=O.fraction*(1-O.fraction);S>b&&(b=S,C=O)}}return{index:C.index,value:C.value}}return{index:x[0].index,value:x[0].value}},f=(l,u)=>{var d;if(l.restore(),l.addCutConstraints(u),l.simplex(),!((d=l.model)===null||d===void 0)&&d.useMIRCuts&&l.feasible){let p=!0,m=0;const v=3;for(;p&&m<v;){const g=l.computeFractionalVolume(!0);l.applyMIRCuts(),l.simplex();const x=l.computeFractionalVolume(!0);m++,x>=.9*g&&(p=!1)}}};return{applyCuts:f,branchAndCut:l=>{var u,d,p,m,v;const g=new pt,x=[];let b=0;const C=(d=(u=l.model)===null||u===void 0?void 0:u.tolerance)!==null&&d!==void 0?d:0;let O=!0,B=1e99;!((p=l.model)===null||p===void 0)&&p.timeout&&(B=Date.now()+l.model.timeout);let S=1/0,_=null;const I=[];for(let V=0;V<l.optionalObjectives.length;V+=1)I.push(1/0);const w=1;let M=0,P=t==="depth-first"||t==="hybrid";const z=J(-1/0,[],0);let k;for(P?x.push(z):g.push(z);(P?x.length>0:!g.isEmpty())&&O===!0&&Date.now()<B;){!((m=l.model)===null||m===void 0)&&m.isMinimization?k=l.bestPossibleEval*(1+C):k=l.bestPossibleEval*(1-C),C>0&&S<k&&(O=!1);let V;if(P&&x.length>0)V=x.pop();else if(!g.isEmpty())V=g.pop();else break;if(V.relaxedEvaluation>=S)continue;const E=V.cuts;if(l.evaluation,f(l,E),b++,!l.feasible)continue;const T=l.evaluation;if(!(T>S)){if(V.branchVarIndex!==void 0&&V.branchDirection!==void 0&&V.branchFractionality!==void 0&&V.parentEvaluation!==void 0){const R=Math.abs(T-V.parentEvaluation);a(V.branchVarIndex,V.branchDirection,R,V.branchFractionality)}if(T===S){let R=!0;for(let A=0;A<l.optionalObjectives.length&&!(l.optionalObjectives[A].reducedCosts[0]>I[A]);A++)if(l.optionalObjectives[A].reducedCosts[0]<I[A]){R=!1;break}if(R)continue}if(l.isIntegral()){if(l.__isIntegral=!0,M++,b===1){l.branchAndCutIterations=b;return}_=V,S=T;for(let R=0;R<l.optionalObjectives.length;R++)I[R]=l.optionalObjectives[R].reducedCosts[0];if(!((v=l.model)===null||v===void 0)&&v.keep_solutions){const R=l.model.tableau.getSolution(),A=R.generateSolutionSet();A.result=R.evaluation,l.model.solutions||(l.model.solutions=[]),l.model.solutions.push(A)}if(t==="hybrid"&&M>=w)for(P=!1;x.length>0;)g.push(x.pop())}else{b===1&&l.save();const R=h(l);if(!R)continue;const A=R.index,j=R.value,q=[],N=[],W=E.length;for(let U=0;U<W;U++){const L=E[U];L.varIndex===A?L.type==="min"?N.push(L):q.push(L):(q.push(L),N.push(L))}const D=Math.ceil(j),tt=Math.floor(j),et=D-j,it=j-tt,nt=wt("min",A,D);q.push(nt);const st=wt("max",A,tt);N.push(st);const $=V.depth+1;P?(x.push(J(T,N,$,A,"down",it,T)),x.push(J(T,q,$,A,"up",et,T))):(g.push(J(T,q,$,A,"up",et,T)),g.push(J(T,N,$,A,"down",it,T)))}}}_!==null&&f(l,_.cuts),l.branchAndCutIterations=b}}}function je(n){return{matrix:new Float64Array(n.matrix),width:n.width,height:n.height,nVars:n.nVars,varIndexByRow:n.varIndexByRow.slice(),varIndexByCol:n.varIndexByCol.slice(),rowByVarIndex:n.rowByVarIndex.slice(),colByVarIndex:n.colByVarIndex.slice(),availableIndexes:n.availableIndexes.slice(),lastElementIndex:n.lastElementIndex,evaluation:n.evaluation,feasible:n.feasible}}function ze(n,t){n.matrix.length>=t.matrix.length?n.matrix.set(t.matrix):n.matrix=new Float64Array(t.matrix),n.width=t.width,n.height=t.height,n.nVars=t.nVars;const e=t.height;for(let o=0;o<e;o++)n.varIndexByRow[o]=t.varIndexByRow[o];n.varIndexByRow.length=e;const i=t.width;for(let o=0;o<i;o++)n.varIndexByCol[o]=t.varIndexByCol[o];n.varIndexByCol.length=i;const s=t.nVars;for(let o=0;o<s;o++)n.rowByVarIndex[o]=t.rowByVarIndex[o],n.colByVarIndex[o]=t.colByVarIndex[o];n.availableIndexes=t.availableIndexes.slice(),n.lastElementIndex=t.lastElementIndex,n.evaluation=t.evaluation,n.feasible=t.feasible}function It(n,t,e){return{type:n,varIndex:t,value:e}}function Y(n,t,e,i,s){return{relaxedEvaluation:n,cuts:t,depth:e,parentCheckpoint:i,newCut:s}}function Fe(n={}){const{nodeSelection:t="hybrid",branching:e="pseudocost",maxCheckpoints:i=50}=n,s=new Map,o=l=>{let u=s.get(l);return u||(u={upSum:0,upCount:0,downSum:0,downCount:0},s.set(l,u)),u},r=(l,u,d,p)=>{const m=o(l),v=d/(u==="up"?1-p:p);u==="up"?(m.upSum+=v,m.upCount++):(m.downSum+=v,m.downCount++)},a=(l,u)=>{const d=o(l),p=d.upCount>0?d.upSum/d.upCount:1,m=d.downCount>0?d.downSum/d.downCount:1,v=p*(1-u),g=m*u;return Math.max(v,1e-6)*Math.max(g,1e-6)},c=l=>{const u=l.width,d=l.matrix,p=l.rhsColumn,m=l.model.integerVariables,v=l.precision,g=[];for(const C of m){const O=C.index,B=l.rowByVarIndex[O];if(B!==-1){const S=d[B*u+p],_=Math.abs(S-Math.round(S));_>v&&g.push({index:O,value:S,fraction:_})}}if(g.length===0)return null;if(e==="most-fractional")return g.sort((C,O)=>O.fraction-C.fraction),g[0];let x=-1/0,b=g[0];for(const C of g){const O=a(C.index,C.fraction);O>x&&(x=O,b=C)}return b},h=(l,u)=>{var d;if(l.restore(),l.addCutConstraints(u),l.simplex(),!((d=l.model)===null||d===void 0)&&d.useMIRCuts&&l.feasible){let p=!0,m=0;const v=3;for(;p&&m<v;){const g=l.computeFractionalVolume(!0);l.applyMIRCuts(),l.simplex();const x=l.computeFractionalVolume(!0);m++,x>=.9*g&&(p=!1)}}},f=(l,u)=>{var d;if(u.parentCheckpoint&&u.newCut?(ze(l,u.parentCheckpoint),l.addCutConstraints([u.newCut]),l.simplex()):(l.restore(),l.addCutConstraints(u.cuts),l.simplex()),!((d=l.model)===null||d===void 0)&&d.useMIRCuts&&l.feasible){let p=!0,m=0;const v=3;for(;p&&m<v;){const g=l.computeFractionalVolume(!0);l.applyMIRCuts(),l.simplex();const x=l.computeFractionalVolume(!0);m++,x>=.9*g&&(p=!1)}}};return{applyCuts:h,branchAndCut:l=>{var u,d,p,m,v;const g=new pt,x=[];let b=0,C=0;const O=(d=(u=l.model)===null||u===void 0?void 0:u.tolerance)!==null&&d!==void 0?d:0;let B=!0,S=1e99;!((p=l.model)===null||p===void 0)&&p.timeout&&(S=Date.now()+l.model.timeout);let _=1/0,I=null;const w=[];for(let V=0;V<l.optionalObjectives.length;V++)w.push(1/0);const M=1;let P=0,z=t==="depth-first"||t==="hybrid";const k=Y(-1/0,[],0);for(z?x.push(k):g.push(k);(z?x.length>0:!g.isEmpty())&&B===!0&&Date.now()<S;){let V;!((m=l.model)===null||m===void 0)&&m.isMinimization?V=l.bestPossibleEval*(1+O):V=l.bestPossibleEval*(1-O),O>0&&_<V&&(B=!1);let E;if(z&&x.length>0)E=x.pop();else if(!g.isEmpty())E=g.pop();else break;if(E.relaxedEvaluation>=_)continue;const T=l.evaluation;if(f(l,E),b++,!l.feasible)continue;const R=l.evaluation;if(!(R>_)){if(E.newCut&&T!==0){const A=Math.abs(R-T);r(E.newCut.varIndex,E.newCut.type==="min"?"up":"down",A,.5)}if(R===_){let A=!0;for(let j=0;j<l.optionalObjectives.length&&!(l.optionalObjectives[j].reducedCosts[0]>w[j]);j++)if(l.optionalObjectives[j].reducedCosts[0]<w[j]){A=!1;break}if(A)continue}if(l.isIntegral()){if(l.__isIntegral=!0,P++,b===1){l.branchAndCutIterations=b;return}I=E,_=R;for(let A=0;A<l.optionalObjectives.length;A++)w[A]=l.optionalObjectives[A].reducedCosts[0];if(!((v=l.model)===null||v===void 0)&&v.keep_solutions){const A=l.model.tableau.getSolution(),j=A.generateSolutionSet();j.result=A.evaluation,l.model.solutions||(l.model.solutions=[]),l.model.solutions.push(j)}if(t==="hybrid"&&P>=M)for(z=!1;x.length>0;)g.push(x.pop())}else{b===1&&l.save();const A=c(l);if(!A)continue;const j=A.index,q=A.value;let N;z&&C<i&&(N=je(l),C++);const W=[],D=[],tt=E.cuts.length;for(let U=0;U<tt;U++){const L=E.cuts[U];L.varIndex===j?L.type==="min"?D.push(L):W.push(L):(W.push(L),D.push(L))}const et=Math.ceil(q),it=Math.floor(q),nt=It("min",j,et);W.push(nt);const st=It("max",j,it);D.push(st);const $=E.depth+1;z?(x.push(Y(R,D,$,N,st)),x.push(Y(R,W,$,N,nt))):(g.push(Y(R,W,$)),g.push(Y(R,D,$)))}}}I!==null&&h(l,I.cuts),l.branchAndCutIterations=b}}}class ke{constructor(){this.Model=ut,this.Tableau=Tt,this.Constraint=Z,this.Variable=lt,this.Numeral=Zt,this.Term=Rt,this.External=rt,this.ReformatLP=Ee,this.branchAndCutService=ft(),this.branchAndCut=t=>this.branchAndCutService.branchAndCut(t),this.lastSolvedModel=null}selectBranchAndCutService(t){var e,i,s,o;const r=t.options,a=r?.nodeSelection||r?.branching;return r?.useIncremental===!0?Fe({nodeSelection:(e=r?.nodeSelection)!==null&&e!==void 0?e:"hybrid",branching:(i=r?.branching)!==null&&i!==void 0?i:"pseudocost"}):a?Te({nodeSelection:(s=r?.nodeSelection)!==null&&s!==void 0?s:"hybrid",branching:(o=r?.branching)!==null&&o!==void 0?o:"pseudocost",useDiving:!0}):ft()}Solve(t,e,i,s){if(s)for(const a in yt){const c=yt[a];typeof c=="function"&&(t=c(t))}if(!t)throw new Error("Solver requires a model to operate on");if(typeof t.optimize=="object"&&Object.keys(t.optimize).length>1)return bt(this,t);if(t.external)return this.solveWithExternalSolver(t);let o;if(t instanceof ut)o=t;else{const a=this.selectBranchAndCutService(t);o=new ut(e,void 0,a).loadJson(t)}const r=o.solve();return this.lastSolvedModel=o,r.solutionSet=r.generateSolutionSet(),i?r:this.buildSimplifiedResult(r)}solveWithExternalSolver(t){var e;const i=Object.keys(rt),s=JSON.stringify(i);if(!(!((e=t.external)===null||e===void 0)&&e.solver))throw new Error(`Model has 'external' object without solver attribute. Available: ${s}`);const o=t.external.solver;if(!rt[o])throw new Error(`Solver '${o}' not supported. Available: ${s}`);return rt[o].solve(t)}buildSimplifiedResult(t){const e={feasible:t.feasible,result:t.evaluation,bounded:t.bounded};t._tableau.__isIntegral&&(e.isIntegral=!0);for(const i of Object.keys(t.solutionSet)){const s=t.solutionSet[i];s!==0&&(e[i]=s)}return e}MultiObjective(t){return bt(this,t)}}const K=new ke;typeof define=="function"?define([],()=>K):typeof window=="object"?window.solver=K:typeof self=="object"&&(self.solver=K);F.setLevel("warn");const Le=1,Ct="p_",Vt="o_";function Bt(n,t){const e=[];for(const i of n.playerActions){const s=[];for(const o of n.opponentActions){const r=`${i}-${o}`,a=n.rewards.get(r),c=n.children.get(r);let h=0;a?h=t?a[0]:a[1]:c&&(h=t?c.playerValue:c.opponentValue),s.push(h)}e.push(s)}return e}function St(n){let t=1/0;for(const e of n)for(const i of e)t=Math.min(t,i);return t<0?-t+Le:0}function Ot(n,t,e){const i=new Map;for(const s of t){const o=`${e}${s}`,r=n[o]??0;i.set(s,r)}return i}function Mt(n){const t=new Map,e=1/n.length;for(const i of n)t.set(i,e);return t}class Ne{constructor(t,e=!1){this.nodeId=t,this.isTerminal=e,this.playerActions=[],this.opponentActions=[],this.children=new Map,this.rewards=new Map,this.playerStrategy=new Map,this.opponentStrategy=new Map,this.playerValue=0,this.opponentValue=0}}class $e{constructor(t){this.initialized=!1,this.gameTree=t,this.nodes=new Map,this.nodeMap=new Map,this.topologicalOrder=[]}buildInternalTree(){const t=this.gameTree.nodes[this.gameTree.root];return t?(this.collectAllNodes(t),this.buildLPNode(t)?(this.computeTopologicalOrder(),this.initialized=!0,!0):!1):(F.error(`Root node ${this.gameTree.root} not found in nodes map`),!1)}collectAllNodes(t){this.nodeMap.set(t.nodeId,t);for(const e of t.transitions){if(!e.nextNodeId)continue;const i=this.findNodeById(e.nextNodeId);!i||this.nodeMap.has(i.nodeId)||this.collectAllNodes(i)}}findNodeById(t){if(this.nodeMap.has(t))return this.nodeMap.get(t);const e=this.gameTree.nodes[t];if(e)return e}isTerminalNode(t){return t.playerReward!==void 0||t.opponentReward!==void 0}buildLPNode(t){if(this.nodes.has(t.nodeId))return this.nodes.get(t.nodeId);const e=this.isTerminalNode(t),i=new Ne(t.nodeId,e);t.playerActions&&(i.playerActions=t.playerActions.actions.map(s=>s.actionId)),t.opponentActions&&(i.opponentActions=t.opponentActions.actions.map(s=>s.actionId));for(const s of t.transitions){const o=`${s.playerActionId}-${s.opponentActionId}`;if(!s.nextNodeId)return F.error(`Transition in node "${t.nodeId}" (player action: ${s.playerActionId}, opponent action: ${s.opponentActionId}) has no nextNodeId`),null;const r=this.nodeMap.get(s.nextNodeId);if(!r)return F.error(`Transition in node "${t.nodeId}" references non-existent node "${s.nextNodeId}"`),null;if(this.isTerminalNode(r)){const c=r.playerReward?.value??0,h=r.opponentReward?.value??0;i.rewards.set(o,[c,h]);continue}const a=this.buildLPNode(r);if(!a)return null;i.children.set(o,a)}return this.nodes.set(t.nodeId,i),i}computeTopologicalOrder(){const t=new Set,e=new Set,i=[],s=o=>{if(e.has(o)||t.has(o))return;e.add(o);const r=this.nodes.get(o);if(r){const a=Array.from(r.children.values());for(const c of a)s(c.nodeId)}e.delete(o),t.add(o),i.push(o)};s(this.gameTree.root),this.topologicalOrder=i}solvePlayerLP(t){if(t.playerActions.length===0)return;if(F.debug("Solving player LP for node:",t.nodeId),t.playerActions.length===1){t.playerStrategy.set(t.playerActions[0],1),t.playerValue=this.calculateMinimaxValueForSinglePlayerAction(t),F.debug("Single player action, value:",t.playerValue);return}const e=Bt(t,!0),i=St(e),s=this.buildPlayerLPModel(t,e,i),o=K.Solve(s);o.feasible?(t.playerStrategy=Ot(o,t.playerActions,Ct),t.playerValue=(o.v??0)-i,F.debug("Player LP solved, value:",t.playerValue)):(F.warn(`LP solver infeasible for player at node "${t.nodeId}", using uniform strategy`),t.playerStrategy=Mt(t.playerActions),t.playerValue=this.calculateExpectedValue(t,!0))}buildPlayerLPModel(t,e,i){const s={optimize:"v",opType:"max",constraints:{},variables:{}};s.constraints.prob_sum={equal:1};for(let o=0;o<t.opponentActions.length;o++)s.constraints[`opp_${o}`]={min:0};s.variables.v={v:1};for(let o=0;o<t.opponentActions.length;o++)s.variables.v[`opp_${o}`]=-1;for(let o=0;o<t.playerActions.length;o++){const r=t.playerActions[o],a=`${Ct}${r}`;s.variables[a]={prob_sum:1};for(let c=0;c<t.opponentActions.length;c++){const h=e[o][c]+i;s.variables[a][`opp_${c}`]=h}}return s}solveOpponentLP(t){if(t.opponentActions.length===0)return;if(F.debug("Solving opponent LP for node:",t.nodeId),t.opponentActions.length===1){t.opponentStrategy.set(t.opponentActions[0],1),t.opponentValue=this.calculateMinimaxValueForSingleOpponentAction(t),F.debug("Single opponent action, value:",t.opponentValue);return}const e=Bt(t,!1),i=St(e),s=this.buildOpponentLPModel(t,e,i),o=K.Solve(s);o.feasible?(t.opponentStrategy=Ot(o,t.opponentActions,Vt),t.opponentValue=(o.v??0)-i,F.debug("Opponent LP solved, value:",t.opponentValue)):(F.warn(`LP solver infeasible for opponent at node "${t.nodeId}", using uniform strategy`),t.opponentStrategy=Mt(t.opponentActions),t.opponentValue=this.calculateExpectedValue(t,!1))}buildOpponentLPModel(t,e,i){const s={optimize:"v",opType:"max",constraints:{},variables:{}};s.constraints.prob_sum={equal:1};for(let o=0;o<t.playerActions.length;o++)s.constraints[`player_${o}`]={min:0};s.variables.v={v:1};for(let o=0;o<t.playerActions.length;o++)s.variables.v[`player_${o}`]=-1;for(let o=0;o<t.opponentActions.length;o++){const r=t.opponentActions[o],a=`${Vt}${r}`;s.variables[a]={prob_sum:1};for(let c=0;c<t.playerActions.length;c++){const h=e[c][o]+i;s.variables[a][`player_${c}`]=h}}return s}calculateMinimaxValueForSinglePlayerAction(t){const e=t.playerActions[0];let i=1/0;for(const s of t.opponentActions){const o=`${e}-${s}`,r=t.rewards.get(o),a=t.children.get(o);let c=0;r?c=r[0]:a&&(c=a.playerValue),i=Math.min(i,c)}return i===1/0?0:i}calculateMinimaxValueForSingleOpponentAction(t){const e=t.opponentActions[0];let i=1/0;for(const s of t.playerActions){const o=`${s}-${e}`,r=t.rewards.get(o),a=t.children.get(o);let c=0;r?c=r[1]:a&&(c=a.opponentValue),i=Math.min(i,c)}return i===1/0?0:i}calculateExpectedValue(t,e){let i=0;for(const s of t.playerActions){const o=t.playerStrategy.get(s)??1/t.playerActions.length;for(const r of t.opponentActions){const a=t.opponentStrategy.get(r)??1/t.opponentActions.length,c=`${s}-${r}`,h=t.rewards.get(c),f=t.children.get(c);let y=0;h?y=e?h[0]:h[1]:f&&(y=e?f.playerValue:f.opponentValue),i+=o*a*y}}return i}solve(t){if(F.debug("Starting LP solver"),!this.initialized){if(F.debug("Building internal tree structure"),!this.buildInternalTree())return F.error("Failed to build internal tree"),!1;F.debug("Topological order computed, nodes:",this.topologicalOrder.length)}for(const e of this.topologicalOrder){const i=this.nodes.get(e);!i||i.isTerminal||(this.solvePlayerLP(i),this.solveOpponentLP(i))}return F.debug("LP solver completed successfully"),!0}getAverageStrategy(t){const e=this.nodes.get(t);if(!e)return null;if(e.playerStrategy.size===0&&e.playerActions.length>0){const i=new Map,s=1/e.playerActions.length;for(const o of e.playerActions)i.set(o,s);return i}return new Map(e.playerStrategy)}getAverageOpponentStrategy(t){const e=this.nodes.get(t);if(!e)return null;if(e.opponentStrategy.size===0&&e.opponentActions.length>0){const i=new Map,s=1/e.opponentActions.length;for(const o of e.opponentActions)i.set(o,s);return i}return new Map(e.opponentStrategy)}getRootStrategy(){return this.getAverageStrategy(this.gameTree.root)}}let Q=null,X=null;function G(n){self.postMessage(n)}function jt(n){if(!Q||!X)return null;const t=X.nodes[n];if(!t)return F.warn(`Node not found in gameTree while getting strategy: ${n}`),null;const e=Q.getAverageStrategy(n),i=[];if(t.playerActions)for(const r of t.playerActions.actions){const a=e?.get(r.actionId)??0;i.push({actionId:r.actionId,probability:a})}const s=Q.getAverageOpponentStrategy(n),o=[];if(t.opponentActions)for(const r of t.opponentActions.actions){const a=s?.get(r.actionId)??0;o.push({actionId:r.actionId,probability:a})}return{nodeId:n,playerStrategy:i,opponentStrategy:o}}function zt(){if(!X)return{};const n={};for(const t of Object.keys(X.nodes)){const e=jt(t);e&&(n[t]=e)}return n}async function qe(n){if(X=n,Q=new $e(n),!Q.solve()){G({type:"error",message:"Failed to build game tree for solver. Check console for details."});return}const t=zt();G({type:"complete",strategies:t})}self.onmessage=async n=>{const t=n.data;switch(t.type){case"start":try{await qe(t.gameTree)}catch(e){G({type:"error",message:e instanceof Error?e.message:"Unknown error"})}break;case"pause":break;case"resume":break;case"getStrategy":{const e=jt(t.nodeId);G({type:"strategy",nodeId:t.nodeId,data:e});break}case"getAllStrategies":G({type:"allStrategies",strategies:zt()});break}};
