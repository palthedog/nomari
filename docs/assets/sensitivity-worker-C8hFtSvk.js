function Yt(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var Te={exports:{}},Ht=Te.exports,We;function Wt(){return We||(We=1,(function(n){(function(e,t){n.exports?n.exports=t():e.log=t()})(Ht,function(){var e=function(){},t="undefined",i=typeof window!==t&&typeof window.navigator!==t&&/Trident\/|MSIE /.test(window.navigator.userAgent),s=["trace","debug","info","warn","error"],o={},r=null;function a(p,g){var m=p[g];if(typeof m.bind=="function")return m.bind(p);try{return Function.prototype.bind.call(m,p)}catch{return function(){return Function.prototype.apply.apply(m,[p,arguments])}}}function c(){console.log&&(console.log.apply?console.log.apply(console,arguments):Function.prototype.apply.apply(console.log,[console,arguments])),console.trace&&console.trace()}function l(p){return p==="debug"&&(p="log"),typeof console===t?!1:p==="trace"&&i?c:console[p]!==void 0?a(console,p):console.log!==void 0?a(console,"log"):e}function f(){for(var p=this.getLevel(),g=0;g<s.length;g++){var m=s[g];this[m]=g<p?e:this.methodFactory(m,p,this.name)}if(this.log=this.debug,typeof console===t&&p<this.levels.SILENT)return"No console available for logging"}function b(p){return function(){typeof console!==t&&(f.call(this),this[p].apply(this,arguments))}}function u(p,g,m){return l(p)||b.apply(this,arguments)}function h(p,g){var m=this,w,v,I,C="loglevel";typeof p=="string"?C+=":"+p:typeof p=="symbol"&&(C=void 0);function _(x){var A=(s[x]||"silent").toUpperCase();if(!(typeof window===t||!C)){try{window.localStorage[C]=A;return}catch{}try{window.document.cookie=encodeURIComponent(C)+"="+A+";"}catch{}}}function O(){var x;if(!(typeof window===t||!C)){try{x=window.localStorage[C]}catch{}if(typeof x===t)try{var A=window.document.cookie,M=encodeURIComponent(C),Y=A.indexOf(M+"=");Y!==-1&&(x=/^([^;]+)/.exec(A.slice(Y+M.length+1))[1])}catch{}return m.levels[x]===void 0&&(x=void 0),x}}function E(){if(!(typeof window===t||!C)){try{window.localStorage.removeItem(C)}catch{}try{window.document.cookie=encodeURIComponent(C)+"=; expires=Thu, 01 Jan 1970 00:00:00 UTC"}catch{}}}function R(x){var A=x;if(typeof A=="string"&&m.levels[A.toUpperCase()]!==void 0&&(A=m.levels[A.toUpperCase()]),typeof A=="number"&&A>=0&&A<=m.levels.SILENT)return A;throw new TypeError("log.setLevel() called with invalid level: "+x)}m.name=p,m.levels={TRACE:0,DEBUG:1,INFO:2,WARN:3,ERROR:4,SILENT:5},m.methodFactory=g||u,m.getLevel=function(){return I??v??w},m.setLevel=function(x,A){return I=R(x),A!==!1&&_(I),f.call(m)},m.setDefaultLevel=function(x){v=R(x),O()||m.setLevel(x,!1)},m.resetLevel=function(){I=null,E(),f.call(m)},m.enableAll=function(x){m.setLevel(m.levels.TRACE,x)},m.disableAll=function(x){m.setLevel(m.levels.SILENT,x)},m.rebuild=function(){if(r!==m&&(w=R(r.getLevel())),f.call(m),r===m)for(var x in o)o[x].rebuild()},w=R(r?r.getLevel():"WARN");var T=O();T!=null&&(I=R(T)),f.call(m)}r=new h,r.getLogger=function(g){if(typeof g!="symbol"&&typeof g!="string"||g==="")throw new TypeError("You must supply a name when creating a logger.");var m=o[g];return m||(m=o[g]=new h(g,r.methodFactory)),m};var d=typeof window!==t?window.log:void 0;return r.noConflict=function(){return typeof window!==t&&window.log===r&&(window.log=d),r},r.getLoggers=function(){return o},r.default=r,r})})(Te)),Te.exports}var qt=Wt(),k=Yt(qt);class vt{constructor(e,t,i,s){this.feasible=i,this.evaluation=t,this.bounded=s,this._tableau=e,this.solutionSet={}}generateSolutionSet(){const e={},t=this._tableau,i=t.varIndexByRow,s=t.variablesPerIndex,o=t.matrix,r=t.width,a=t.rhsColumn,c=t.height-1,l=Math.round(1/t.precision);for(let f=1;f<=c;f+=1){const b=i[f],u=s[b];if(u===void 0||u.isSlack===!0)continue;const h=o[f*r+a];e[u.id]=Math.round((Number.EPSILON+h)*l)/l}return e}}class Kt extends vt{constructor(e,t,i,s,o){super(e,t,i,s),this.iter=o}}class Ye{constructor(e=64){this.heap=new Array(e),this.size=0,this.seqCounter=0,this.pool=new Array(64),this.poolSize=0}allocEntry(e,t){if(this.poolSize>0){const i=this.pool[--this.poolSize];return i.branch=e,i.seq=t,i}return{branch:e,seq:t}}freeEntry(e){this.poolSize<256&&(this.pool[this.poolSize++]=e)}get length(){return this.size}isEmpty(){return this.size===0}clear(){this.size=0,this.seqCounter=0}isBefore(e,t){return e.branch.relaxedEvaluation!==t.branch.relaxedEvaluation?e.branch.relaxedEvaluation<t.branch.relaxedEvaluation:e.seq>t.seq}push(e){const t=this.heap;let i=this.size;this.size++,i>=t.length&&(t.length=t.length*2);const s=this.allocEntry(e,this.seqCounter++);for(;i>0;){const o=i-1>>1,r=t[o];if(!this.isBefore(s,r))break;t[i]=r,i=o}t[i]=s}pop(){if(this.size===0)return;const e=this.heap,t=e[0],i=t.branch;if(this.size--,this.freeEntry(t),this.size===0)return i;const s=e[this.size];let o=0;const r=this.size>>1;for(;o<r;){let a=(o<<1)+1,c=e[a];const l=a+1;if(l<this.size&&this.isBefore(e[l],c)&&(a=l,c=e[l]),!this.isBefore(c,s))break;e[o]=c,o=a}return e[o]=s,i}peek(){return this.size>0?this.heap[0].branch:void 0}}function qe(n,e,t){return{type:n,varIndex:e,value:t}}function ke(n,e){return{relaxedEvaluation:n,cuts:e}}function Le(){const n=(t,i)=>{var s;if(t.restore(),t.addCutConstraints(i),t.simplex(),!((s=t.model)===null||s===void 0)&&s.useMIRCuts){let o=t.computeFractionalVolume(!0);for(;o>0;){t.applyMIRCuts(),t.simplex();const r=t.computeFractionalVolume(!0);if(r>=.9*o)break;o=r}}};return{applyCuts:n,branchAndCut:t=>{var i,s,o,r,a;const c=new Ye;let l=0;const f=(s=(i=t.model)===null||i===void 0?void 0:i.tolerance)!==null&&s!==void 0?s:0;let b=!0,u=1e99;!((o=t.model)===null||o===void 0)&&o.timeout&&(u=Date.now()+t.model.timeout);let h=1/0,d=null;const p=[],g=t.optionalObjectives,m=g.length;for(let I=0;I<m;I+=1)p.push(1/0);const w=ke(-1/0,[]);let v;for(c.push(w);!c.isEmpty()&&b===!0&&Date.now()<u;){!((r=t.model)===null||r===void 0)&&r.isMinimization?v=t.bestPossibleEval*(1+f):v=t.bestPossibleEval*(1-f),f>0&&h<v&&(b=!1);const I=c.pop();if(I.relaxedEvaluation>=h)continue;const C=I.cuts;if(n(t,C),l++,t.feasible===!1)continue;const _=t.evaluation;if(!(_>h)){if(_===h){let O=!0;for(let E=0;E<m;E+=1){const R=g[E].reducedCosts[0],T=p[E];if(R>T)break;if(R<T){O=!1;break}}if(O)continue}if(t.isIntegral()===!0){if(t.__isIntegral=!0,l===1){t.branchAndCutIterations=l;return}d=I,h=_;for(let O=0;O<m;O+=1)p[O]=g[O].reducedCosts[0];if(!((a=t.model)===null||a===void 0)&&a.keep_solutions){const O=t.model.tableau.getSolution(),E=O.generateSolutionSet();E.result=O.evaluation,t.model.solutions||(t.model.solutions=[]),t.model.solutions.push(E)}}else{l===1&&t.save();const O=t.getMostFractionalVar(),E=O.index,R=O.value,T=[],x=[],A=C.length;for(let H=0;H<A;H+=1){const N=C[H];N.varIndex===E?N.type==="min"?x.push(N):T.push(N):(T.push(N),x.push(N))}const M=qe("min",E,Math.ceil(R));T.push(M);const Y=qe("max",E,Math.floor(R));x.push(Y),c.push(ke(_,T)),c.push(ke(_,x))}}}d!==null&&n(t,d.cuts),t.branchAndCutIterations=l}}}class It{constructor(){this.pairs=[],this.positions=new Map}add(e,t){const i=`${e}_${t}`,s=this.pairs.length;this.pairs.push([e,t]);const o=this.positions.get(i);if(o===void 0)return this.positions.set(i,[s]),[];for(const r of o){const a=s-r;if(a>this.pairs.length-s)continue;let c=!0;for(let l=1;l<a&&r+a+l<this.pairs.length;l++){const f=this.pairs[r+l],b=this.pairs[r+a+l];if(f[0]!==b[0]||f[1]!==b[1]){c=!1;break}}if(c)return[r,a]}return o.push(s),[]}}function Xt(){return this.bounded=!0,this.phase1(),this.feasible===!0&&this.phase2(),this}function Jt(){const n=this.matrix,e=this.width,t=this.rhsColumn,i=e-1,s=this.height-1,r=-this.precision;let a=0;const c=1e4;for(;a<c;){let l=0,f=r;for(let d=1;d<=s;d++){const p=n[d*e+t];p<f&&(f=p,l=d)}if(l===0)return this.feasible=!0,this.setEvaluation(),a;let b=0,u=1/0;const h=l*e;for(let d=1;d<=i;d++){const p=n[h+d];if(p<r){const g=n[d];if(g>=r){const m=g/-p;m<u&&(u=m,b=d)}}}if(b===0)return this.feasible=!1,-1;this.pivot(l,b),a++}return this.feasible=!1,a}function Zt(){const e=this.model.checkForCycles?new It:null,t=this.matrix,i=this.width,s=this.rhsColumn,o=this.width-1,r=this.height-1,a=this.precision,c=-a,l=this.unrestrictedVars,f=this.varIndexByRow,b=this.varIndexByCol,u=10,h=Math.max(r,o);let d=0,p=!1,g=-1/0,m=null,w=null,v=null,I=null,C=null;for(;;){let _=0,O=c;for(let T=1;T<=r;T++){if(l[f[T]]===!0)continue;const x=t[T*i+s];x<O&&(O=x,_=T)}if(_===0)return this.feasible=!0,d;if(!p&&d>0&&O<=g&&(d>=u&&m===null&&(m=t.slice(),w=f.slice(),v=b.slice(),I=this.rowByVarIndex.slice(),C=this.colByVarIndex.slice()),d>=h&&(p=!0,m))){t.set(m);for(let T=0;T<w.length;T++)f[T]=w[T];for(let T=0;T<v.length;T++)b[T]=v[T];for(let T=0;T<I.length;T++)this.rowByVarIndex[T]=I[T];for(let T=0;T<C.length;T++)this.colByVarIndex[T]=C[T];d=0;continue}d===0&&(g=O);let E=0;const R=_*i;if(p){for(let T=1;T<=o;T++)if(t[R+T]<c){E=T;break}if(E===0)for(let T=1;T<=o;T++){const x=t[R+T];if(l[b[T]]===!0&&(x<c||x>a)){E=T;break}}}else{let T=-1/0;for(let x=1;x<=o;x++){const A=t[R+x];if(A<c){const M=-t[x]/A;T<M&&(T=M,E=x)}}if(E===0)for(let x=1;x<=o;x++){const A=t[R+x];if(l[b[x]]===!0&&(A<c||A>a)){E=x;break}}}if(E===0)return this.feasible=!1,d;if(e){const T=e.add(f[_],b[E]);if(T.length>0)return this.model.messages.push("Cycle in phase 1"),this.model.messages.push("Start :"+T[0]),this.model.messages.push("Length :"+T[1]),this.feasible=!1,d}this.pivot(_,E),d+=1}}function Qt(){const e=this.model.checkForCycles?new It:null,t=this.matrix,i=this.width,s=this.rhsColumn,o=this.width-1,r=this.height-1,a=this.precision,c=-a,l=this.optionalObjectives.length;let f=null;const b=this.unrestrictedVars,u=this.varIndexByCol,h=this.varIndexByRow;let d=0,p,g;const m=100,w=5;let v=!1,I=t[s],C=0,_=0,O=0;const E=o,R=this.pricingBatchSize>0?this.pricingBatchSize:Math.min(500,Math.max(50,Math.floor(Math.sqrt(E)))),T=E>R*2;for(;;){if(l>0&&(f=[]),!v&&d>0&&d%m===0){const N=t[s],L=Math.abs(N-I),D=Math.max(1,Math.abs(I));L/D<1e-10?(C++,C>=w&&(v=!0,_=d,O=N)):C=0,I=N}if(v&&d-_>r){const N=t[s],L=Math.abs(N-O),D=Math.max(1,Math.abs(O));if(L/D<1e-10)return this.setEvaluation(),this.simplexIters+=1,d;_=d,O=N}let x=0,A=a,M=!1;if(v)for(let N=1;N<=o;N++){if(p=t[N],g=b[u[N]]===!0,g&&p<0){x=N,A=-p,M=!0;break}if(p>a){x=N,A=p,M=!1;break}}else if(T){const N=this.pricingBatchStart;let L=0;const D=Math.ceil(E/R);for(;x===0&&L<D;){const B=this.pricingBatchStart,S=Math.min(B+R-1,o);for(let $=B;$<=S;$++){if(p=t[$],g=b[u[$]]===!0,l>0&&c<p&&p<a){f?.push($);continue}if(g&&p<0){-p>A&&(A=-p,x=$,M=!0);continue}p>A&&(A=p,x=$,M=!1)}this.pricingBatchStart=S>=o?1:S+1,L++}x!==0&&(this.pricingBatchStart=N)}else for(let N=1;N<=o;N++){if(p=t[N],g=b[u[N]]===!0,l>0&&c<p&&p<a){f?.push(N);continue}if(g&&p<0){-p>A&&(A=-p,x=N,M=!0);continue}p>A&&(A=p,x=N,M=!1)}if(l>0){let N=0;for(;x===0&&f&&f.length>0&&N<l;){const L=[],D=this.optionalObjectives[N].reducedCosts;A=a;for(let B=0;B<f.length;B++){const S=f[B];if(p=D[S],g=b[u[S]]===!0,c<p&&p<a){L.push(S);continue}if(g&&p<0){-p>A&&(A=-p,x=S,M=!0);continue}p>A&&(A=p,x=S,M=!1)}f=L,N+=1}}if(x===0)return this.setEvaluation(),this.simplexIters+=1,d;let Y=0,H=1/0;for(let N=1;N<=r;N++){const L=N*i,D=t[L+s],B=t[L+x];if(c<B&&B<a)continue;if(B>0&&a>D&&D>c){H=0,Y=N;break}const S=M?-D/B:D/B;S>a&&H>S&&(H=S,Y=N)}if(H===1/0)return this.evaluation=-1/0,this.bounded=!1,this.unboundedVarIndex=u[x],d;if(e){const N=e.add(h[Y],u[x]);if(N.length>0)return this.model.messages.push("Cycle in phase 2"),this.model.messages.push("Start :"+N[0]),this.model.messages.push("Length :"+N[1]),this.feasible=!1,d}this.pivot(Y,x),d+=1}}let re=new Int32Array(1024),we=new Float64Array(1024);function en(n,e){const t=this.matrix,i=this.width;i>re.length&&(re=new Int32Array(i*2),we=new Float64Array(i*2));const s=n*i,o=t[s+e],r=1/o,a=this.height,c=this.varIndexByRow[n],l=this.varIndexByCol[e];this.varIndexByRow[n]=l,this.varIndexByCol[e]=c,this.rowByVarIndex[l]=n,this.rowByVarIndex[c]=-1,this.colByVarIndex[l]=-1,this.colByVarIndex[c]=e;let f=0;for(let h=0;h<i;h++){const d=s+h,p=t[d];if(p>=-1e-16&&p<=1e-16)t[d]=0;else{const g=p/o;t[d]=g,re[f]=h,we[f]=g,f++}}t[s+e]=r;for(let h=0;h<a;h++)if(h!==n){const d=h*i,p=t[d+e];if(!(p>=-1e-16&&p<=1e-16)){const g=p;if(g>=-1e-16&&g<=1e-16)g!==0&&(t[d+e]=0);else{for(let m=0;m<f;m++){const w=re[m],v=we[m];v>=-1e-16&&v<=1e-16?v!==0&&(t[s+w]=0):t[d+w]-=g*v}t[d+e]=-g/o}}}const b=this.optionalObjectives,u=b.length;if(u>0)for(let h=0;h<u;h++){const d=b[h].reducedCosts,p=d[e];if(p!==0){for(let g=0;g<f;g++){const m=re[g];d[m]-=p*we[g]}d[e]=-p*r}}}function tn(n){for(let e=0;e<n.length-1;e++)for(let t=e+1;t<n.length;t++){const i=n[e],s=n[t];if(i[0]===s[0]&&i[1]===s[1]){if(t-e>n.length-t)break;let o=!0;for(let r=1;r<t-e;r++){const a=n[e+r],c=n[t+r];if(a[0]!==c[0]||a[1]!==c[1]){o=!1;break}}if(o)return[e,t-e]}}return[]}class Se{constructor(e,t,i,s){this.id=e,this.cost=t,this.index=i,this.value=0,this.priority=s}}class nn extends Se{constructor(e,t,i,s){super(e,t,i,s),this.isInteger=!0}}class Re extends Se{constructor(e,t){super(e,0,t,0),this.isSlack=!0}}class xt{constructor(e,t){this.variable=e,this.coefficient=t}}function Tt(n,e,t){if(t===0||t==="required")return null;const i=e===void 0?1:e,s=t===void 0?1:t,o=n.isMinimization===!1?-i:i;return n.addVariable(o,"r"+n.relaxationIndex++,!1,!1,s)}class le{constructor(e,t,i,s){this.slack=new Re("s"+i,i),this.index=i,this.model=s,this.rhs=e,this.isUpperBound=t,this.terms=[],this.termsByVarIndex={},this.relaxation=null}addTerm(e,t){const i=t.index,s=this.termsByVarIndex[i];if(s===void 0){const o=new xt(t,e);this.termsByVarIndex[i]=o,this.terms.push(o);const r=this.isUpperBound===!0?-e:e;this.model.updateConstraintCoefficient(this,t,r)}else{const o=s.coefficient+e;this.setVariableCoefficient(o,t)}return this}removeTerm(e){return this}setRightHandSide(e){if(e!==this.rhs){let t=e-this.rhs;this.isUpperBound===!0&&(t=-t),this.rhs=e,this.model.updateRightHandSide(this,t)}return this}setVariableCoefficient(e,t){const i=t.index;if(i===-1){console.warn("[Constraint.setVariableCoefficient] Trying to change coefficient of inexistant variable.");return}const s=this.termsByVarIndex[i];if(s===void 0)this.addTerm(e,t);else if(e!==s.coefficient){let o=e-s.coefficient;this.isUpperBound===!0&&(o=-o),s.coefficient=e,this.model.updateConstraintCoefficient(this,t,o)}return this}relax(e,t){this.relaxation=Tt(this.model,e,t),this._relax(this.relaxation)}_relax(e){e!==null&&(this.isUpperBound?this.setVariableCoefficient(-1,e):this.setVariableCoefficient(1,e))}}class Ke{constructor(e,t){this.isEquality=!0,this.upperBound=e,this.lowerBound=t,this.model=e.model,this.rhs=e.rhs,this.relaxation=null}addTerm(e,t){return this.upperBound.addTerm(e,t),this.lowerBound.addTerm(e,t),this}removeTerm(e){return this.upperBound.removeTerm(e),this.lowerBound.removeTerm(e),this}setRightHandSide(e){this.upperBound.setRightHandSide(e),this.lowerBound.setRightHandSide(e),this.rhs=e}relax(e,t){this.relaxation=Tt(this.model,e,t),this.upperBound.relaxation=this.relaxation,this.upperBound._relax(this.relaxation),this.lowerBound.relaxation=this.relaxation,this.lowerBound._relax(this.relaxation)}}class sn{constructor(e){this.value=e}}function on(n){const e=n.length,t=this.height,i=t+e,s=this.width,o=s-1,r=this.matrix,a=i*s;if(r.length<a){const d=Math.ceil(a*1.5),p=new Float64Array(d);p.set(r),this.matrix=p}const c=this.matrix;this.height=i,this.nVars=this.width+this.height-2;const l=this.rhsColumn,f=this.rowByVarIndex,b=this.colByVarIndex,u=this.varIndexByRow,h=this.variablesPerIndex;for(let d=0;d<e;d+=1){const p=n[d],g=t+d,m=g*s,w=p.type==="min"?-1:1,v=p.varIndex;let I=f[v];if(I===-1){c[m+l]=w*p.value;for(let C=1;C<=o;C+=1)c[m+C]=0;c[m+b[v]]=w}else{const C=I*s,_=c[C+l];c[m+l]=w*(p.value-_);for(let O=1;O<=o;O+=1)c[m+O]=-w*c[C+O]}I=this.getNewElementIndex(),u[g]=I,f[I]=g,b[I]=-1,h[I]=new Re("s"+I,I),this.nVars+=1}}function rn(n){if(n===this.costRowIndex)return!1;const e=this.width,t=this.matrix,i=n*e,s=this.variablesPerIndex[this.varIndexByRow[n]];if(s===void 0||!s.isInteger)return!1;const o=t[i+this.rhsColumn],r=o-Math.floor(o);if(r<this.precision||r>1-this.precision)return!1;const a=this.height,c=a*e,l=(a+1)*e;if(t.length<l){const m=Math.ceil(l*1.5),w=new Float64Array(m);w.set(t),this.matrix=w}const f=this.matrix;this.height+=1,this.nVars+=1;const b=this.getNewElementIndex();this.varIndexByRow[a]=b,this.rowByVarIndex[b]=a,this.colByVarIndex[b]=-1,this.variablesPerIndex[b]=new Re("s"+b,b);const u=this.rhsColumn;f[c+u]=Math.floor(o);const h=this.variablesPerIndex,d=this.varIndexByCol,p=d.length,g=1-r;for(let m=1;m<p;m+=1){const w=h[d[m]],v=f[i+m];if(w!==void 0&&w.isInteger){const I=Math.floor(v),C=I+Math.max(0,v-I-r)/g;f[c+m]=C}else f[c+m]=Math.min(0,v/g)}for(let m=0;m<e;m+=1)f[c+m]-=f[i+m];return!0}function an(n){if(n===this.costRowIndex)return!1;const e=this.width,t=this.matrix,i=n*e,s=this.variablesPerIndex[this.varIndexByRow[n]];if(s===void 0||!s.isInteger)return!1;const o=t[i+this.rhsColumn],r=o-Math.floor(o);if(r<this.precision||r>1-this.precision)return!1;const a=this.height,c=a*e,l=(a+1)*e;if(t.length<l){const m=Math.ceil(l*1.5),w=new Float64Array(m);w.set(t),this.matrix=w}const f=this.matrix;this.height+=1,this.nVars+=1;const b=this.getNewElementIndex();this.varIndexByRow[a]=b,this.rowByVarIndex[b]=a,this.colByVarIndex[b]=-1,this.variablesPerIndex[b]=new Re("s"+b,b);const u=this.rhsColumn;f[c+u]=-r;const h=this.variablesPerIndex,d=this.varIndexByCol,p=d.length,g=1-r;for(let m=1;m<p;m+=1){const w=h[d[m]],v=f[i+m],I=v-Math.floor(v);w!==void 0&&w.isInteger?f[c+m]=I<=r?-I:-(1-I)*r/I:f[c+m]=v>=0?-v:v*r/g}return!0}function cn(){const n=this.height;let e=0;const t=10;for(let i=1;i<n&&e<t;i++)this.addLowerBoundMIRCut(i)&&e++}function ln(n){const e=this.width;let t=this.rowByVarIndex[n];if(t===-1){const i=this.colByVarIndex[n];for(let s=1;s<this.height;s+=1){const o=this.matrix[s*e+i];if(o<-this.precision||this.precision<o){t=s;break}}this.pivot(t,i)}return t}function un(n){const e=this.width;let t=this.colByVarIndex[n];if(t===-1){const i=this.rowByVarIndex[n],s=i*e;for(let o=1;o<this.height;o+=1){const r=this.matrix[s+o];if(r<-this.precision||this.precision<r){t=o;break}}this.pivot(i,t)}return t}function fn(){const n=this.width,e=this.matrix,t=this.rhsColumn,i=this.variables.length,s=Math.round(1/this.precision);for(let o=0;o<i;o+=1){const r=this.variables[o],a=r.index,c=this.rowByVarIndex[a];if(c===-1)r.value=0;else{const l=e[c*n+t];r.value=Math.round((l+Number.EPSILON)*s)/s}}}function hn(n,e){const t=this.width,i=this.matrix,s=this.rhsColumn,o=this.height-1,r=this.rowByVarIndex[n.index];if(r===-1){const a=this.colByVarIndex[n.index];for(let l=0;l<=o;l+=1){const f=l*t;i[f+s]-=e*i[f+a]}const c=this.optionalObjectives.length;if(c>0)for(let l=0;l<c;l+=1){const f=this.optionalObjectives[l].reducedCosts;f[s]-=e*f[a]}}else i[r*t+s]-=e}function dn(n,e,t){if(n.index===e.index)throw new Error("[Tableau.updateConstraintCoefficient] constraint index should not be equal to variable index !");const i=this.width,s=this.matrix,r=this.putInBase(n.index)*i,a=this.colByVarIndex[e.index];if(a===-1){const l=this.rowByVarIndex[e.index]*i;for(let f=0;f<i;f+=1)s[r+f]+=t*s[l+f]}else s[r+a]-=t}function pn(n,e){const t=this.width,i=this.matrix,s=n.index,o=t-1,r=this.colByVarIndex[s];if(r===-1){const a=this.rowByVarIndex[s]*t;if(n.priority===0)for(let c=0;c<=o;c+=1)i[c]+=e*i[a+c];else{const c=this.objectivesByPriority[n.priority].reducedCosts;for(let l=0;l<=o;l+=1)c[l]+=e*i[a+l]}}else i[r]-=e}function mn(n){const e=n.isUpperBound?1:-1,t=this.height,i=this.width,s=i-1,r=(t+1)*i;if(this.matrix.length<r){const u=this.matrix.length,h=Math.max(i*16,Math.floor(u*.5)),d=u+h,p=this.matrix,g=new Float64Array(d);g.set(p),this.matrix=g}const a=this.matrix,c=t*i;for(let u=0;u<=s;u+=1)a[c+u]=0;a[c+this.rhsColumn]=e*n.rhs;const l=n.terms,f=l.length;for(let u=0;u<f;u+=1){const h=l[u],d=h.coefficient,p=h.variable.index,g=this.rowByVarIndex[p];if(g===-1)a[c+this.colByVarIndex[p]]+=e*d;else{const m=g*i;for(let w=0;w<=s;w+=1)a[c+w]-=e*d*a[m+w]}}const b=n.index;this.varIndexByRow[t]=b,this.rowByVarIndex[b]=t,this.colByVarIndex[b]=-1,this.height+=1}function gn(n){const e=n.index,t=this.height-1,i=this.width,s=this.matrix,o=this.putInBase(e),r=o*i,a=t*i;for(let c=0;c<i;c++){const l=s[a+c];s[a+c]=s[r+c],s[r+c]=l}this.varIndexByRow[o]=this.varIndexByRow[t],this.varIndexByRow[t]=-1,this.rowByVarIndex[e]=-1,this.availableIndexes[this.availableIndexes.length]=e,n.slack.index=-1,this.height-=1}function bn(n){this.height-1;const e=this.width,t=e+1,i=this.height,s=this.model.isMinimization===!0?-n.cost:n.cost,o=n.priority,r=this.matrix,a=new Float64Array(i*t);for(let f=0;f<i;f++){const b=f*e,u=f*t;for(let h=0;h<e;h++)a[u+h]=r[b+h]}this.matrix=a,this.width=t;const c=t-1,l=this.optionalObjectives.length;if(l>0)for(let f=0;f<l;f+=1)this.optionalObjectives[f].reducedCosts[c]=0;o===0?a[c]=s:(this.setOptionalObjective(o,c,s),a[c]=0),this.colByVarIndex[n.index]=c,this.varIndexByCol[c]=n.index}function yn(n){const e=n.index,t=this.width,i=this.matrix,s=t-1,o=this.takeOutOfBase(e),r=this.height-1;for(let a=0;a<=r;a+=1){const c=a*t;i[c+o]=i[c+s]}this.varIndexByCol[o]=this.varIndexByCol[s],this.rowByVarIndex[e]=-1,this.colByVarIndex[e]=-1,this.availableIndexes[this.availableIndexes.length]=e,this.width-=1}function wn(){const n=new this.constructor(this.precision,this.branchAndCutService);n.width=this.width,n.height=this.height,n.nVars=this.nVars,n.model=this.model,n.variables=this.variables,n.variablesPerIndex=this.variablesPerIndex,n.unrestrictedVars=this.unrestrictedVars,n.lastElementIndex=this.lastElementIndex,n.varIndexByRow=this.varIndexByRow.slice(),n.varIndexByCol=this.varIndexByCol.slice(),n.rowByVarIndex=this.rowByVarIndex.slice(),n.colByVarIndex=this.colByVarIndex.slice(),n.availableIndexes=this.availableIndexes.slice();const e=[];for(let t=0;t<this.optionalObjectives.length;t++)e[t]=this.optionalObjectives[t].copy();return n.optionalObjectives=e,n.objectivesByPriority={...this.objectivesByPriority},n.optionalObjectivePerPriority={...this.optionalObjectivePerPriority},n.matrix=new Float64Array(this.matrix),n}function vn(){this.savedState=this.copy()}function In(){if(this.savedState===null)return;const n=this.savedState;this.nVars=n.nVars,this.model=n.model,this.variables=n.variables,this.variablesPerIndex=n.variablesPerIndex,this.unrestrictedVars=n.unrestrictedVars,this.lastElementIndex=n.lastElementIndex,this.width=n.width,this.height=n.height,this.matrix.set(n.matrix);const e=n.varIndexByRow,t=this.height;for(let a=0;a<t;a+=1)this.varIndexByRow[a]=e[a];this.varIndexByRow.length=t;const i=n.varIndexByCol,s=this.width;for(let a=0;a<s;a+=1)this.varIndexByCol[a]=i[a];this.varIndexByCol.length=s;const o=n.rowByVarIndex,r=n.colByVarIndex;for(let a=0;a<this.nVars;a+=1)this.rowByVarIndex[a]=o[a],this.colByVarIndex[a]=r[a];if(n.optionalObjectives.length>0&&this.optionalObjectives.length>0){this.optionalObjectives=[],this.optionalObjectivePerPriority={};for(let a=0;a<n.optionalObjectives.length;a++){const c=n.optionalObjectives[a].copy();this.optionalObjectives[a]=c,this.optionalObjectivePerPriority[c.priority]=c,this.objectivesByPriority[c.priority]=c}}}function xn(){let n=0;const e=this.width,t=this.matrix,i=this.rhsColumn;for(let s=1;s<this.height;s+=1){const o=this.variablesPerIndex[this.varIndexByRow[s]];if(o!==void 0&&o.isInteger){const r=t[s*e+i],a=r-Math.floor(r);a<this.precision&&-a<this.precision&&(n+=1)}}return n}function Tn(){const n=this.width,e=this.matrix,t=this.rhsColumn,i=this.model.integerVariables,s=i.length,o=this.rowByVarIndex,r=this.precision;for(let a=0;a<s;a++){const c=i[a].index,l=o[c];if(l!==-1){const f=e[l*n+t];if(Math.abs(f-Math.round(f))>r)return!1}}return!0}function Cn(n){let e=-1;const t=this.width,i=this.matrix,s=this.rhsColumn,o=this.height,r=this.variablesPerIndex,a=this.varIndexByRow,c=this.precision;for(let l=1;l<o;l+=1){const f=r[a[l]];if(f!==void 0&&f.isInteger){const b=i[l*t+s],u=Math.abs(b);if(Math.min(u-Math.floor(u),Math.floor(u+1))<c){if(n!==!0)return 0}else e===-1?e=u:e*=u}}return e===-1?0:e}function Nn(){let n=0,e=null,t=0;const i=this.width,s=this.matrix,o=this.rhsColumn,r=this.model.integerVariables,a=r.length,c=this.rowByVarIndex;for(let l=0;l<a;l+=1){const f=r[l].index,b=c[f];if(b!==-1){const u=s[b*i+o],h=Math.abs(u-Math.round(u));h>n&&(n=h,e=f,t=u)}}return{index:e,value:t}}function On(){let n=1/0,e=null,t=null;const i=this.width,s=this.matrix,o=this.rhsColumn,r=this.model.integerVariables,a=r.length;for(let c=0;c<a;c+=1){const l=r[c],f=l.index,b=this.rowByVarIndex[f];if(b!==-1){const u=s[b*i+o];Math.abs(u-Math.round(u))>this.precision&&l.cost<n&&(n=l.cost,e=f,t=u)}}return{index:e,value:t}}function En(n,e){if(!e)return this;console.log("****",n,"****"),console.log("Nb Variables",this.width-1),console.log("Nb Constraints",this.height-1),console.log("Basic Indexes",this.varIndexByRow),console.log("Non Basic Indexes",this.varIndexByCol),console.log("Rows",this.rowByVarIndex),console.log("Cols",this.colByVarIndex);const t=5,i=this.matrix,s=this.width;let o="";const r=[" "];let a,c,l,f,b,u,h;for(c=1;c<this.width;c+=1){l=this.varIndexByCol[c];const w=this.variablesPerIndex[l];w===void 0?f="c"+l:f=w.id,b=f.length,u=" ",h="	",b>5?u+=" ":h+="	",r[c]=u,o+=h+f}console.log(o);let d;const p=this.costRowIndex*s;let g="	";for(a=1;a<this.width;a+=1)d="	",g+=d,g+=r[a],g+=i[p+a].toFixed(t);d="	",g+=d+r[0]+i[p].toFixed(t),console.log(g+"	Z");for(let w=1;w<this.height;w+=1){const v=w*s;let I="	";for(c=1;c<this.width;c+=1)d="	",I+=d+r[c]+i[v+c].toFixed(t);d="	",I+=d+r[0]+i[v].toFixed(t),l=this.varIndexByRow[w];const C=this.variablesPerIndex[l];C===void 0?f="c"+l:f=C.id,console.log(I+"	"+f)}console.log("");const m=this.optionalObjectives.length;if(m>0){console.log("    Optional objectives:");for(let w=0;w<m;w+=1){const v=this.optionalObjectives[w].reducedCosts;let I="";for(a=1;a<this.width;a+=1)d=v[a]<0?"":" ",I+=d,I+=r[a],I+=v[a].toFixed(t);d=v[0]<0?"":" ",I+=d+r[0]+v[0].toFixed(t),console.log(I+" z"+w)}}return console.log("Feasible?",this.feasible),console.log("evaluation",this.evaluation),this}function Ct(n,e,t){return{priority:n,reducedCosts:t?t.slice():new Array(e).fill(0),copy(){return Ct(this.priority,this.reducedCosts.length,this.reducedCosts)}}}class Nt{constructor(e=1e-8,t){this.model=null,this.matrix=new Float64Array(0),this.width=0,this.height=0,this.costRowIndex=0,this.rhsColumn=0,this.variablesPerIndex=[],this.unrestrictedVars={},this.feasible=!0,this.evaluation=0,this.simplexIters=0,this.varIndexByRow=[],this.varIndexByCol=[],this.rowByVarIndex=[],this.colByVarIndex=[],this.optionalObjectives=[],this.objectivesByPriority={},this.optionalObjectivePerPriority={},this.savedState=null,this.availableIndexes=[],this.lastElementIndex=0,this.variables=[],this.nVars=0,this.bounded=!0,this.unboundedVarIndex=null,this.branchAndCutIterations=0,this.bestPossibleEval=0,this.pricingBatchStart=1,this.pricingBatchSize=0,this.precision=e,this.branchAndCutService=t??Le()}simplex(){return Xt.call(this),this}phase1(){return Zt.call(this)}phase2(){return Qt.call(this)}dualSimplex(){return Jt.call(this)}pivot(e,t){en.call(this,e,t)}checkForCycles(e){return tn.call(this,e)}countIntegerValues(){return xn.call(this)}isIntegral(){return Tn.call(this)}computeFractionalVolume(e){return Cn.call(this,e)}addCutConstraints(e){on.call(this,e)}applyMIRCuts(){cn.call(this)}addLowerBoundMIRCut(e){return rn.call(this,e)}addUpperBoundMIRCut(e){return an.call(this,e)}getMostFractionalVar(){return Nn.call(this)}getFractionalVarWithLowestCost(){return On.call(this)}putInBase(e){return ln.call(this,e)}takeOutOfBase(e){return un.call(this,e)}updateVariableValues(){fn.call(this)}updateRightHandSide(e,t){hn.call(this,e,t)}updateConstraintCoefficient(e,t,i){dn.call(this,e,t,i)}updateCost(e,t){pn.call(this,e,t)}addConstraint(e){mn.call(this,e)}removeConstraint(e){gn.call(this,e)}addVariable(e){bn.call(this,e)}removeVariable(e){yn.call(this,e)}copy(){return wn.call(this)}save(){vn.call(this)}restore(){In.call(this)}log(e){return En.call(this,e),this}applyCuts(e){this.branchAndCutService.applyCuts(this,e)}branchAndCut(){this.branchAndCutService.branchAndCut(this)}solve(){var e,t;return((t=(e=this.model)===null||e===void 0?void 0:e.getNumberOfIntegerVariables())!==null&&t!==void 0?t:0)>0?this.branchAndCut():this.simplex(),this.updateVariableValues(),this.getSolution()}getSolution(){var e,t,i;const s=((e=this.model)===null||e===void 0?void 0:e.isMinimization)===!0?this.evaluation:-this.evaluation;return((i=(t=this.model)===null||t===void 0?void 0:t.getNumberOfIntegerVariables())!==null&&i!==void 0?i:0)>0?new Kt(this,s,this.feasible,this.bounded,this.branchAndCutIterations):new vt(this,s,this.feasible,this.bounded)}setOptionalObjective(e,t,i){let s=this.objectivesByPriority[e];if(s===void 0){const o=Math.max(this.width,t+1);s=Ct(e,o),this.objectivesByPriority[e]=s,this.optionalObjectivePerPriority[e]=s,this.optionalObjectives.push(s),this.optionalObjectives.sort((r,a)=>r.priority-a.priority)}s.reducedCosts[t]=i}initialize(e,t,i,s){this.variables=i,this.unrestrictedVars=s,this.width=e,this.height=t,this.matrix=new Float64Array(e*t),this.varIndexByRow=new Array(this.height),this.varIndexByCol=new Array(this.width),this.varIndexByRow[0]=-1,this.varIndexByCol[0]=-1,this.nVars=e+t-2,this.rowByVarIndex=new Array(this.nVars),this.colByVarIndex=new Array(this.nVars),this.lastElementIndex=this.nVars}_resetMatrix(){if(this.model===null)throw new Error("[Tableau._resetMatrix] Model not set");const e=this.matrix,t=this.width,i=this.model.variables,s=this.model.constraints,o=i.length,r=s.length,a=this.model.isMinimization===!0?-1:1;for(let l=0;l<o;l+=1){const f=i[l],b=f.priority,u=a*f.cost;b===0?e[l+1]=u:this.setOptionalObjective(b,l+1,u);const h=i[l].index;this.rowByVarIndex[h]=-1,this.colByVarIndex[h]=l+1,this.varIndexByCol[l+1]=h}let c=1;for(let l=0;l<r;l+=1){const f=s[l],b=f.index;this.rowByVarIndex[b]=c,this.colByVarIndex[b]=-1,this.varIndexByRow[c]=b;const u=f.terms,h=u.length,d=c*t;if(c++,f.isUpperBound){for(let p=0;p<h;p+=1){const g=u[p],m=this.colByVarIndex[g.variable.index];e[d+m]=g.coefficient}e[d]=f.rhs}else{for(let p=0;p<h;p+=1){const g=u[p],m=this.colByVarIndex[g.variable.index];e[d+m]=-g.coefficient}e[d]=-f.rhs}}}setModel(e){this.model=e;const t=e.nVariables+1,i=e.nConstraints+1;return this.initialize(t,i,e.variables,e.unrestrictedVariables),this._resetMatrix(),this}getNewElementIndex(){if(this.availableIndexes.length>0)return this.availableIndexes.pop();const e=this.lastElementIndex;return this.lastElementIndex+=1,e}density(){let e=0;const t=this.matrix,i=this.width;for(let s=0;s<this.height;s++){const o=s*i;for(let r=0;r<i;r++)t[o+r]!==0&&(e+=1)}return e/(this.height*this.width)}setEvaluation(){const e=Math.round(1/this.precision),t=this.matrix[this.costRowIndex*this.width+this.rhsColumn],i=Math.round((Number.EPSILON+t)*e)/e;this.evaluation=i,this.simplexIters===0&&(this.bestPossibleEval=i)}}function _n(n,e){var t,i,s,o,r,a,c;let l=!1;for(const f of n.constraints){if(e.removedConstraints.has(f)||!f.isUpperBound)continue;let b=0;for(const h of f.terms)if(e.fixedVariables.has(h.variable))b+=h.coefficient*e.fixedVariables.get(h.variable);else{const d=(t=e.tightenedBounds.get(h.variable))!==null&&t!==void 0?t:{},p=(i=d.lower)!==null&&i!==void 0?i:0;if(h.coefficient>0)b+=h.coefficient*p;else{const g=(s=d.upper)!==null&&s!==void 0?s:1/0;b+=h.coefficient*g}}const u=f.rhs-b;if(!(u<0))for(const h of f.terms){if(e.fixedVariables.has(h.variable)||!h.variable.isInteger||h.coefficient<=0)continue;const d=(o=e.tightenedBounds.get(h.variable))!==null&&o!==void 0?o:{},p=(r=d.lower)!==null&&r!==void 0?r:0,g=(a=d.upper)!==null&&a!==void 0?a:1;if(p>=-.5&&g<=1.5&&h.coefficient*(g-p)>u+1e-6){const w=p+u/h.coefficient;if(w<g-1e-6){const v=(c=e.tightenedBounds.get(h.variable))!==null&&c!==void 0?c:{};(!v.upper||w<v.upper)&&(e.tightenedBounds.set(h.variable,{...v,upper:w}),e.stats.boundsTightened++,l=!0)}}}}return l}function An(n,e){var t,i,s;let o=!1;for(const r of n.constraints){if(e.removedConstraints.has(r))continue;let a=0,c=0;for(const l of r.terms){const f=e.fixedVariables.get(l.variable);if(f!==void 0){a+=l.coefficient*f,c+=l.coefficient*f;continue}const b=(t=e.tightenedBounds.get(l.variable))!==null&&t!==void 0?t:{},u=(i=b.lower)!==null&&i!==void 0?i:0,h=(s=b.upper)!==null&&s!==void 0?s:1/0;l.coefficient>0?(a+=l.coefficient*u,c+=l.coefficient*(h===1/0?1e10:h)):(a+=l.coefficient*(h===1/0?1e10:h),c+=l.coefficient*u)}if(r.isUpperBound){if(c<=r.rhs+1e-6&&(e.removedConstraints.add(r),e.stats.constraintsRemoved++,o=!0),a>r.rhs+1e-6)return e.isInfeasible=!0,!1}else if(a>=r.rhs-1e-6&&(e.removedConstraints.add(r),e.stats.constraintsRemoved++,o=!0),c<r.rhs-1e-6)return e.isInfeasible=!0,!1}return o}function Sn(n){var e,t;const i={fixedVariables:new Map,removedConstraints:new Set,tightenedBounds:new Map,isInfeasible:!1,stats:{variablesFixed:0,constraintsRemoved:0,boundsTightened:0}};let s=!0,o=0;const r=5;for(;s&&o<r;){s=!1,o++;for(const a of n.constraints){if(i.removedConstraints.has(a))continue;const c=a.terms.filter(l=>!i.fixedVariables.has(l.variable));if(c.length===0){let l=0;for(const b of a.terms){const u=i.fixedVariables.get(b.variable);u!==void 0&&(l+=b.coefficient*u)}if(!(a.isUpperBound?l<=a.rhs+1e-6:l>=a.rhs-1e-6))return i.isInfeasible=!0,i;i.removedConstraints.add(a),i.stats.constraintsRemoved++,s=!0}else if(c.length===1){const l=c[0],f=l.variable,b=l.coefficient;let u=a.rhs;for(const d of a.terms)if(d.variable!==f){const p=i.fixedVariables.get(d.variable);p!==void 0&&(u-=d.coefficient*p)}const h=u/b;if(a.isUpperBound)if(b>0){const d=i.tightenedBounds.get(f);(!d?.upper||h<d.upper)&&(i.tightenedBounds.set(f,{...d,upper:h}),i.stats.boundsTightened++,s=!0)}else{const d=i.tightenedBounds.get(f);(!d?.lower||h>d.lower)&&(i.tightenedBounds.set(f,{...d,lower:h}),i.stats.boundsTightened++,s=!0)}i.removedConstraints.add(a),i.stats.constraintsRemoved++}}for(const[a,c]of i.tightenedBounds)if(!i.fixedVariables.has(a)){if(c.lower!==void 0&&c.upper!==void 0){if(c.lower>c.upper+1e-6)return i.isInfeasible=!0,i;if(Math.abs(c.lower-c.upper)<1e-6){let l=c.lower;a.isInteger&&(l=Math.round(l)),i.fixedVariables.set(a,l),i.stats.variablesFixed++,s=!0}}a.isInteger&&c.lower!==void 0&&c.lower>=.5&&((e=c.upper)!==null&&e!==void 0?e:1/0)<=1.5&&(i.fixedVariables.set(a,1),i.stats.variablesFixed++,s=!0),a.isInteger&&c.upper!==void 0&&c.upper<=.5&&((t=c.lower)!==null&&t!==void 0?t:0)>=-.5&&(i.fixedVariables.set(a,0),i.stats.variablesFixed++,s=!0)}if(An(n,i)&&(s=!0),i.isInfeasible)return i;_n(n,i)&&(s=!0)}return i}class Ve{constructor(e,t,i){this.tableau=new Nt(e,i),this.name=t,this.variables=[],this.integerVariables=[],this.unrestrictedVariables={},this.constraints=[],this.nConstraints=0,this.nVariables=0,this.isMinimization=!0,this.tableauInitialized=!1,this.relaxationIndex=1,this.useMIRCuts=!1,this.checkForCycles=!0,this.messages=[],this.availableIndexes=[],this.lastElementIndex=0,this.usePresolve=!0,this.presolveResult=null}minimize(){return this.isMinimization=!0,this}maximize(){return this.isMinimization=!1,this}_getNewElementIndex(){if(this.availableIndexes.length>0)return this.availableIndexes.pop();const e=this.lastElementIndex;return this.lastElementIndex+=1,e}_addConstraint(e){const t=e.slack;this.tableau.variablesPerIndex[t.index]=t,this.constraints.push(e),this.nConstraints+=1,this.tableauInitialized===!0&&this.tableau.addConstraint(e)}smallerThan(e){const t=new le(e,!0,this.tableau.getNewElementIndex(),this);return this._addConstraint(t),t}greaterThan(e){const t=new le(e,!1,this.tableau.getNewElementIndex(),this);return this._addConstraint(t),t}equal(e){const t=new le(e,!0,this.tableau.getNewElementIndex(),this);this._addConstraint(t);const i=new le(e,!1,this.tableau.getNewElementIndex(),this);return this._addConstraint(i),new Ke(t,i)}addVariable(e,t,i,s,o){if(typeof o=="string")switch(o){case"required":o=0;break;case"strong":o=1;break;case"medium":o=2;break;case"weak":o=3;break;default:o=0;break}const r=this.tableau.getNewElementIndex(),a=t??"v"+r,c=e??0,l=o??0;let f;if(i){const b=new nn(a,c,r,l);this.integerVariables.push(b),f=b}else f=new Se(a,c,r,l);return this.variables.push(f),this.tableau.variablesPerIndex[r]=f,s&&(this.unrestrictedVariables[r]=!0),this.nVariables+=1,this.tableauInitialized===!0&&this.tableau.addVariable(f),f}_removeConstraint(e){const t=this.constraints.indexOf(e);if(t===-1){console.warn("[Model.removeConstraint] Constraint not present in model");return}this.constraints.splice(t,1),this.nConstraints-=1,this.tableauInitialized===!0&&this.tableau.removeConstraint(e),e.relaxation&&this.removeVariable(e.relaxation)}removeConstraint(e){if(e.isEquality){const t=e;this._removeConstraint(t.upperBound),this._removeConstraint(t.lowerBound)}else this._removeConstraint(e);return this}removeVariable(e){const t=this.variables.indexOf(e);if(t===-1){console.warn("[Model.removeVariable] Variable not present in model");return}return this.variables.splice(t,1),this.tableauInitialized===!0&&this.tableau.removeVariable(e),this}updateRightHandSide(e,t){return this.tableauInitialized===!0&&this.tableau.updateRightHandSide(e,t),this}updateConstraintCoefficient(e,t,i){return this.tableauInitialized===!0&&this.tableau.updateConstraintCoefficient(e,t,i),this}setCost(e,t){let i=e-t.cost;return this.isMinimization===!1&&(i=-i),t.cost=e,this.tableau.updateCost(t,i),this}loadJson(e){this.isMinimization=e.opType!=="max";const t=e.variables,i=e.constraints,s={},o={},r=Object.keys(i),a=r.length;for(let g=0;g<a;g+=1){const m=r[g],w=i[m],v=w.equal,I=w.weight,C=w.priority,_=I!==void 0||C!==void 0;let O,E;if(v===void 0){const R=w.min;R!==void 0&&(O=this.greaterThan(R),s[m]=O,_&&O.relax(I,C));const T=w.max;T!==void 0&&(E=this.smallerThan(T),o[m]=E,_&&E.relax(I,C))}else{O=this.greaterThan(v),s[m]=O,E=this.smallerThan(v),o[m]=E;const R=new Ke(O,E);_&&R.relax(I,C)}}const c=Object.keys(t),l=c.length;this.tolerance=e.tolerance||0,e.timeout&&(this.timeout=e.timeout),e.options&&(e.options.timeout&&(this.timeout=e.options.timeout),this.tolerance===0&&(this.tolerance=e.options.tolerance||0),e.options.useMIRCuts&&(this.useMIRCuts=e.options.useMIRCuts),typeof e.options.exitOnCycles>"u"?this.checkForCycles=!0:this.checkForCycles=e.options.exitOnCycles,e.options.keep_solutions?this.keep_solutions=e.options.keep_solutions:this.keep_solutions=!1,e.options.presolve!==void 0&&(this.usePresolve=e.options.presolve));const f=e.ints||{},b=e.binaries||{},u=e.unrestricted||{},h=e.optimize,p=!c.some(g=>h in t[g])&&c.includes(h);for(let g=0;g<l;g+=1){const m=c[g],w=t[m],v=p?m===h?1:0:w[h]||0,I=!!b[m],C=!!f[m]||I,_=!!u[m],O=this.addVariable(v,m,C,_);I&&this.smallerThan(1).addTerm(1,O);const E=Object.keys(w);for(let R=0;R<E.length;R+=1){const T=E[R];if(T===h)continue;const x=w[T],A=s[T];A!==void 0&&A.addTerm(x,O);const M=o[T];M!==void 0&&M.addTerm(x,O)}}return this}getNumberOfIntegerVariables(){return this.integerVariables.length}solve(){if(this.usePresolve&&this.presolveResult===null){if(this.presolveResult=Sn(this),this.presolveResult.isInfeasible)return this.tableau.feasible=!1,this.tableau.getSolution();this.applyPresolveReductions(this.presolveResult)}return this.tableauInitialized===!1&&(this.tableau.setModel(this),this.tableauInitialized=!0),this.tableau.solve()}applyPresolveReductions(e){for(const[t,i]of e.fixedVariables)t.value=i,t.cost=0}isFeasible(){return this.tableau.feasible}save(){this.tableau.save()}restore(){this.tableau.restore()}activateMIRCuts(e){this.useMIRCuts=e}debug(e){this.checkForCycles=e}log(e){return this.tableau.log(e)}}const Pe={optype:"opType",OpType:"opType",op_type:"opType",type:"opType",optimise:"optimize",Optimize:"optimize",objective:"optimize",constraint:"constraints",Constraints:"constraints",variable:"variables",Variables:"variables",vars:"variables",int:"ints",integers:"ints",Ints:"ints",binary:"binaries",Binaries:"binaries"},Rn={minimum:"min",maximum:"max",Min:"min",Max:"max",eq:"equal",equals:"equal",Equal:"equal"};function Bn(n){const e=Object.keys(n);for(const t of e){const i=Pe[t];i&&console.warn(`[jsLPSolver] Warning: Model has '${t}' but expected '${i}'. This may cause unexpected behavior.`)}if(!n.optimize&&!e.some(t=>Pe[t]==="optimize")&&console.warn("[jsLPSolver] Warning: Model is missing 'optimize' property. The solver needs to know which attribute to optimize."),!n.opType&&!e.some(t=>Pe[t]==="opType")&&console.warn(`[jsLPSolver] Warning: Model is missing 'opType' property. Defaulting to 'max'. Use 'opType: "max"' or 'opType: "min"' to be explicit.`),n.constraints){for(const[t,i]of Object.entries(n.constraints))if(typeof i=="object"&&i!==null)for(const s of Object.keys(i)){const o=Rn[s];o&&console.warn(`[jsLPSolver] Warning: Constraint '${t}' has '${s}' but expected '${o}'.`)}}return n}function kn(n){let e,t,i;if(typeof n.optimize=="string"){if(n.constraints[n.optimize]){e=Math.random();for(t in n.variables)n.variables[t][n.optimize]&&(n.variables[t][e]=n.variables[t][n.optimize]);return n.constraints[e]=n.constraints[n.optimize],delete n.constraints[n.optimize],n}return n}else{for(i in n.optimize)if(n.constraints[i])if(n.constraints[i]==="equal")delete n.optimize[i];else{e=Math.random();for(t in n.variables)n.variables[t][i]&&(n.variables[t][e]=n.variables[t][i]);n.constraints[e]=n.constraints[i],delete n.constraints[i]}return n}}var Xe=Object.freeze({__proto__:null,CleanObjectiveAttributes:kn,WarnOnTypos:Bn});const ve={};function Vn(n){return JSON.parse(JSON.stringify(n))}function Je(n){if(n&&typeof n=="object")return n;throw new Error("Polyopt requires the solver to return an object result.")}function Pn(n,e,t){for(const i of t)if(!e.variables[i]){typeof n[i]!="number"&&(n[i]=0);for(const[s,o]of Object.entries(e.variables)){const r=o[i],a=n[s];typeof r=="number"&&typeof a=="number"&&(n[i]+=a*r)}}}function Mn(n,e){return`base-${e.map(i=>{const s=n[i];return typeof s=="number"?Math.round(s*1e3)/1e3:0}).join("-")}`}function Fn(n){var e;const t={};for(const i of n)for(const[s,o]of Object.entries(i)){if(typeof o!="number")continue;const r=(e=t[s])!==null&&e!==void 0?e:{min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};t[s]={min:Math.min(r.min,o),max:Math.max(r.max,o)}}for(const i of n)for(const s of Object.keys(t))typeof i[s]!="number"&&(i[s]=0),t[s].min=Math.min(t[s].min,i[s]),t[s].max=Math.max(t[s].max,i[s]);for(const[i,s]of Object.entries(t))Number.isFinite(s.min)||(t[i]={min:0,max:0});return t}function Ze(n,e){const t=Vn(e),i=t.optimize,s=Object.keys(i);if(s.length===0)throw new Error("Multi-objective solve requires at least one objective definition.");const o=t;delete o.optimize,delete o.opType;const r={},a=new Set,c=[];for(const u of s)r[u]=0;for(const u of s){t.optimize=u,t.opType=i[u];const h=Je(n.Solve(t,void 0,void 0,!0));Pn(h,t,s);const d=Mn(h,s);if(a.has(d))continue;a.add(d);for(const v of s){const I=h[v];typeof I=="number"&&(r[v]+=I)}const{feasible:p,result:g,bounded:m,...w}=h;c.push(w)}for(const u of s)t.constraints[u]={equal:r[u]/a.size};const l=`cheater-${Math.random()}`;t.optimize=l,t.opType="max";for(const u of Object.values(t.variables))u[l]=1;const f=Fn(c);return{midpoint:Je(n.Solve(t,void 0,void 0,!0)),vertices:c,ranges:f}}function Ln(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function Dn(n){var e={is_objective:/(max|min)(imize){0,}\:/i,is_int:/^(?!\/\*)\W{0,}int/i,is_bin:/^(?!\/\*)\W{0,}bin/i,is_constraint:/(\>|\<){0,}\=/i,is_unrestricted:/^\S{0,}unrestricted/i,parse_lhs:/(\-|\+){0,1}\s{0,1}\d{0,}\.{0,}\d{0,}\s{0,}[A-Za-z]\S{0,}/gi,parse_rhs:/(\-|\+){0,1}\d{1,}\.{0,}\d{0,}\W{0,}\;{0,1}$/i,parse_dir:/(\>|\<){0,}\=/gi,parse_int:/[^\s|^\,]+/gi,parse_bin:/[^\s|^\,]+/gi,get_num:/(\-|\+){0,1}(\W|^)\d+\.{0,1}\d{0,}/g,get_word:/[A-Za-z].*/},t={opType:"",optimize:"_obj",constraints:{},variables:{}},i={">=":"min","<=":"max","=":"equal"},s="",o=null,r="",a="",c="",l=0;typeof n=="string"&&(n=n.split(`
`));for(var f=0;f<n.length;f++)if(c="__"+f,s=n[f],o=null,e.is_objective.test(s))t.opType=s.match(/(max|min)/gi)[0],o=s.match(e.parse_lhs).map(function(h){return h.replace(/\s+/,"")}).slice(1),o.forEach(function(h){r=h.match(e.get_num),r===null?h.substr(0,1)==="-"?r=-1:r=1:r=r[0],r=parseFloat(r),a=h.match(e.get_word)[0].replace(/\;$/,""),t.variables[a]=t.variables[a]||{},t.variables[a]._obj=r});else if(e.is_int.test(s))o=s.match(e.parse_int).slice(1),t.ints=t.ints||{},o.forEach(function(h){h=h.replace(";",""),t.ints[h]=1});else if(e.is_bin.test(s))o=s.match(e.parse_bin).slice(1),t.binaries=t.binaries||{},o.forEach(function(h){h=h.replace(";",""),t.binaries[h]=1});else if(e.is_constraint.test(s)){var b=s.indexOf(":"),u=b===-1?s:s.slice(b+1);o=u.match(e.parse_lhs).map(function(h){return h.replace(/\s+/,"")}),o.forEach(function(h){r=h.match(e.get_num),r===null?h.substr(0,1)==="-"?r=-1:r=1:r=r[0],r=parseFloat(r),a=h.match(e.get_word)[0],t.variables[a]=t.variables[a]||{},t.variables[a][c]=r}),l=parseFloat(s.match(e.parse_rhs)[0]),s=i[s.match(e.parse_dir)[0]],t.constraints[c]=t.constraints[c]||{},t.constraints[c][s]=l}else e.is_unrestricted.test(s)&&(o=s.match(e.parse_int).slice(1),t.unrestricted=t.unrestricted||{},o.forEach(function(h){h=h.replace(";",""),t.unrestricted[h]=1}));return t}function $n(n){if(!n)throw new Error("Solver requires a model to operate on");var e="",t={max:"<=",min:">=",equal:"="},i=new RegExp("[^A-Za-z0-9_[{}/.&#$%~'@^]","gi");if(n.opType){e+=n.opType+":";for(var s in n.variables)n.variables[s][s]=n.variables[s][s]?n.variables[s][s]:1,n.variables[s][n.optimize]&&(e+=" "+n.variables[s][n.optimize]+" "+s.replace(i,"_"))}else e+="max:";e+=`;

`;for(var o in n.constraints)for(var r in n.constraints[o])if(typeof t[r]<"u"){for(var a in n.variables)typeof n.variables[a][o]<"u"&&(e+=" "+n.variables[a][o]+" "+a.replace(i,"_"));e+=" "+t[r]+" "+n.constraints[o][r],e+=`;
`}if(n.ints){e+=`

`;for(var c in n.ints)e+="int "+c.replace(i,"_")+`;
`}if(n.unrestricted){e+=`

`;for(var l in n.unrestricted)e+="unrestricted "+l.replace(i,"_")+`;
`}return e}var Un=function(n){return n.length?Dn(n):$n(n)},jn=Ln(Un);function Qe(n,e,t){return{type:n,varIndex:e,value:t}}function ae(n,e,t,i,s,o,r){return{relaxedEvaluation:n,cuts:e,depth:t,branchVarIndex:i,branchDirection:s,branchFractionality:o,parentEvaluation:r}}function Gn(n={}){const{nodeSelection:e="hybrid",branching:t="pseudocost",useDiving:i=!0,strongBranchingCandidates:s=5}=n,o=new Map,r=u=>{let h=o.get(u);return h||(h={upSum:0,upCount:0,downSum:0,downCount:0},o.set(u,h)),h},a=(u,h,d,p)=>{const g=r(u),m=d/(h==="up"?1-p:p);h==="up"?(g.upSum+=m,g.upCount++):(g.downSum+=m,g.downCount++)},c=(u,h)=>{const d=r(u),p=d.upCount>0?d.upSum/d.upCount:1,g=d.downCount>0?d.downSum/d.downCount:1,m=p*(1-h),w=g*h;return Math.max(m,1e-6)*Math.max(w,1e-6)},l=(u,h)=>{const d=u.width,p=u.matrix,g=u.rhsColumn,m=u.model.integerVariables,w=u.precision;let v=[];for(const I of m){const C=I.index,_=u.rowByVarIndex[C];if(_!==-1){const O=p[_*d+g],E=Math.abs(O-Math.round(O));E>w&&v.push({index:C,value:O,fraction:E})}}if(v.length===0)return null;if(t==="most-fractional")return v.sort((I,C)=>C.fraction-I.fraction),{index:v[0].index,value:v[0].value};if(t==="pseudocost"){let I=-1/0,C=v[0];for(const _ of v){const O=c(_.index,_.fraction);O>I&&(I=O,C=_)}return{index:C.index,value:C.value}}if(t==="strong"){v.sort((_,O)=>O.fraction-_.fraction),v=v.slice(0,s);let I=-1/0,C=v[0];for(const _ of v){const O=r(_.index);if(O.upCount>=2&&O.downCount>=2){const E=c(_.index,_.fraction);E>I&&(I=E,C=_)}else{const E=_.fraction*(1-_.fraction);E>I&&(I=E,C=_)}}return{index:C.index,value:C.value}}return{index:v[0].index,value:v[0].value}},f=(u,h)=>{var d;if(u.restore(),u.addCutConstraints(h),u.simplex(),!((d=u.model)===null||d===void 0)&&d.useMIRCuts&&u.feasible){let p=!0,g=0;const m=3;for(;p&&g<m;){const w=u.computeFractionalVolume(!0);u.applyMIRCuts(),u.simplex();const v=u.computeFractionalVolume(!0);g++,v>=.9*w&&(p=!1)}}};return{applyCuts:f,branchAndCut:u=>{var h,d,p,g,m;const w=new Ye,v=[];let I=0;const C=(d=(h=u.model)===null||h===void 0?void 0:h.tolerance)!==null&&d!==void 0?d:0;let _=!0,O=1e99;!((p=u.model)===null||p===void 0)&&p.timeout&&(O=Date.now()+u.model.timeout);let E=1/0,R=null;const T=[];for(let N=0;N<u.optionalObjectives.length;N+=1)T.push(1/0);const x=1;let A=0,M=e==="depth-first"||e==="hybrid";const Y=ae(-1/0,[],0);let H;for(M?v.push(Y):w.push(Y);(M?v.length>0:!w.isEmpty())&&_===!0&&Date.now()<O;){!((g=u.model)===null||g===void 0)&&g.isMinimization?H=u.bestPossibleEval*(1+C):H=u.bestPossibleEval*(1-C),C>0&&E<H&&(_=!1);let N;if(M&&v.length>0)N=v.pop();else if(!w.isEmpty())N=w.pop();else break;if(N.relaxedEvaluation>=E)continue;const L=N.cuts;if(u.evaluation,f(u,L),I++,!u.feasible)continue;const D=u.evaluation;if(!(D>E)){if(N.branchVarIndex!==void 0&&N.branchDirection!==void 0&&N.branchFractionality!==void 0&&N.parentEvaluation!==void 0){const B=Math.abs(D-N.parentEvaluation);a(N.branchVarIndex,N.branchDirection,B,N.branchFractionality)}if(D===E){let B=!0;for(let S=0;S<u.optionalObjectives.length&&!(u.optionalObjectives[S].reducedCosts[0]>T[S]);S++)if(u.optionalObjectives[S].reducedCosts[0]<T[S]){B=!1;break}if(B)continue}if(u.isIntegral()){if(u.__isIntegral=!0,A++,I===1){u.branchAndCutIterations=I;return}R=N,E=D;for(let B=0;B<u.optionalObjectives.length;B++)T[B]=u.optionalObjectives[B].reducedCosts[0];if(!((m=u.model)===null||m===void 0)&&m.keep_solutions){const B=u.model.tableau.getSolution(),S=B.generateSolutionSet();S.result=B.evaluation,u.model.solutions||(u.model.solutions=[]),u.model.solutions.push(S)}if(e==="hybrid"&&A>=x)for(M=!1;v.length>0;)w.push(v.pop())}else{I===1&&u.save();const B=l(u);if(!B)continue;const S=B.index,$=B.value,ne=[],Q=[],se=L.length;for(let oe=0;oe<se;oe++){const q=L[oe];q.varIndex===S?q.type==="min"?Q.push(q):ne.push(q):(ne.push(q),Q.push(q))}const ie=Math.ceil($),pe=Math.floor($),me=ie-$,ge=$-pe,be=Qe("min",S,ie);ne.push(be);const ye=Qe("max",S,pe);Q.push(ye);const ee=N.depth+1;M?(v.push(ae(D,Q,ee,S,"down",ge,D)),v.push(ae(D,ne,ee,S,"up",me,D))):(w.push(ae(D,ne,ee,S,"up",me,D)),w.push(ae(D,Q,ee,S,"down",ge,D)))}}}R!==null&&f(u,R.cuts),u.branchAndCutIterations=I}}}function zn(n){return{matrix:new Float64Array(n.matrix),width:n.width,height:n.height,nVars:n.nVars,varIndexByRow:n.varIndexByRow.slice(),varIndexByCol:n.varIndexByCol.slice(),rowByVarIndex:n.rowByVarIndex.slice(),colByVarIndex:n.colByVarIndex.slice(),availableIndexes:n.availableIndexes.slice(),lastElementIndex:n.lastElementIndex,evaluation:n.evaluation,feasible:n.feasible}}function Yn(n,e){n.matrix.length>=e.matrix.length?n.matrix.set(e.matrix):n.matrix=new Float64Array(e.matrix),n.width=e.width,n.height=e.height,n.nVars=e.nVars;const t=e.height;for(let o=0;o<t;o++)n.varIndexByRow[o]=e.varIndexByRow[o];n.varIndexByRow.length=t;const i=e.width;for(let o=0;o<i;o++)n.varIndexByCol[o]=e.varIndexByCol[o];n.varIndexByCol.length=i;const s=e.nVars;for(let o=0;o<s;o++)n.rowByVarIndex[o]=e.rowByVarIndex[o],n.colByVarIndex[o]=e.colByVarIndex[o];n.availableIndexes=e.availableIndexes.slice(),n.lastElementIndex=e.lastElementIndex,n.evaluation=e.evaluation,n.feasible=e.feasible}function et(n,e,t){return{type:n,varIndex:e,value:t}}function ce(n,e,t,i,s){return{relaxedEvaluation:n,cuts:e,depth:t,parentCheckpoint:i,newCut:s}}function Hn(n={}){const{nodeSelection:e="hybrid",branching:t="pseudocost",maxCheckpoints:i=50}=n,s=new Map,o=u=>{let h=s.get(u);return h||(h={upSum:0,upCount:0,downSum:0,downCount:0},s.set(u,h)),h},r=(u,h,d,p)=>{const g=o(u),m=d/(h==="up"?1-p:p);h==="up"?(g.upSum+=m,g.upCount++):(g.downSum+=m,g.downCount++)},a=(u,h)=>{const d=o(u),p=d.upCount>0?d.upSum/d.upCount:1,g=d.downCount>0?d.downSum/d.downCount:1,m=p*(1-h),w=g*h;return Math.max(m,1e-6)*Math.max(w,1e-6)},c=u=>{const h=u.width,d=u.matrix,p=u.rhsColumn,g=u.model.integerVariables,m=u.precision,w=[];for(const C of g){const _=C.index,O=u.rowByVarIndex[_];if(O!==-1){const E=d[O*h+p],R=Math.abs(E-Math.round(E));R>m&&w.push({index:_,value:E,fraction:R})}}if(w.length===0)return null;if(t==="most-fractional")return w.sort((C,_)=>_.fraction-C.fraction),w[0];let v=-1/0,I=w[0];for(const C of w){const _=a(C.index,C.fraction);_>v&&(v=_,I=C)}return I},l=(u,h)=>{var d;if(u.restore(),u.addCutConstraints(h),u.simplex(),!((d=u.model)===null||d===void 0)&&d.useMIRCuts&&u.feasible){let p=!0,g=0;const m=3;for(;p&&g<m;){const w=u.computeFractionalVolume(!0);u.applyMIRCuts(),u.simplex();const v=u.computeFractionalVolume(!0);g++,v>=.9*w&&(p=!1)}}},f=(u,h)=>{var d;if(h.parentCheckpoint&&h.newCut?(Yn(u,h.parentCheckpoint),u.addCutConstraints([h.newCut]),u.simplex()):(u.restore(),u.addCutConstraints(h.cuts),u.simplex()),!((d=u.model)===null||d===void 0)&&d.useMIRCuts&&u.feasible){let p=!0,g=0;const m=3;for(;p&&g<m;){const w=u.computeFractionalVolume(!0);u.applyMIRCuts(),u.simplex();const v=u.computeFractionalVolume(!0);g++,v>=.9*w&&(p=!1)}}};return{applyCuts:l,branchAndCut:u=>{var h,d,p,g,m;const w=new Ye,v=[];let I=0,C=0;const _=(d=(h=u.model)===null||h===void 0?void 0:h.tolerance)!==null&&d!==void 0?d:0;let O=!0,E=1e99;!((p=u.model)===null||p===void 0)&&p.timeout&&(E=Date.now()+u.model.timeout);let R=1/0,T=null;const x=[];for(let N=0;N<u.optionalObjectives.length;N++)x.push(1/0);const A=1;let M=0,Y=e==="depth-first"||e==="hybrid";const H=ce(-1/0,[],0);for(Y?v.push(H):w.push(H);(Y?v.length>0:!w.isEmpty())&&O===!0&&Date.now()<E;){let N;!((g=u.model)===null||g===void 0)&&g.isMinimization?N=u.bestPossibleEval*(1+_):N=u.bestPossibleEval*(1-_),_>0&&R<N&&(O=!1);let L;if(Y&&v.length>0)L=v.pop();else if(!w.isEmpty())L=w.pop();else break;if(L.relaxedEvaluation>=R)continue;const D=u.evaluation;if(f(u,L),I++,!u.feasible)continue;const B=u.evaluation;if(!(B>R)){if(L.newCut&&D!==0){const S=Math.abs(B-D);r(L.newCut.varIndex,L.newCut.type==="min"?"up":"down",S,.5)}if(B===R){let S=!0;for(let $=0;$<u.optionalObjectives.length&&!(u.optionalObjectives[$].reducedCosts[0]>x[$]);$++)if(u.optionalObjectives[$].reducedCosts[0]<x[$]){S=!1;break}if(S)continue}if(u.isIntegral()){if(u.__isIntegral=!0,M++,I===1){u.branchAndCutIterations=I;return}T=L,R=B;for(let S=0;S<u.optionalObjectives.length;S++)x[S]=u.optionalObjectives[S].reducedCosts[0];if(!((m=u.model)===null||m===void 0)&&m.keep_solutions){const S=u.model.tableau.getSolution(),$=S.generateSolutionSet();$.result=S.evaluation,u.model.solutions||(u.model.solutions=[]),u.model.solutions.push($)}if(e==="hybrid"&&M>=A)for(Y=!1;v.length>0;)w.push(v.pop())}else{I===1&&u.save();const S=c(u);if(!S)continue;const $=S.index,ne=S.value;let Q;Y&&C<i&&(Q=zn(u),C++);const se=[],ie=[],pe=L.cuts.length;for(let oe=0;oe<pe;oe++){const q=L.cuts[oe];q.varIndex===$?q.type==="min"?ie.push(q):se.push(q):(se.push(q),ie.push(q))}const me=Math.ceil(ne),ge=Math.floor(ne),be=et("min",$,me);se.push(be);const ye=et("max",$,ge);ie.push(ye);const ee=L.depth+1;Y?(v.push(ce(B,ie,ee,Q,ye)),v.push(ce(B,se,ee,Q,be))):(w.push(ce(B,se,ee)),w.push(ce(B,ie,ee)))}}}T!==null&&l(u,T.cuts),u.branchAndCutIterations=I}}}class Wn{constructor(){this.Model=Ve,this.Tableau=Nt,this.Constraint=le,this.Variable=Se,this.Numeral=sn,this.Term=xt,this.External=ve,this.ReformatLP=jn,this.branchAndCutService=Le(),this.branchAndCut=e=>this.branchAndCutService.branchAndCut(e),this.lastSolvedModel=null}selectBranchAndCutService(e){var t,i,s,o;const r=e.options,a=r?.nodeSelection||r?.branching;return r?.useIncremental===!0?Hn({nodeSelection:(t=r?.nodeSelection)!==null&&t!==void 0?t:"hybrid",branching:(i=r?.branching)!==null&&i!==void 0?i:"pseudocost"}):a?Gn({nodeSelection:(s=r?.nodeSelection)!==null&&s!==void 0?s:"hybrid",branching:(o=r?.branching)!==null&&o!==void 0?o:"pseudocost",useDiving:!0}):Le()}Solve(e,t,i,s){if(s)for(const a in Xe){const c=Xe[a];typeof c=="function"&&(e=c(e))}if(!e)throw new Error("Solver requires a model to operate on");if(typeof e.optimize=="object"&&Object.keys(e.optimize).length>1)return Ze(this,e);if(e.external)return this.solveWithExternalSolver(e);let o;if(e instanceof Ve)o=e;else{const a=this.selectBranchAndCutService(e);o=new Ve(t,void 0,a).loadJson(e)}const r=o.solve();return this.lastSolvedModel=o,r.solutionSet=r.generateSolutionSet(),i?r:this.buildSimplifiedResult(r)}solveWithExternalSolver(e){var t;const i=Object.keys(ve),s=JSON.stringify(i);if(!(!((t=e.external)===null||t===void 0)&&t.solver))throw new Error(`Model has 'external' object without solver attribute. Available: ${s}`);const o=e.external.solver;if(!ve[o])throw new Error(`Solver '${o}' not supported. Available: ${s}`);return ve[o].solve(e)}buildSimplifiedResult(e){const t={feasible:e.feasible,result:e.evaluation,bounded:e.bounded};e._tableau.__isIntegral&&(t.isIntegral=!0);for(const i of Object.keys(e.solutionSet)){const s=e.solutionSet[i];s!==0&&(t[i]=s)}return t}MultiObjective(e){return Ze(this,e)}}const fe=new Wn;typeof define=="function"?define([],()=>fe):typeof window=="object"?window.solver=fe:typeof self=="object"&&(self.solver=fe);k.setLevel("warn");const qn=1,tt="p_",nt="o_";function it(n,e){const t=[];for(const i of n.playerActions){const s=[];for(const o of n.opponentActions){const r=`${i}-${o}`,a=n.rewards.get(r),c=n.children.get(r);let l=0;a?l=e?a[0]:a[1]:c&&(l=e?c.playerValue:c.opponentValue),s.push(l)}t.push(s)}return t}function st(n){let e=1/0;for(const t of n)for(const i of t)e=Math.min(e,i);return e<0?-e+qn:0}function ot(n,e,t){const i=new Map;for(const s of e){const o=`${t}${s}`,r=n[o]??0;i.set(s,r)}return i}function rt(n){const e=new Map,t=1/n.length;for(const i of n)e.set(i,t);return e}class Kn{constructor(e,t=!1){this.nodeId=e,this.isTerminal=t,this.playerActions=[],this.opponentActions=[],this.children=new Map,this.rewards=new Map,this.playerStrategy=new Map,this.opponentStrategy=new Map,this.playerValue=0,this.opponentValue=0}}class Xn{constructor(e){this.initialized=!1,this.gameTree=e,this.nodes=new Map,this.nodeMap=new Map,this.topologicalOrder=[]}buildInternalTree(){const e=this.gameTree.nodes[this.gameTree.root];return e?(this.collectAllNodes(e),this.buildLPNode(e)?(this.computeTopologicalOrder(),this.initialized=!0,!0):!1):(k.error(`Root node ${this.gameTree.root} not found in nodes map`),!1)}collectAllNodes(e){this.nodeMap.set(e.nodeId,e);for(const t of e.transitions){if(!t.nextNodeId)continue;const i=this.findNodeById(t.nextNodeId);!i||this.nodeMap.has(i.nodeId)||this.collectAllNodes(i)}}findNodeById(e){if(this.nodeMap.has(e))return this.nodeMap.get(e);const t=this.gameTree.nodes[e];if(t)return t}isTerminalNode(e){return e.playerReward!==void 0||e.opponentReward!==void 0}buildLPNode(e){if(this.nodes.has(e.nodeId))return this.nodes.get(e.nodeId);const t=this.isTerminalNode(e),i=new Kn(e.nodeId,t);e.playerActions&&(i.playerActions=e.playerActions.actions.map(s=>s.actionId)),e.opponentActions&&(i.opponentActions=e.opponentActions.actions.map(s=>s.actionId));for(const s of e.transitions){const o=`${s.playerActionId}-${s.opponentActionId}`;if(!s.nextNodeId)return k.error(`Transition in node "${e.nodeId}" (player action: ${s.playerActionId}, opponent action: ${s.opponentActionId}) has no nextNodeId`),null;const r=this.nodeMap.get(s.nextNodeId);if(!r)return k.error(`Transition in node "${e.nodeId}" references non-existent node "${s.nextNodeId}"`),null;if(this.isTerminalNode(r)){const c=r.playerReward?.value??0,l=r.opponentReward?.value??0;i.rewards.set(o,[c,l]);continue}const a=this.buildLPNode(r);if(!a)return null;i.children.set(o,a)}return this.nodes.set(e.nodeId,i),i}computeTopologicalOrder(){const e=new Set,t=new Set,i=[],s=o=>{if(t.has(o)||e.has(o))return;t.add(o);const r=this.nodes.get(o);if(r){const a=Array.from(r.children.values());for(const c of a)s(c.nodeId)}t.delete(o),e.add(o),i.push(o)};s(this.gameTree.root),this.topologicalOrder=i}solvePlayerLP(e){if(e.playerActions.length===0)return;if(k.debug("Solving player LP for node:",e.nodeId),e.playerActions.length===1){e.playerStrategy.set(e.playerActions[0],1),e.playerValue=this.calculateMinimaxValueForSinglePlayerAction(e),k.debug("Single player action, value:",e.playerValue);return}const t=it(e,!0),i=st(t),s=this.buildPlayerLPModel(e,t,i),o=fe.Solve(s);o.feasible?(e.playerStrategy=ot(o,e.playerActions,tt),e.playerValue=(o.v??0)-i,k.debug("Player LP solved, value:",e.playerValue)):(k.warn(`LP solver infeasible for player at node "${e.nodeId}", using uniform strategy`),e.playerStrategy=rt(e.playerActions),e.playerValue=this.calculateExpectedValue(e,!0))}buildPlayerLPModel(e,t,i){const s={optimize:"v",opType:"max",constraints:{},variables:{}};s.constraints.prob_sum={equal:1};for(let o=0;o<e.opponentActions.length;o++)s.constraints[`opp_${o}`]={min:0};s.variables.v={v:1};for(let o=0;o<e.opponentActions.length;o++)s.variables.v[`opp_${o}`]=-1;for(let o=0;o<e.playerActions.length;o++){const r=e.playerActions[o],a=`${tt}${r}`;s.variables[a]={prob_sum:1};for(let c=0;c<e.opponentActions.length;c++){const l=t[o][c]+i;s.variables[a][`opp_${c}`]=l}}return s}solveOpponentLP(e){if(e.opponentActions.length===0)return;if(k.debug("Solving opponent LP for node:",e.nodeId),e.opponentActions.length===1){e.opponentStrategy.set(e.opponentActions[0],1),e.opponentValue=this.calculateMinimaxValueForSingleOpponentAction(e),k.debug("Single opponent action, value:",e.opponentValue);return}const t=it(e,!1),i=st(t),s=this.buildOpponentLPModel(e,t,i),o=fe.Solve(s);o.feasible?(e.opponentStrategy=ot(o,e.opponentActions,nt),e.opponentValue=(o.v??0)-i,k.debug("Opponent LP solved, value:",e.opponentValue)):(k.warn(`LP solver infeasible for opponent at node "${e.nodeId}", using uniform strategy`),e.opponentStrategy=rt(e.opponentActions),e.opponentValue=this.calculateExpectedValue(e,!1))}buildOpponentLPModel(e,t,i){const s={optimize:"v",opType:"max",constraints:{},variables:{}};s.constraints.prob_sum={equal:1};for(let o=0;o<e.playerActions.length;o++)s.constraints[`player_${o}`]={min:0};s.variables.v={v:1};for(let o=0;o<e.playerActions.length;o++)s.variables.v[`player_${o}`]=-1;for(let o=0;o<e.opponentActions.length;o++){const r=e.opponentActions[o],a=`${nt}${r}`;s.variables[a]={prob_sum:1};for(let c=0;c<e.playerActions.length;c++){const l=t[c][o]+i;s.variables[a][`player_${c}`]=l}}return s}calculateMinimaxValueForSinglePlayerAction(e){const t=e.playerActions[0];let i=1/0;for(const s of e.opponentActions){const o=`${t}-${s}`,r=e.rewards.get(o),a=e.children.get(o);let c=0;r?c=r[0]:a&&(c=a.playerValue),i=Math.min(i,c)}return i===1/0?0:i}calculateMinimaxValueForSingleOpponentAction(e){const t=e.opponentActions[0];let i=1/0;for(const s of e.playerActions){const o=`${s}-${t}`,r=e.rewards.get(o),a=e.children.get(o);let c=0;r?c=r[1]:a&&(c=a.opponentValue),i=Math.min(i,c)}return i===1/0?0:i}calculateExpectedValue(e,t){let i=0;for(const s of e.playerActions){const o=e.playerStrategy.get(s)??1/e.playerActions.length;for(const r of e.opponentActions){const a=e.opponentStrategy.get(r)??1/e.opponentActions.length,c=`${s}-${r}`,l=e.rewards.get(c),f=e.children.get(c);let b=0;l?b=t?l[0]:l[1]:f&&(b=t?f.playerValue:f.opponentValue),i+=o*a*b}}return i}solve(e){if(k.debug("Starting LP solver"),!this.initialized){if(k.debug("Building internal tree structure"),!this.buildInternalTree())return k.error("Failed to build internal tree"),!1;k.debug("Topological order computed, nodes:",this.topologicalOrder.length)}for(const t of this.topologicalOrder){const i=this.nodes.get(t);!i||i.isTerminal||(this.solvePlayerLP(i),this.solveOpponentLP(i))}return k.debug("LP solver completed successfully"),!0}getAverageStrategy(e){const t=this.nodes.get(e);if(!t)return null;if(t.playerStrategy.size===0&&t.playerActions.length>0){const i=new Map,s=1/t.playerActions.length;for(const o of t.playerActions)i.set(o,s);return i}return new Map(t.playerStrategy)}getAverageOpponentStrategy(e){const t=this.nodes.get(e);if(!t)return null;if(t.opponentStrategy.size===0&&t.opponentActions.length>0){const i=new Map,s=1/t.opponentActions.length;for(const o of t.opponentActions)i.set(o,s);return i}return new Map(t.opponentStrategy)}getRootStrategy(){return this.getAverageStrategy(this.gameTree.root)}}function Ot(n){let e=typeof n;if(e=="object"){if(Array.isArray(n))return"array";if(n===null)return"null"}return e}function Jn(n){return n!==null&&typeof n=="object"&&!Array.isArray(n)}let te="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),Be=[];for(let n=0;n<te.length;n++)Be[te[n].charCodeAt(0)]=n;Be[45]=te.indexOf("+");Be[95]=te.indexOf("/");function Zn(n){let e=n.length*3/4;n[n.length-2]=="="?e-=2:n[n.length-1]=="="&&(e-=1);let t=new Uint8Array(e),i=0,s=0,o,r=0;for(let a=0;a<n.length;a++){if(o=Be[n.charCodeAt(a)],o===void 0)switch(n[a]){case"=":s=0;case`
`:case"\r":case"	":case" ":continue;default:throw Error("invalid base64 string.")}switch(s){case 0:r=o,s=1;break;case 1:t[i++]=r<<2|(o&48)>>4,r=o,s=2;break;case 2:t[i++]=(r&15)<<4|(o&60)>>2,r=o,s=3;break;case 3:t[i++]=(r&3)<<6|o,s=0;break}}if(s==1)throw Error("invalid base64 string.");return t.subarray(0,i)}function Qn(n){let e="",t=0,i,s=0;for(let o=0;o<n.length;o++)switch(i=n[o],t){case 0:e+=te[i>>2],s=(i&3)<<4,t=1;break;case 1:e+=te[s|i>>4],s=(i&15)<<2,t=2;break;case 2:e+=te[s|i>>6],e+=te[i&63],t=0;break}return t&&(e+=te[s],e+="=",t==1&&(e+="=")),e}var Ne;(function(n){n.symbol=Symbol.for("protobuf-ts/unknown"),n.onRead=(t,i,s,o,r)=>{(e(i)?i[n.symbol]:i[n.symbol]=[]).push({no:s,wireType:o,data:r})},n.onWrite=(t,i,s)=>{for(let{no:o,wireType:r,data:a}of n.list(i))s.tag(o,r).raw(a)},n.list=(t,i)=>{if(e(t)){let s=t[n.symbol];return i?s.filter(o=>o.no==i):s}return[]},n.last=(t,i)=>n.list(t,i).slice(-1)[0];const e=t=>t&&Array.isArray(t[n.symbol])})(Ne||(Ne={}));var G;(function(n){n[n.Varint=0]="Varint",n[n.Bit64=1]="Bit64",n[n.LengthDelimited=2]="LengthDelimited",n[n.StartGroup=3]="StartGroup",n[n.EndGroup=4]="EndGroup",n[n.Bit32=5]="Bit32"})(G||(G={}));function ei(){let n=0,e=0;for(let i=0;i<28;i+=7){let s=this.buf[this.pos++];if(n|=(s&127)<<i,(s&128)==0)return this.assertBounds(),[n,e]}let t=this.buf[this.pos++];if(n|=(t&15)<<28,e=(t&112)>>4,(t&128)==0)return this.assertBounds(),[n,e];for(let i=3;i<=31;i+=7){let s=this.buf[this.pos++];if(e|=(s&127)<<i,(s&128)==0)return this.assertBounds(),[n,e]}throw new Error("invalid varint")}function Me(n,e,t){for(let o=0;o<28;o=o+7){const r=n>>>o,a=!(!(r>>>7)&&e==0),c=(a?r|128:r)&255;if(t.push(c),!a)return}const i=n>>>28&15|(e&7)<<4,s=e>>3!=0;if(t.push((s?i|128:i)&255),!!s){for(let o=3;o<31;o=o+7){const r=e>>>o,a=!!(r>>>7),c=(a?r|128:r)&255;if(t.push(c),!a)return}t.push(e>>>31&1)}}const Ce=65536*65536;function Et(n){let e=n[0]=="-";e&&(n=n.slice(1));const t=1e6;let i=0,s=0;function o(r,a){const c=Number(n.slice(r,a));s*=t,i=i*t+c,i>=Ce&&(s=s+(i/Ce|0),i=i%Ce)}return o(-24,-18),o(-18,-12),o(-12,-6),o(-6),[e,i,s]}function De(n,e){if(e>>>0<=2097151)return""+(Ce*e+(n>>>0));let t=n&16777215,i=(n>>>24|e<<8)>>>0&16777215,s=e>>16&65535,o=t+i*6777216+s*6710656,r=i+s*8147497,a=s*2,c=1e7;o>=c&&(r+=Math.floor(o/c),o%=c),r>=c&&(a+=Math.floor(r/c),r%=c);function l(f,b){let u=f?String(f):"";return b?"0000000".slice(u.length)+u:u}return l(a,0)+l(r,a)+l(o,1)}function at(n,e){if(n>=0){for(;n>127;)e.push(n&127|128),n=n>>>7;e.push(n)}else{for(let t=0;t<9;t++)e.push(n&127|128),n=n>>7;e.push(1)}}function ti(){let n=this.buf[this.pos++],e=n&127;if((n&128)==0)return this.assertBounds(),e;if(n=this.buf[this.pos++],e|=(n&127)<<7,(n&128)==0)return this.assertBounds(),e;if(n=this.buf[this.pos++],e|=(n&127)<<14,(n&128)==0)return this.assertBounds(),e;if(n=this.buf[this.pos++],e|=(n&127)<<21,(n&128)==0)return this.assertBounds(),e;n=this.buf[this.pos++],e|=(n&15)<<28;for(let t=5;(n&128)!==0&&t<10;t++)n=this.buf[this.pos++];if((n&128)!=0)throw new Error("invalid varint");return this.assertBounds(),e>>>0}let U;function ni(){const n=new DataView(new ArrayBuffer(8));U=globalThis.BigInt!==void 0&&typeof n.getBigInt64=="function"&&typeof n.getBigUint64=="function"&&typeof n.setBigInt64=="function"&&typeof n.setBigUint64=="function"?{MIN:BigInt("-9223372036854775808"),MAX:BigInt("9223372036854775807"),UMIN:BigInt("0"),UMAX:BigInt("18446744073709551615"),C:BigInt,V:n}:void 0}ni();function _t(n){if(!n)throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support")}const At=/^-?[0-9]+$/,Oe=4294967296,Ie=2147483648;class St{constructor(e,t){this.lo=e|0,this.hi=t|0}isZero(){return this.lo==0&&this.hi==0}toNumber(){let e=this.hi*Oe+(this.lo>>>0);if(!Number.isSafeInteger(e))throw new Error("cannot convert to safe number");return e}}class W extends St{static from(e){if(U)switch(typeof e){case"string":if(e=="0")return this.ZERO;if(e=="")throw new Error("string is no integer");e=U.C(e);case"number":if(e===0)return this.ZERO;e=U.C(e);case"bigint":if(!e)return this.ZERO;if(e<U.UMIN)throw new Error("signed value for ulong");if(e>U.UMAX)throw new Error("ulong too large");return U.V.setBigUint64(0,e,!0),new W(U.V.getInt32(0,!0),U.V.getInt32(4,!0))}else switch(typeof e){case"string":if(e=="0")return this.ZERO;if(e=e.trim(),!At.test(e))throw new Error("string is no integer");let[t,i,s]=Et(e);if(t)throw new Error("signed value for ulong");return new W(i,s);case"number":if(e==0)return this.ZERO;if(!Number.isSafeInteger(e))throw new Error("number is no integer");if(e<0)throw new Error("signed value for ulong");return new W(e,e/Oe)}throw new Error("unknown value "+typeof e)}toString(){return U?this.toBigInt().toString():De(this.lo,this.hi)}toBigInt(){return _t(U),U.V.setInt32(0,this.lo,!0),U.V.setInt32(4,this.hi,!0),U.V.getBigUint64(0,!0)}}W.ZERO=new W(0,0);class z extends St{static from(e){if(U)switch(typeof e){case"string":if(e=="0")return this.ZERO;if(e=="")throw new Error("string is no integer");e=U.C(e);case"number":if(e===0)return this.ZERO;e=U.C(e);case"bigint":if(!e)return this.ZERO;if(e<U.MIN)throw new Error("signed long too small");if(e>U.MAX)throw new Error("signed long too large");return U.V.setBigInt64(0,e,!0),new z(U.V.getInt32(0,!0),U.V.getInt32(4,!0))}else switch(typeof e){case"string":if(e=="0")return this.ZERO;if(e=e.trim(),!At.test(e))throw new Error("string is no integer");let[t,i,s]=Et(e);if(t){if(s>Ie||s==Ie&&i!=0)throw new Error("signed long too small")}else if(s>=Ie)throw new Error("signed long too large");let o=new z(i,s);return t?o.negate():o;case"number":if(e==0)return this.ZERO;if(!Number.isSafeInteger(e))throw new Error("number is no integer");return e>0?new z(e,e/Oe):new z(-e,-e/Oe).negate()}throw new Error("unknown value "+typeof e)}isNegative(){return(this.hi&Ie)!==0}negate(){let e=~this.hi,t=this.lo;return t?t=~t+1:e+=1,new z(t,e)}toString(){if(U)return this.toBigInt().toString();if(this.isNegative()){let e=this.negate();return"-"+De(e.lo,e.hi)}return De(this.lo,this.hi)}toBigInt(){return _t(U),U.V.setInt32(0,this.lo,!0),U.V.setInt32(4,this.hi,!0),U.V.getBigInt64(0,!0)}}z.ZERO=new z(0,0);const ct={readUnknownField:!0,readerFactory:n=>new si(n)};function ii(n){return n?Object.assign(Object.assign({},ct),n):ct}class si{constructor(e,t){this.varint64=ei,this.uint32=ti,this.buf=e,this.len=e.length,this.pos=0,this.view=new DataView(e.buffer,e.byteOffset,e.byteLength),this.textDecoder=t??new TextDecoder("utf-8",{fatal:!0,ignoreBOM:!0})}tag(){let e=this.uint32(),t=e>>>3,i=e&7;if(t<=0||i<0||i>5)throw new Error("illegal tag: field no "+t+" wire type "+i);return[t,i]}skip(e){let t=this.pos;switch(e){case G.Varint:for(;this.buf[this.pos++]&128;);break;case G.Bit64:this.pos+=4;case G.Bit32:this.pos+=4;break;case G.LengthDelimited:let i=this.uint32();this.pos+=i;break;case G.StartGroup:let s;for(;(s=this.tag()[1])!==G.EndGroup;)this.skip(s);break;default:throw new Error("cant skip wire type "+e)}return this.assertBounds(),this.buf.subarray(t,this.pos)}assertBounds(){if(this.pos>this.len)throw new RangeError("premature EOF")}int32(){return this.uint32()|0}sint32(){let e=this.uint32();return e>>>1^-(e&1)}int64(){return new z(...this.varint64())}uint64(){return new W(...this.varint64())}sint64(){let[e,t]=this.varint64(),i=-(e&1);return e=(e>>>1|(t&1)<<31)^i,t=t>>>1^i,new z(e,t)}bool(){let[e,t]=this.varint64();return e!==0||t!==0}fixed32(){return this.view.getUint32((this.pos+=4)-4,!0)}sfixed32(){return this.view.getInt32((this.pos+=4)-4,!0)}fixed64(){return new W(this.sfixed32(),this.sfixed32())}sfixed64(){return new z(this.sfixed32(),this.sfixed32())}float(){return this.view.getFloat32((this.pos+=4)-4,!0)}double(){return this.view.getFloat64((this.pos+=8)-8,!0)}bytes(){let e=this.uint32(),t=this.pos;return this.pos+=e,this.assertBounds(),this.buf.subarray(t,t+e)}string(){return this.textDecoder.decode(this.bytes())}}function F(n,e){if(!n)throw new Error(e)}const oi=34028234663852886e22,ri=-34028234663852886e22,ai=4294967295,ci=2147483647,li=-2147483648;function he(n){if(typeof n!="number")throw new Error("invalid int 32: "+typeof n);if(!Number.isInteger(n)||n>ci||n<li)throw new Error("invalid int 32: "+n)}function Ee(n){if(typeof n!="number")throw new Error("invalid uint 32: "+typeof n);if(!Number.isInteger(n)||n>ai||n<0)throw new Error("invalid uint 32: "+n)}function He(n){if(typeof n!="number")throw new Error("invalid float 32: "+typeof n);if(Number.isFinite(n)&&(n>oi||n<ri))throw new Error("invalid float 32: "+n)}const lt={writeUnknownFields:!0,writerFactory:()=>new fi};function ui(n){return n?Object.assign(Object.assign({},lt),n):lt}class fi{constructor(e){this.stack=[],this.textEncoder=e??new TextEncoder,this.chunks=[],this.buf=[]}finish(){this.chunks.push(new Uint8Array(this.buf));let e=0;for(let s=0;s<this.chunks.length;s++)e+=this.chunks[s].length;let t=new Uint8Array(e),i=0;for(let s=0;s<this.chunks.length;s++)t.set(this.chunks[s],i),i+=this.chunks[s].length;return this.chunks=[],t}fork(){return this.stack.push({chunks:this.chunks,buf:this.buf}),this.chunks=[],this.buf=[],this}join(){let e=this.finish(),t=this.stack.pop();if(!t)throw new Error("invalid state, fork stack empty");return this.chunks=t.chunks,this.buf=t.buf,this.uint32(e.byteLength),this.raw(e)}tag(e,t){return this.uint32((e<<3|t)>>>0)}raw(e){return this.buf.length&&(this.chunks.push(new Uint8Array(this.buf)),this.buf=[]),this.chunks.push(e),this}uint32(e){for(Ee(e);e>127;)this.buf.push(e&127|128),e=e>>>7;return this.buf.push(e),this}int32(e){return he(e),at(e,this.buf),this}bool(e){return this.buf.push(e?1:0),this}bytes(e){return this.uint32(e.byteLength),this.raw(e)}string(e){let t=this.textEncoder.encode(e);return this.uint32(t.byteLength),this.raw(t)}float(e){He(e);let t=new Uint8Array(4);return new DataView(t.buffer).setFloat32(0,e,!0),this.raw(t)}double(e){let t=new Uint8Array(8);return new DataView(t.buffer).setFloat64(0,e,!0),this.raw(t)}fixed32(e){Ee(e);let t=new Uint8Array(4);return new DataView(t.buffer).setUint32(0,e,!0),this.raw(t)}sfixed32(e){he(e);let t=new Uint8Array(4);return new DataView(t.buffer).setInt32(0,e,!0),this.raw(t)}sint32(e){return he(e),e=(e<<1^e>>31)>>>0,at(e,this.buf),this}sfixed64(e){let t=new Uint8Array(8),i=new DataView(t.buffer),s=z.from(e);return i.setInt32(0,s.lo,!0),i.setInt32(4,s.hi,!0),this.raw(t)}fixed64(e){let t=new Uint8Array(8),i=new DataView(t.buffer),s=W.from(e);return i.setInt32(0,s.lo,!0),i.setInt32(4,s.hi,!0),this.raw(t)}int64(e){let t=z.from(e);return Me(t.lo,t.hi,this.buf),this}sint64(e){let t=z.from(e),i=t.hi>>31,s=t.lo<<1^i,o=(t.hi<<1|t.lo>>>31)^i;return Me(s,o,this.buf),this}uint64(e){let t=W.from(e);return Me(t.lo,t.hi,this.buf),this}}const ut={emitDefaultValues:!1,enumAsInteger:!1,useProtoFieldName:!1,prettySpaces:0},ft={ignoreUnknownFields:!1};function hi(n){return n?Object.assign(Object.assign({},ft),n):ft}function di(n){return n?Object.assign(Object.assign({},ut),n):ut}const Rt=Symbol.for("protobuf-ts/message-type");function ht(n){let e=!1;const t=[];for(let i=0;i<n.length;i++){let s=n.charAt(i);s=="_"?e=!0:/\d/.test(s)?(t.push(s),e=!0):e?(t.push(s.toUpperCase()),e=!1):i==0?t.push(s.toLowerCase()):t.push(s)}return t.join("")}var y;(function(n){n[n.DOUBLE=1]="DOUBLE",n[n.FLOAT=2]="FLOAT",n[n.INT64=3]="INT64",n[n.UINT64=4]="UINT64",n[n.INT32=5]="INT32",n[n.FIXED64=6]="FIXED64",n[n.FIXED32=7]="FIXED32",n[n.BOOL=8]="BOOL",n[n.STRING=9]="STRING",n[n.BYTES=12]="BYTES",n[n.UINT32=13]="UINT32",n[n.SFIXED32=15]="SFIXED32",n[n.SFIXED64=16]="SFIXED64",n[n.SINT32=17]="SINT32",n[n.SINT64=18]="SINT64"})(y||(y={}));var Z;(function(n){n[n.BIGINT=0]="BIGINT",n[n.STRING=1]="STRING",n[n.NUMBER=2]="NUMBER"})(Z||(Z={}));var _e;(function(n){n[n.NO=0]="NO",n[n.PACKED=1]="PACKED",n[n.UNPACKED=2]="UNPACKED"})(_e||(_e={}));function pi(n){var e,t,i,s;return n.localName=(e=n.localName)!==null&&e!==void 0?e:ht(n.name),n.jsonName=(t=n.jsonName)!==null&&t!==void 0?t:ht(n.name),n.repeat=(i=n.repeat)!==null&&i!==void 0?i:_e.NO,n.opt=(s=n.opt)!==null&&s!==void 0?s:n.repeat||n.oneof?!1:n.kind=="message",n}function mi(n){if(typeof n!="object"||n===null||!n.hasOwnProperty("oneofKind"))return!1;switch(typeof n.oneofKind){case"string":return n[n.oneofKind]===void 0?!1:Object.keys(n).length==2;case"undefined":return Object.keys(n).length==1;default:return!1}}class gi{constructor(e){var t;this.fields=(t=e.fields)!==null&&t!==void 0?t:[]}prepare(){if(this.data)return;const e=[],t=[],i=[];for(let s of this.fields)if(s.oneof)i.includes(s.oneof)||(i.push(s.oneof),e.push(s.oneof),t.push(s.oneof));else switch(t.push(s.localName),s.kind){case"scalar":case"enum":(!s.opt||s.repeat)&&e.push(s.localName);break;case"message":s.repeat&&e.push(s.localName);break;case"map":e.push(s.localName);break}this.data={req:e,known:t,oneofs:Object.values(i)}}is(e,t,i=!1){if(t<0)return!0;if(e==null||typeof e!="object")return!1;this.prepare();let s=Object.keys(e),o=this.data;if(s.length<o.req.length||o.req.some(r=>!s.includes(r))||!i&&s.some(r=>!o.known.includes(r)))return!1;if(t<1)return!0;for(const r of o.oneofs){const a=e[r];if(!mi(a))return!1;if(a.oneofKind===void 0)continue;const c=this.fields.find(l=>l.localName===a.oneofKind);if(!c||!this.field(a[a.oneofKind],c,i,t))return!1}for(const r of this.fields)if(r.oneof===void 0&&!this.field(e[r.localName],r,i,t))return!1;return!0}field(e,t,i,s){let o=t.repeat;switch(t.kind){case"scalar":return e===void 0?t.opt:o?this.scalars(e,t.T,s,t.L):this.scalar(e,t.T,t.L);case"enum":return e===void 0?t.opt:o?this.scalars(e,y.INT32,s):this.scalar(e,y.INT32);case"message":return e===void 0?!0:o?this.messages(e,t.T(),i,s):this.message(e,t.T(),i,s);case"map":if(typeof e!="object"||e===null)return!1;if(s<2)return!0;if(!this.mapKeys(e,t.K,s))return!1;switch(t.V.kind){case"scalar":return this.scalars(Object.values(e),t.V.T,s,t.V.L);case"enum":return this.scalars(Object.values(e),y.INT32,s);case"message":return this.messages(Object.values(e),t.V.T(),i,s)}break}return!0}message(e,t,i,s){return i?t.isAssignable(e,s):t.is(e,s)}messages(e,t,i,s){if(!Array.isArray(e))return!1;if(s<2)return!0;if(i){for(let o=0;o<e.length&&o<s;o++)if(!t.isAssignable(e[o],s-1))return!1}else for(let o=0;o<e.length&&o<s;o++)if(!t.is(e[o],s-1))return!1;return!0}scalar(e,t,i){let s=typeof e;switch(t){case y.UINT64:case y.FIXED64:case y.INT64:case y.SFIXED64:case y.SINT64:switch(i){case Z.BIGINT:return s=="bigint";case Z.NUMBER:return s=="number"&&!isNaN(e);default:return s=="string"}case y.BOOL:return s=="boolean";case y.STRING:return s=="string";case y.BYTES:return e instanceof Uint8Array;case y.DOUBLE:case y.FLOAT:return s=="number"&&!isNaN(e);default:return s=="number"&&Number.isInteger(e)}}scalars(e,t,i,s){if(!Array.isArray(e))return!1;if(i<2)return!0;if(Array.isArray(e)){for(let o=0;o<e.length&&o<i;o++)if(!this.scalar(e[o],t,s))return!1}return!0}mapKeys(e,t,i){let s=Object.keys(e);switch(t){case y.INT32:case y.FIXED32:case y.SFIXED32:case y.SINT32:case y.UINT32:return this.scalars(s.slice(0,i).map(o=>parseInt(o)),t,i);case y.BOOL:return this.scalars(s.slice(0,i).map(o=>o=="true"?!0:o=="false"?!1:o),t,i);default:return this.scalars(s,t,i,Z.STRING)}}}function K(n,e){switch(e){case Z.BIGINT:return n.toBigInt();case Z.NUMBER:return n.toNumber();default:return n.toString()}}class bi{constructor(e){this.info=e}prepare(){var e;if(this.fMap===void 0){this.fMap={};const t=(e=this.info.fields)!==null&&e!==void 0?e:[];for(const i of t)this.fMap[i.name]=i,this.fMap[i.jsonName]=i,this.fMap[i.localName]=i}}assert(e,t,i){if(!e){let s=Ot(i);throw(s=="number"||s=="boolean")&&(s=i.toString()),new Error(`Cannot parse JSON ${s} for ${this.info.typeName}#${t}`)}}read(e,t,i){this.prepare();const s=[];for(const[o,r]of Object.entries(e)){const a=this.fMap[o];if(!a){if(!i.ignoreUnknownFields)throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${o}`);continue}const c=a.localName;let l;if(a.oneof){if(r===null&&(a.kind!=="enum"||a.T()[0]!=="google.protobuf.NullValue"))continue;if(s.includes(a.oneof))throw new Error(`Multiple members of the oneof group "${a.oneof}" of ${this.info.typeName} are present in JSON.`);s.push(a.oneof),l=t[a.oneof]={oneofKind:c}}else l=t;if(a.kind=="map"){if(r===null)continue;this.assert(Jn(r),a.name,r);const f=l[c];for(const[b,u]of Object.entries(r)){this.assert(u!==null,a.name+" map value",null);let h;switch(a.V.kind){case"message":h=a.V.T().internalJsonRead(u,i);break;case"enum":if(h=this.enum(a.V.T(),u,a.name,i.ignoreUnknownFields),h===!1)continue;break;case"scalar":h=this.scalar(u,a.V.T,a.V.L,a.name);break}this.assert(h!==void 0,a.name+" map value",u);let d=b;a.K==y.BOOL&&(d=d=="true"?!0:d=="false"?!1:d),d=this.scalar(d,a.K,Z.STRING,a.name).toString(),f[d]=h}}else if(a.repeat){if(r===null)continue;this.assert(Array.isArray(r),a.name,r);const f=l[c];for(const b of r){this.assert(b!==null,a.name,null);let u;switch(a.kind){case"message":u=a.T().internalJsonRead(b,i);break;case"enum":if(u=this.enum(a.T(),b,a.name,i.ignoreUnknownFields),u===!1)continue;break;case"scalar":u=this.scalar(b,a.T,a.L,a.name);break}this.assert(u!==void 0,a.name,r),f.push(u)}}else switch(a.kind){case"message":if(r===null&&a.T().typeName!="google.protobuf.Value"){this.assert(a.oneof===void 0,a.name+" (oneof member)",null);continue}l[c]=a.T().internalJsonRead(r,i,l[c]);break;case"enum":if(r===null)continue;let f=this.enum(a.T(),r,a.name,i.ignoreUnknownFields);if(f===!1)continue;l[c]=f;break;case"scalar":if(r===null)continue;l[c]=this.scalar(r,a.T,a.L,a.name);break}}}enum(e,t,i,s){if(e[0]=="google.protobuf.NullValue"&&F(t===null||t==="NULL_VALUE",`Unable to parse field ${this.info.typeName}#${i}, enum ${e[0]} only accepts null.`),t===null)return 0;switch(typeof t){case"number":return F(Number.isInteger(t),`Unable to parse field ${this.info.typeName}#${i}, enum can only be integral number, got ${t}.`),t;case"string":let o=t;e[2]&&t.substring(0,e[2].length)===e[2]&&(o=t.substring(e[2].length));let r=e[1][o];return typeof r>"u"&&s?!1:(F(typeof r=="number",`Unable to parse field ${this.info.typeName}#${i}, enum ${e[0]} has no value for "${t}".`),r)}F(!1,`Unable to parse field ${this.info.typeName}#${i}, cannot parse enum value from ${typeof t}".`)}scalar(e,t,i,s){let o;try{switch(t){case y.DOUBLE:case y.FLOAT:if(e===null)return 0;if(e==="NaN")return Number.NaN;if(e==="Infinity")return Number.POSITIVE_INFINITY;if(e==="-Infinity")return Number.NEGATIVE_INFINITY;if(e===""){o="empty string";break}if(typeof e=="string"&&e.trim().length!==e.length){o="extra whitespace";break}if(typeof e!="string"&&typeof e!="number")break;let r=Number(e);if(Number.isNaN(r)){o="not a number";break}if(!Number.isFinite(r)){o="too large or small";break}return t==y.FLOAT&&He(r),r;case y.INT32:case y.FIXED32:case y.SFIXED32:case y.SINT32:case y.UINT32:if(e===null)return 0;let a;if(typeof e=="number"?a=e:e===""?o="empty string":typeof e=="string"&&(e.trim().length!==e.length?o="extra whitespace":a=Number(e)),a===void 0)break;return t==y.UINT32?Ee(a):he(a),a;case y.INT64:case y.SFIXED64:case y.SINT64:if(e===null)return K(z.ZERO,i);if(typeof e!="number"&&typeof e!="string")break;return K(z.from(e),i);case y.FIXED64:case y.UINT64:if(e===null)return K(W.ZERO,i);if(typeof e!="number"&&typeof e!="string")break;return K(W.from(e),i);case y.BOOL:if(e===null)return!1;if(typeof e!="boolean")break;return e;case y.STRING:if(e===null)return"";if(typeof e!="string"){o="extra whitespace";break}try{encodeURIComponent(e)}catch(c){c="invalid UTF8";break}return e;case y.BYTES:if(e===null||e==="")return new Uint8Array(0);if(typeof e!="string")break;return Zn(e)}}catch(r){o=r.message}this.assert(!1,s+(o?" - "+o:""),e)}}class yi{constructor(e){var t;this.fields=(t=e.fields)!==null&&t!==void 0?t:[]}write(e,t){const i={},s=e;for(const o of this.fields){if(!o.oneof){let l=this.field(o,s[o.localName],t);l!==void 0&&(i[t.useProtoFieldName?o.name:o.jsonName]=l);continue}const r=s[o.oneof];if(r.oneofKind!==o.localName)continue;const a=o.kind=="scalar"||o.kind=="enum"?Object.assign(Object.assign({},t),{emitDefaultValues:!0}):t;let c=this.field(o,r[o.localName],a);F(c!==void 0),i[t.useProtoFieldName?o.name:o.jsonName]=c}return i}field(e,t,i){let s;if(e.kind=="map"){F(typeof t=="object"&&t!==null);const o={};switch(e.V.kind){case"scalar":for(const[c,l]of Object.entries(t)){const f=this.scalar(e.V.T,l,e.name,!1,!0);F(f!==void 0),o[c.toString()]=f}break;case"message":const r=e.V.T();for(const[c,l]of Object.entries(t)){const f=this.message(r,l,e.name,i);F(f!==void 0),o[c.toString()]=f}break;case"enum":const a=e.V.T();for(const[c,l]of Object.entries(t)){F(l===void 0||typeof l=="number");const f=this.enum(a,l,e.name,!1,!0,i.enumAsInteger);F(f!==void 0),o[c.toString()]=f}break}(i.emitDefaultValues||Object.keys(o).length>0)&&(s=o)}else if(e.repeat){F(Array.isArray(t));const o=[];switch(e.kind){case"scalar":for(let c=0;c<t.length;c++){const l=this.scalar(e.T,t[c],e.name,e.opt,!0);F(l!==void 0),o.push(l)}break;case"enum":const r=e.T();for(let c=0;c<t.length;c++){F(t[c]===void 0||typeof t[c]=="number");const l=this.enum(r,t[c],e.name,e.opt,!0,i.enumAsInteger);F(l!==void 0),o.push(l)}break;case"message":const a=e.T();for(let c=0;c<t.length;c++){const l=this.message(a,t[c],e.name,i);F(l!==void 0),o.push(l)}break}(i.emitDefaultValues||o.length>0||i.emitDefaultValues)&&(s=o)}else switch(e.kind){case"scalar":s=this.scalar(e.T,t,e.name,e.opt,i.emitDefaultValues);break;case"enum":s=this.enum(e.T(),t,e.name,e.opt,i.emitDefaultValues,i.enumAsInteger);break;case"message":s=this.message(e.T(),t,e.name,i);break}return s}enum(e,t,i,s,o,r){if(e[0]=="google.protobuf.NullValue")return!o&&!s?void 0:null;if(t===void 0){F(s);return}if(!(t===0&&!o&&!s))return F(typeof t=="number"),F(Number.isInteger(t)),r||!e[1].hasOwnProperty(t)?t:e[2]?e[2]+e[1][t]:e[1][t]}message(e,t,i,s){return t===void 0?s.emitDefaultValues?null:void 0:e.internalJsonWrite(t,s)}scalar(e,t,i,s,o){if(t===void 0){F(s);return}const r=o||s;switch(e){case y.INT32:case y.SFIXED32:case y.SINT32:return t===0?r?0:void 0:(he(t),t);case y.FIXED32:case y.UINT32:return t===0?r?0:void 0:(Ee(t),t);case y.FLOAT:He(t);case y.DOUBLE:return t===0?r?0:void 0:(F(typeof t=="number"),Number.isNaN(t)?"NaN":t===Number.POSITIVE_INFINITY?"Infinity":t===Number.NEGATIVE_INFINITY?"-Infinity":t);case y.STRING:return t===""?r?"":void 0:(F(typeof t=="string"),t);case y.BOOL:return t===!1?r?!1:void 0:(F(typeof t=="boolean"),t);case y.UINT64:case y.FIXED64:F(typeof t=="number"||typeof t=="string"||typeof t=="bigint");let a=W.from(t);return a.isZero()&&!r?void 0:a.toString();case y.INT64:case y.SFIXED64:case y.SINT64:F(typeof t=="number"||typeof t=="string"||typeof t=="bigint");let c=z.from(t);return c.isZero()&&!r?void 0:c.toString();case y.BYTES:return F(t instanceof Uint8Array),t.byteLength?Qn(t):r?"":void 0}}}function $e(n,e=Z.STRING){switch(n){case y.BOOL:return!1;case y.UINT64:case y.FIXED64:return K(W.ZERO,e);case y.INT64:case y.SFIXED64:case y.SINT64:return K(z.ZERO,e);case y.DOUBLE:case y.FLOAT:return 0;case y.BYTES:return new Uint8Array(0);case y.STRING:return"";default:return 0}}class wi{constructor(e){this.info=e}prepare(){var e;if(!this.fieldNoToField){const t=(e=this.info.fields)!==null&&e!==void 0?e:[];this.fieldNoToField=new Map(t.map(i=>[i.no,i]))}}read(e,t,i,s){this.prepare();const o=s===void 0?e.len:e.pos+s;for(;e.pos<o;){const[r,a]=e.tag(),c=this.fieldNoToField.get(r);if(!c){let u=i.readUnknownField;if(u=="throw")throw new Error(`Unknown field ${r} (wire type ${a}) for ${this.info.typeName}`);let h=e.skip(a);u!==!1&&(u===!0?Ne.onRead:u)(this.info.typeName,t,r,a,h);continue}let l=t,f=c.repeat,b=c.localName;switch(c.oneof&&(l=l[c.oneof],l.oneofKind!==b&&(l=t[c.oneof]={oneofKind:b})),c.kind){case"scalar":case"enum":let u=c.kind=="enum"?y.INT32:c.T,h=c.kind=="scalar"?c.L:void 0;if(f){let g=l[b];if(a==G.LengthDelimited&&u!=y.STRING&&u!=y.BYTES){let m=e.uint32()+e.pos;for(;e.pos<m;)g.push(this.scalar(e,u,h))}else g.push(this.scalar(e,u,h))}else l[b]=this.scalar(e,u,h);break;case"message":if(f){let g=l[b],m=c.T().internalBinaryRead(e,e.uint32(),i);g.push(m)}else l[b]=c.T().internalBinaryRead(e,e.uint32(),i,l[b]);break;case"map":let[d,p]=this.mapEntry(c,e,i);l[b][d]=p;break}}}mapEntry(e,t,i){let s=t.uint32(),o=t.pos+s,r,a;for(;t.pos<o;){let[c,l]=t.tag();switch(c){case 1:e.K==y.BOOL?r=t.bool().toString():r=this.scalar(t,e.K,Z.STRING);break;case 2:switch(e.V.kind){case"scalar":a=this.scalar(t,e.V.T,e.V.L);break;case"enum":a=t.int32();break;case"message":a=e.V.T().internalBinaryRead(t,t.uint32(),i);break}break;default:throw new Error(`Unknown field ${c} (wire type ${l}) in map entry for ${this.info.typeName}#${e.name}`)}}if(r===void 0){let c=$e(e.K);r=e.K==y.BOOL?c.toString():c}if(a===void 0)switch(e.V.kind){case"scalar":a=$e(e.V.T,e.V.L);break;case"enum":a=0;break;case"message":a=e.V.T().create();break}return[r,a]}scalar(e,t,i){switch(t){case y.INT32:return e.int32();case y.STRING:return e.string();case y.BOOL:return e.bool();case y.DOUBLE:return e.double();case y.FLOAT:return e.float();case y.INT64:return K(e.int64(),i);case y.UINT64:return K(e.uint64(),i);case y.FIXED64:return K(e.fixed64(),i);case y.FIXED32:return e.fixed32();case y.BYTES:return e.bytes();case y.UINT32:return e.uint32();case y.SFIXED32:return e.sfixed32();case y.SFIXED64:return K(e.sfixed64(),i);case y.SINT32:return e.sint32();case y.SINT64:return K(e.sint64(),i)}}}class vi{constructor(e){this.info=e}prepare(){if(!this.fields){const e=this.info.fields?this.info.fields.concat():[];this.fields=e.sort((t,i)=>t.no-i.no)}}write(e,t,i){this.prepare();for(const o of this.fields){let r,a,c=o.repeat,l=o.localName;if(o.oneof){const f=e[o.oneof];if(f.oneofKind!==l)continue;r=f[l],a=!0}else r=e[l],a=!1;switch(o.kind){case"scalar":case"enum":let f=o.kind=="enum"?y.INT32:o.T;if(c)if(F(Array.isArray(r)),c==_e.PACKED)this.packed(t,f,o.no,r);else for(const b of r)this.scalar(t,f,o.no,b,!0);else r===void 0?F(o.opt):this.scalar(t,f,o.no,r,a||o.opt);break;case"message":if(c){F(Array.isArray(r));for(const b of r)this.message(t,i,o.T(),o.no,b)}else this.message(t,i,o.T(),o.no,r);break;case"map":F(typeof r=="object"&&r!==null);for(const[b,u]of Object.entries(r))this.mapEntry(t,i,o,b,u);break}}let s=i.writeUnknownFields;s!==!1&&(s===!0?Ne.onWrite:s)(this.info.typeName,e,t)}mapEntry(e,t,i,s,o){e.tag(i.no,G.LengthDelimited),e.fork();let r=s;switch(i.K){case y.INT32:case y.FIXED32:case y.UINT32:case y.SFIXED32:case y.SINT32:r=Number.parseInt(s);break;case y.BOOL:F(s=="true"||s=="false"),r=s=="true";break}switch(this.scalar(e,i.K,1,r,!0),i.V.kind){case"scalar":this.scalar(e,i.V.T,2,o,!0);break;case"enum":this.scalar(e,y.INT32,2,o,!0);break;case"message":this.message(e,t,i.V.T(),2,o);break}e.join()}message(e,t,i,s,o){o!==void 0&&(i.internalBinaryWrite(o,e.tag(s,G.LengthDelimited).fork(),t),e.join())}scalar(e,t,i,s,o){let[r,a,c]=this.scalarInfo(t,s);(!c||o)&&(e.tag(i,r),e[a](s))}packed(e,t,i,s){if(!s.length)return;F(t!==y.BYTES&&t!==y.STRING),e.tag(i,G.LengthDelimited),e.fork();let[,o]=this.scalarInfo(t);for(let r=0;r<s.length;r++)e[o](s[r]);e.join()}scalarInfo(e,t){let i=G.Varint,s,o=t===void 0,r=t===0;switch(e){case y.INT32:s="int32";break;case y.STRING:r=o||!t.length,i=G.LengthDelimited,s="string";break;case y.BOOL:r=t===!1,s="bool";break;case y.UINT32:s="uint32";break;case y.DOUBLE:i=G.Bit64,s="double";break;case y.FLOAT:i=G.Bit32,s="float";break;case y.INT64:r=o||z.from(t).isZero(),s="int64";break;case y.UINT64:r=o||W.from(t).isZero(),s="uint64";break;case y.FIXED64:r=o||W.from(t).isZero(),i=G.Bit64,s="fixed64";break;case y.BYTES:r=o||!t.byteLength,i=G.LengthDelimited,s="bytes";break;case y.FIXED32:i=G.Bit32,s="fixed32";break;case y.SFIXED32:i=G.Bit32,s="sfixed32";break;case y.SFIXED64:r=o||z.from(t).isZero(),i=G.Bit64,s="sfixed64";break;case y.SINT32:s="sint32";break;case y.SINT64:r=o||z.from(t).isZero(),s="sint64";break}return[i,s,o||r]}}function Ii(n){const e=n.messagePrototype?Object.create(n.messagePrototype):Object.defineProperty({},Rt,{value:n});for(let t of n.fields){let i=t.localName;if(!t.opt)if(t.oneof)e[t.oneof]={oneofKind:void 0};else if(t.repeat)e[i]=[];else switch(t.kind){case"scalar":e[i]=$e(t.T,t.L);break;case"enum":e[i]=0;break;case"map":e[i]={};break}}return e}function Fe(n,e,t){let i,s=t,o;for(let r of n.fields){let a=r.localName;if(r.oneof){const c=s[r.oneof];if(c?.oneofKind==null)continue;if(i=c[a],o=e[r.oneof],o.oneofKind=c.oneofKind,i==null){delete o[a];continue}}else if(i=s[a],o=e,i==null)continue;switch(r.repeat&&(o[a].length=i.length),r.kind){case"scalar":case"enum":if(r.repeat)for(let l=0;l<i.length;l++)o[a][l]=i[l];else o[a]=i;break;case"message":let c=r.T();if(r.repeat)for(let l=0;l<i.length;l++)o[a][l]=c.create(i[l]);else o[a]===void 0?o[a]=c.create(i):c.mergePartial(o[a],i);break;case"map":switch(r.V.kind){case"scalar":case"enum":Object.assign(o[a],i);break;case"message":let l=r.V.T();for(let f of Object.keys(i))o[a][f]=l.create(i[f]);break}break}}}function xi(n,e,t){if(e===t)return!0;if(!e||!t)return!1;for(let i of n.fields){let s=i.localName,o=i.oneof?e[i.oneof][s]:e[s],r=i.oneof?t[i.oneof][s]:t[s];switch(i.kind){case"enum":case"scalar":let a=i.kind=="enum"?y.INT32:i.T;if(!(i.repeat?dt(a,o,r):Bt(a,o,r)))return!1;break;case"map":if(!(i.V.kind=="message"?pt(i.V.T(),xe(o),xe(r)):dt(i.V.kind=="enum"?y.INT32:i.V.T,xe(o),xe(r))))return!1;break;case"message":let c=i.T();if(!(i.repeat?pt(c,o,r):c.equals(o,r)))return!1;break}}return!0}const xe=Object.values;function Bt(n,e,t){if(e===t)return!0;if(n!==y.BYTES)return!1;let i=e,s=t;if(i.length!==s.length)return!1;for(let o=0;o<i.length;o++)if(i[o]!=s[o])return!1;return!0}function dt(n,e,t){if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(!Bt(n,e[i],t[i]))return!1;return!0}function pt(n,e,t){if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(!n.equals(e[i],t[i]))return!1;return!0}const kt=Object.getOwnPropertyDescriptors(Object.getPrototypeOf({})),Ti=kt[Rt]={};class P{constructor(e,t,i){this.defaultCheckDepth=16,this.typeName=e,this.fields=t.map(pi),this.options=i??{},Ti.value=this,this.messagePrototype=Object.create(null,kt),this.refTypeCheck=new gi(this),this.refJsonReader=new bi(this),this.refJsonWriter=new yi(this),this.refBinReader=new wi(this),this.refBinWriter=new vi(this)}create(e){let t=Ii(this);return e!==void 0&&Fe(this,t,e),t}clone(e){let t=this.create();return Fe(this,t,e),t}equals(e,t){return xi(this,e,t)}is(e,t=this.defaultCheckDepth){return this.refTypeCheck.is(e,t,!1)}isAssignable(e,t=this.defaultCheckDepth){return this.refTypeCheck.is(e,t,!0)}mergePartial(e,t){Fe(this,e,t)}fromBinary(e,t){let i=ii(t);return this.internalBinaryRead(i.readerFactory(e),e.byteLength,i)}fromJson(e,t){return this.internalJsonRead(e,hi(t))}fromJsonString(e,t){let i=JSON.parse(e);return this.fromJson(i,t)}toJson(e,t){return this.internalJsonWrite(e,di(t))}toJsonString(e,t){var i;let s=this.toJson(e,t);return JSON.stringify(s,null,(i=t?.prettySpaces)!==null&&i!==void 0?i:0)}toBinary(e,t){let i=ui(t);return this.internalBinaryWrite(e,i.writerFactory(),i).finish()}internalJsonRead(e,t,i){if(e!==null&&typeof e=="object"&&!Array.isArray(e)){let s=i??this.create();return this.refJsonReader.read(e,s,t),s}throw new Error(`Unable to parse message ${this.typeName} from JSON ${Ot(e)}.`)}internalJsonWrite(e,t){return this.refJsonWriter.write(e,t)}internalBinaryWrite(e,t,i){return this.refBinWriter.write(e,t,i),t}internalBinaryRead(e,t,i,s){let o=s??this.create();return this.refBinReader.read(e,o,i,t),o}}var de;(function(n){n[n.UNKNOWN=0]="UNKNOWN",n[n.NONE=1]="NONE",n[n.PLAYER_IN_CORNER=2]="PLAYER_IN_CORNER",n[n.OPPONENT_IN_CORNER=3]="OPPONENT_IN_CORNER"})(de||(de={}));var V;(function(n){n[n.UNKNOWN=0]="UNKNOWN",n[n.PLAYER_HEALTH=1]="PLAYER_HEALTH",n[n.OPPONENT_HEALTH=2]="OPPONENT_HEALTH",n[n.PLAYER_OD_GAUGE=3]="PLAYER_OD_GAUGE",n[n.OPPONENT_OD_GAUGE=5]="OPPONENT_OD_GAUGE",n[n.PLAYER_SA_GAUGE=4]="PLAYER_SA_GAUGE",n[n.OPPONENT_SA_GAUGE=6]="OPPONENT_SA_GAUGE"})(V||(V={}));var X;(function(n){n[n.UNKNOWN=0]="UNKNOWN",n[n.NORMAL=1]="NORMAL",n[n.OD=2]="OD",n[n.SA1=3]="SA1",n[n.SA2=4]="SA2",n[n.SA3=5]="SA3",n[n.DRIVE_RUSH=6]="DRIVE_RUSH",n[n.PARRY=7]="PARRY"})(X||(X={}));let Ci=class extends P{constructor(){super("nomari.Scenario",[{no:1,name:"game_id",kind:"scalar",T:13},{no:2,name:"name",kind:"scalar",T:9},{no:3,name:"description",kind:"scalar",T:9},{no:4,name:"root_situation_id",kind:"scalar",T:13},{no:5,name:"situations",kind:"message",repeat:2,T:()=>Ei},{no:6,name:"terminal_situations",kind:"message",repeat:2,T:()=>Ai},{no:7,name:"initial_dynamic_state",kind:"message",T:()=>Ui},{no:8,name:"reward_computation_method",kind:"message",T:()=>Ri},{no:13,name:"player",kind:"message",T:()=>mt},{no:14,name:"opponent",kind:"message",T:()=>mt}])}};new Ci;let Ni=class extends P{constructor(){super("nomari.Character",[{no:1,name:"name",kind:"scalar",T:9},{no:2,name:"actions",kind:"message",repeat:2,T:()=>Vt},{no:3,name:"combo_starters",kind:"message",repeat:2,T:()=>Ji}])}};const mt=new Ni;let Oi=class extends P{constructor(){super("nomari.Situation",[{no:1,name:"situation_id",kind:"scalar",T:13},{no:2,name:"name",kind:"scalar",T:9},{no:4,name:"player_action_ids",kind:"scalar",repeat:1,T:13},{no:5,name:"opponent_action_ids",kind:"scalar",repeat:1,T:13},{no:6,name:"transitions",kind:"message",repeat:2,T:()=>Wi}])}};const Ei=new Oi;let _i=class extends P{constructor(){super("nomari.TerminalSituation",[{no:1,name:"situation_id",kind:"scalar",T:13},{no:2,name:"name",kind:"scalar",T:9},{no:3,name:"description",kind:"scalar",T:9},{no:4,name:"corner_state",kind:"enum",opt:!0,T:()=>["nomari.CornerState",de,"CORNER_STATE_"]}])}};const Ai=new _i;let Si=class extends P{constructor(){super("nomari.RewardComputationMethod",[{no:1,name:"damage_race",kind:"message",oneof:"method",T:()=>ki},{no:2,name:"win_probability",kind:"message",oneof:"method",T:()=>Pi}])}};const Ri=new Si;let Bi=class extends P{constructor(){super("nomari.RewardComputationMethod.DamageRace",[])}};const ki=new Bi;let Vi=class extends P{constructor(){super("nomari.RewardComputationMethod.WinProbability",[{no:1,name:"corner_bonus",kind:"scalar",T:1},{no:2,name:"od_gauge_bonus",kind:"scalar",opt:!0,T:1},{no:3,name:"sa_gauge_bonus",kind:"scalar",opt:!0,T:1}])}};const Pi=new Vi;let Mi=class extends P{constructor(){super("nomari.ResourceConsumption",[{no:1,name:"resource_type",kind:"enum",T:()=>["nomari.ResourceType",V,"RESOURCE_TYPE_"]},{no:2,name:"value",kind:"scalar",T:1}])}};const Fi=new Mi;let Li=class extends P{constructor(){super("nomari.ResourceRequirement",[{no:1,name:"resource_type",kind:"enum",T:()=>["nomari.ResourceType",V,"RESOURCE_TYPE_"]},{no:2,name:"value",kind:"scalar",T:1}])}};const Di=new Li;let $i=class extends P{constructor(){super("nomari.DynamicState",[{no:1,name:"resources",kind:"message",repeat:2,T:()=>Gi}])}};const Ui=new $i;let ji=class extends P{constructor(){super("nomari.DynamicState.Resource",[{no:1,name:"resource_type",kind:"enum",T:()=>["nomari.ResourceType",V,"RESOURCE_TYPE_"]},{no:2,name:"value",kind:"scalar",T:1}])}};const Gi=new ji;let zi=class extends P{constructor(){super("nomari.PlayerActions",[{no:1,name:"actions",kind:"message",repeat:2,T:()=>Vt}])}};new zi;let Yi=class extends P{constructor(){super("nomari.Action",[{no:1,name:"action_id",kind:"scalar",T:13},{no:2,name:"name",kind:"scalar",T:9},{no:3,name:"description",kind:"scalar",T:9},{no:4,name:"action_type",kind:"enum",T:()=>["nomari.ActionType",X,"ACTION_TYPE_"]}])}};const Vt=new Yi;let Hi=class extends P{constructor(){super("nomari.Transition",[{no:1,name:"player_action_id",kind:"scalar",T:13},{no:2,name:"opponent_action_id",kind:"scalar",T:13},{no:3,name:"next_situation_id",kind:"scalar",T:13}])}};const Wi=new Hi;let qi=class extends P{constructor(){super("nomari.ComboRoute",[{no:1,name:"name",kind:"scalar",T:9},{no:2,name:"requirements",kind:"message",repeat:2,T:()=>Di},{no:3,name:"consumptions",kind:"message",repeat:2,T:()=>Fi},{no:4,name:"next_situation_id",kind:"scalar",T:13}])}};const Ki=new qi;let Xi=class extends P{constructor(){super("nomari.ComboStarter",[{no:1,name:"situation_id",kind:"scalar",T:13},{no:2,name:"name",kind:"scalar",T:9},{no:3,name:"description",kind:"scalar",T:9},{no:5,name:"starter_action_id",kind:"scalar",opt:!0,T:9},{no:4,name:"routes",kind:"message",repeat:2,T:()=>Ki}])}};const Ji=new Xi;k.setLevel("warn");const Zi=1e3;function Ue(n){return n*2e4-1e4}function gt(n,e,t){return n<=0?0:t>=n?1:1+(n-t)/e}function Qi(n,e,t,i,s=0,o=0,r=0,a=0,c=0,l=0,f=Zi){const b=bt(f,t,i,!0),u=bt(f,t,i,!1),h=b+s*c+r*l,d=u+o*c+a*l,p=gt(e,b,h),g=gt(n,u,d),m=es(p,g),w=Ue(m);return k.debug("Win probability reward:",{playerHealth:n,opponentHealth:e,playerTurns:p,opponentTurns:g,winProbability:m,reward:w}),{reward:w,winProbability:m,playerTurnsToKill:p,opponentTurnsToKill:g}}function bt(n,e,t,i){return i&&e===de.OPPONENT_IN_CORNER||!i&&e===de.PLAYER_IN_CORNER?n+t:n}function es(n,e){return n<=0&&k.warn("calculateWinProbabilityFromTurns: playerTurns should be > 0, got:",n),e<=0&&k.warn("calculateWinProbabilityFromTurns: opponentTurns should be > 0, got:",e),e/(n+e)}function je(n,e,t,i){const s=i-e,o=t-n,r=s-o;return k.debug("Damage race reward:",{playerHealth:n,opponentHealth:e,damageDealt:s,damageReceived:o,reward:r}),r}k.setLevel("warn");function Pt(n){return[...n.resources].sort((t,i)=>t.resourceType-i.resourceType).map(t=>`${t.resourceType}:${t.value.toFixed(2)}`).join("|")}function ts(n){return n===V.PLAYER_OD_GAUGE||n===V.PLAYER_SA_GAUGE||n===V.OPPONENT_OD_GAUGE||n===V.OPPONENT_SA_GAUGE}function Ge(n,e){const t=[],i=e?V.PLAYER_OD_GAUGE:V.OPPONENT_OD_GAUGE,s=e?V.PLAYER_SA_GAUGE:V.OPPONENT_SA_GAUGE;switch(n.actionType){case X.OD:t.push({resourceType:i,value:2});break;case X.DRIVE_RUSH:t.push({resourceType:i,value:1});break;case X.PARRY:t.push({resourceType:i,value:.5});break;case X.SA1:t.push({resourceType:s,value:1});break;case X.SA2:t.push({resourceType:s,value:2});break;case X.SA3:t.push({resourceType:s,value:3});break;case X.NORMAL:}return t}function yt(n,e){return Ge(n,e).map(t=>({resourceType:t.resourceType,value:t.value}))}function Mt(n,e){for(const t of e)if((n.resources.find(s=>s.resourceType===t.resourceType)?.value||0)<t.value)return!1;return!0}function Ft(n,e){const t=new Map;for(const s of n.resources)t.set(s.resourceType,s.value);for(const s of e){const o=t.get(s.resourceType)||0;let r;ts(s.resourceType)?r=o<s.value?o:s.value:r=s.value;const a=Math.max(0,o-r);t.set(s.resourceType,a)}return{resources:Array.from(t.entries()).map(([s,o])=>({resourceType:s,value:o}))}}function j(n,e){return n.resources.find(i=>i.resourceType===e)?.value||0}function Lt(n){const e=j(n,V.PLAYER_HEALTH),t=j(n,V.OPPONENT_HEALTH);return e<=0&&t<=0?{isTerminal:!0,type:"draw"}:e<=0?{isTerminal:!0,type:"lose"}:t<=0?{isTerminal:!0,type:"win"}:{isTerminal:!1,type:null}}const Dt={method:{oneofKind:"damageRace",damageRace:{}}};function $t(n,e,t,i,s,o,r,a){let c;return s||(s=Dt),s.method.oneofKind==="damageRace"?c=je(t,i,o,r):e==="win"?c=Ue(1):e==="lose"?c=Ue(0):c=0,{nodeId:n,name:`: ${e}`,description:"",state:{playerHealth:t,opponentHealth:i,playerOd:j(a,V.PLAYER_OD_GAUGE),opponentOd:j(a,V.OPPONENT_OD_GAUGE),playerSa:j(a,V.PLAYER_SA_GAUGE),opponentSa:j(a,V.OPPONENT_SA_GAUGE)},transitions:[],playerActions:void 0,opponentActions:void 0,playerReward:{value:c},opponentReward:{value:-c}}}function ns(n,e,t,i,s,o,r,a){let c;const l=j(a,V.PLAYER_OD_GAUGE),f=j(a,V.OPPONENT_OD_GAUGE),b=j(a,V.PLAYER_SA_GAUGE),u=j(a,V.OPPONENT_SA_GAUGE);if(s||(s=Dt),s.method.oneofKind==="damageRace")c=je(t,i,o,r);else if(s.method.oneofKind==="winProbability"){const h=s.method.winProbability,d=h.cornerBonus||0,p=h.odGaugeBonus??0,g=h.saGaugeBonus??0;c=Qi(t,i,e.cornerState,d,l,f,b,u,p,g).reward}else k.warn("Unknown reward computation method:",s.method.oneofKind,"- using damageRace"),c=je(t,i,o,r);return{nodeId:n,name:e.name,description:e.description??"",state:{situation_id:e.situationId,playerHealth:t,opponentHealth:i,playerOd:l,opponentOd:f,playerSa:b,opponentSa:u},transitions:[],playerActions:void 0,opponentActions:void 0,playerReward:{value:c},opponentReward:{value:-c}}}function Ae(n){return typeof n=="object"&&n!==null&&"code"in n}function is(n,e,t,i,s,o,r){const a=j(t,V.PLAYER_HEALTH),c=j(t,V.OPPONENT_HEALTH),l=Pt(t),f=`terminal_${i}_${l}`,b=n.get(f);if(b)return b;const u=$t(f,i,a,c,s,o,r,t);return n.set(f,u),e.set(f,t),u}function ss(n){const e=n.initialDynamicState||{resources:[]},t=new Map;for(const c of n.situations)t.set(c.situationId,c);const i=new Map;for(const c of n.terminalSituations)i.set(c.situationId,c);const s=new Map;for(const c of n.player?.comboStarters||[])s.set(c.situationId,c);const o=new Map;for(const c of n.opponent?.comboStarters||[])o.set(c.situationId,c);const r=new Map;for(const c of n.player?.actions||[])r.set(c.actionId,c);const a=new Map;for(const c of n.opponent?.actions||[])a.set(c.actionId,c);return{nodeMap:new Map,nodeStateMap:new Map,creatingNodes:new Set,situationMap:t,terminalSituationMap:i,playerComboStarterMap:s,opponentComboStarterMap:o,playerActionMap:r,opponentActionMap:a,rewardComputationMethod:n.rewardComputationMethod,initialPlayerHealth:j(e,V.PLAYER_HEALTH),initialOpponentHealth:j(e,V.OPPONENT_HEALTH)}}function os(n,e){const t=e.nodeMap.get(n);return t?(k.debug("Node cache hit:",n),t):null}function rs(n,e,t,i){return i.creatingNodes.has(n)?(k.warn("Cycle detected at situation:",e,"stateHash:",t),{code:"CYCLE_DETECTED",message:"Cycle detected: Infinite loop found with same DynamicState. This indicates a game definition error where transitions form a cycle without changing game state.",situationId:e,stateHash:t}):null}function as(n,e,t){const i=Lt(e);if(!i.isTerminal)return null;const s=j(e,V.PLAYER_HEALTH),o=j(e,V.OPPONENT_HEALTH);k.debug("Creating terminal node:",n,"type:",i.type);const r=$t(n,i.type,s,o,t.rewardComputationMethod,t.initialPlayerHealth,t.initialOpponentHealth,e);return t.nodeMap.set(n,r),t.nodeStateMap.set(n,e),r}function cs(n,e,t,i){const s=i.terminalSituationMap.get(e);if(!s)return null;const o=j(t,V.PLAYER_HEALTH),r=j(t,V.OPPONENT_HEALTH);k.debug("Creating terminal situation node:",n,"name:",s.name);const a=ns(n,s,o,r,i.rewardComputationMethod,i.initialPlayerHealth,i.initialOpponentHealth,t);return i.nodeMap.set(n,a),i.nodeStateMap.set(n,t),i.creatingNodes.delete(n),a}function Ut(n,e){return{situation_id:n,playerHealth:j(e,V.PLAYER_HEALTH),opponentHealth:j(e,V.OPPONENT_HEALTH),playerOd:j(e,V.PLAYER_OD_GAUGE),opponentOd:j(e,V.OPPONENT_OD_GAUGE),playerSa:j(e,V.PLAYER_SA_GAUGE),opponentSa:j(e,V.OPPONENT_SA_GAUGE)}}function ls(n,e,t,i,s){const o=i.playerActionMap.get(e.playerActionId),r=i.opponentActionMap.get(e.opponentActionId),a=o?yt(o,!0):[],c=r?yt(r,!1):[],l=[...a,...c];if(!Mt(t,l))return null;const f=o?Ge(o,!0):[],b=r?Ge(r,!1):[],u=[...f,...b],h=Ft(t,u),d=Lt(h);if(d.isTerminal){const g=is(i.nodeMap,i.nodeStateMap,h,d.type,i.rewardComputationMethod,i.initialPlayerHealth,i.initialOpponentHealth);return n.transitions.push({playerActionId:e.playerActionId,opponentActionId:e.opponentActionId,nextNodeId:g.nodeId}),null}const p=s(e.nextSituationId,h);return Ae(p)?p:(n.transitions.push({playerActionId:e.playerActionId,opponentActionId:e.opponentActionId,nextNodeId:p.nodeId}),null)}function us(n,e,t,i,s){k.debug("Building situation node:",n,"name:",e.name);const o=e.playerActionIds.map(c=>i.playerActionMap.get(c)).filter(c=>c!==void 0).map(c=>({actionId:c.actionId,name:c.name,description:c.description})),r=e.opponentActionIds.map(c=>i.opponentActionMap.get(c)).filter(c=>c!==void 0).map(c=>({actionId:c.actionId,name:c.name,description:c.description})),a={nodeId:n,name:e.name,description:"",state:Ut(e.situationId,t),playerActions:{actions:o},opponentActions:{actions:r},transitions:[]};for(const c of e.transitions){const l=ls(a,c,t,i,s);if(l)return l}return i.nodeMap.set(n,a),i.nodeStateMap.set(n,t),i.creatingNodes.delete(n),a}function fs(n,e,t,i,s){k.debug("Building combo starter node:",n,"name:",e.name);const o=e.routes.filter(f=>Mt(t,f.requirements)),r=o.map((f,b)=>({actionId:b+1,name:f.name,description:""})),a=0,c=[{actionId:a,name:"",description:""}],l=[];for(let f=0;f<o.length;f++){const b=o[f],u=f+1,h=Ft(t,b.consumptions),d=s(b.nextSituationId,h);if(Ae(d))return d;l.push({playerActionId:u,opponentActionId:a,nextNodeId:d.nodeId})}return{nodeId:n,name:e.name,description:e.description||e.name,state:Ut(e.situationId,t),playerActions:{actions:r},opponentActions:{actions:c},transitions:l}}function hs(n,e){const t={};function i(s){t[s.nodeId]=s;for(const o of s.transitions)if(o.nextNodeId){const r=e.get(o.nextNodeId);r&&!t[r.nodeId]&&i(r)}}return i(n),t}function ds(n){k.debug("Building game tree:",n.name||n.gameId);const e=ss(n),t=n.initialDynamicState||{resources:[]};function i(r,a){const c=Pt(a),l=`${r}_${c}`,f=os(l,e);if(f)return f;const b=rs(l,r,c,e);if(b)return b;e.creatingNodes.add(l);const u=as(l,a,e);if(u)return u;const h=cs(l,r,a,e);if(h)return h;const d=e.playerComboStarterMap.get(r)||e.opponentComboStarterMap.get(r);if(d){const g=fs(l,d,a,e,i);return Ae(g)?(e.creatingNodes.delete(l),g):(e.nodeMap.set(l,g),e.nodeStateMap.set(l,a),e.creatingNodes.delete(l),g)}const p=e.situationMap.get(r);return p?us(l,p,a,e,i):(e.creatingNodes.delete(l),k.error("Situation not found:",r),{code:"SITUATION_NOT_FOUND",message:`Situation not found: ${r}`,situationId:r})}const s=i(n.rootSituationId,t);if(Ae(s))return k.error("Game tree build failed:",s.message),{success:!1,error:s};const o=hs(s,e.nodeMap);return k.debug("Game tree built successfully, node count:",Object.keys(o).length),{success:!0,gameTree:{id:n.gameId,root:s.nodeId,nodes:o}}}var jt=(n=>(n[n.UNKNOWN=0]="UNKNOWN",n[n.NONE=1]="NONE",n[n.PLAYER_IN_CORNER=2]="PLAYER_IN_CORNER",n[n.OPPONENT_IN_CORNER=3]="OPPONENT_IN_CORNER",n))(jt||{}),J=(n=>(n[n.UNKNOWN=0]="UNKNOWN",n[n.PLAYER_HEALTH=1]="PLAYER_HEALTH",n[n.OPPONENT_HEALTH=2]="OPPONENT_HEALTH",n[n.PLAYER_OD_GAUGE=3]="PLAYER_OD_GAUGE",n[n.OPPONENT_OD_GAUGE=5]="OPPONENT_OD_GAUGE",n[n.PLAYER_SA_GAUGE=4]="PLAYER_SA_GAUGE",n[n.OPPONENT_SA_GAUGE=6]="OPPONENT_SA_GAUGE",n))(J||{}),Gt=(n=>(n[n.UNKNOWN=0]="UNKNOWN",n[n.NORMAL=1]="NORMAL",n[n.OD=2]="OD",n[n.SA1=3]="SA1",n[n.SA2=4]="SA2",n[n.SA3=5]="SA3",n[n.DRIVE_RUSH=6]="DRIVE_RUSH",n[n.PARRY=7]="PARRY",n))(Gt||{});class ps extends P{constructor(){super("nomari.Scenario",[{no:1,name:"game_id",kind:"scalar",T:13},{no:2,name:"name",kind:"scalar",T:9},{no:3,name:"description",kind:"scalar",T:9},{no:4,name:"root_situation_id",kind:"scalar",T:13},{no:5,name:"situations",kind:"message",repeat:2,T:()=>bs},{no:6,name:"terminal_situations",kind:"message",repeat:2,T:()=>ws},{no:7,name:"initial_dynamic_state",kind:"message",T:()=>Rs},{no:8,name:"reward_computation_method",kind:"message",T:()=>Is},{no:13,name:"player",kind:"message",T:()=>wt},{no:14,name:"opponent",kind:"message",T:()=>wt}])}}new ps;class ms extends P{constructor(){super("nomari.Character",[{no:1,name:"name",kind:"scalar",T:9},{no:2,name:"actions",kind:"message",repeat:2,T:()=>zt},{no:3,name:"combo_starters",kind:"message",repeat:2,T:()=>Us}])}}const wt=new ms;class gs extends P{constructor(){super("nomari.Situation",[{no:1,name:"situation_id",kind:"scalar",T:13},{no:2,name:"name",kind:"scalar",T:9},{no:4,name:"player_action_ids",kind:"scalar",repeat:1,T:13},{no:5,name:"opponent_action_ids",kind:"scalar",repeat:1,T:13},{no:6,name:"transitions",kind:"message",repeat:2,T:()=>Fs}])}}const bs=new gs;class ys extends P{constructor(){super("nomari.TerminalSituation",[{no:1,name:"situation_id",kind:"scalar",T:13},{no:2,name:"name",kind:"scalar",T:9},{no:3,name:"description",kind:"scalar",T:9},{no:4,name:"corner_state",kind:"enum",opt:!0,T:()=>["nomari.CornerState",jt,"CORNER_STATE_"]}])}}const ws=new ys;class vs extends P{constructor(){super("nomari.RewardComputationMethod",[{no:1,name:"damage_race",kind:"message",oneof:"method",T:()=>Ts},{no:2,name:"win_probability",kind:"message",oneof:"method",T:()=>Ns}])}}const Is=new vs;class xs extends P{constructor(){super("nomari.RewardComputationMethod.DamageRace",[])}}const Ts=new xs;class Cs extends P{constructor(){super("nomari.RewardComputationMethod.WinProbability",[{no:1,name:"corner_bonus",kind:"scalar",T:1},{no:2,name:"od_gauge_bonus",kind:"scalar",opt:!0,T:1},{no:3,name:"sa_gauge_bonus",kind:"scalar",opt:!0,T:1}])}}const Ns=new Cs;class Os extends P{constructor(){super("nomari.ResourceConsumption",[{no:1,name:"resource_type",kind:"enum",T:()=>["nomari.ResourceType",J,"RESOURCE_TYPE_"]},{no:2,name:"value",kind:"scalar",T:1}])}}const Es=new Os;class _s extends P{constructor(){super("nomari.ResourceRequirement",[{no:1,name:"resource_type",kind:"enum",T:()=>["nomari.ResourceType",J,"RESOURCE_TYPE_"]},{no:2,name:"value",kind:"scalar",T:1}])}}const As=new _s;class Ss extends P{constructor(){super("nomari.DynamicState",[{no:1,name:"resources",kind:"message",repeat:2,T:()=>ks}])}}const Rs=new Ss;class Bs extends P{constructor(){super("nomari.DynamicState.Resource",[{no:1,name:"resource_type",kind:"enum",T:()=>["nomari.ResourceType",J,"RESOURCE_TYPE_"]},{no:2,name:"value",kind:"scalar",T:1}])}}const ks=new Bs;class Vs extends P{constructor(){super("nomari.PlayerActions",[{no:1,name:"actions",kind:"message",repeat:2,T:()=>zt}])}}new Vs;class Ps extends P{constructor(){super("nomari.Action",[{no:1,name:"action_id",kind:"scalar",T:13},{no:2,name:"name",kind:"scalar",T:9},{no:3,name:"description",kind:"scalar",T:9},{no:4,name:"action_type",kind:"enum",T:()=>["nomari.ActionType",Gt,"ACTION_TYPE_"]}])}}const zt=new Ps;class Ms extends P{constructor(){super("nomari.Transition",[{no:1,name:"player_action_id",kind:"scalar",T:13},{no:2,name:"opponent_action_id",kind:"scalar",T:13},{no:3,name:"next_situation_id",kind:"scalar",T:13}])}}const Fs=new Ms;class Ls extends P{constructor(){super("nomari.ComboRoute",[{no:1,name:"name",kind:"scalar",T:9},{no:2,name:"requirements",kind:"message",repeat:2,T:()=>As},{no:3,name:"consumptions",kind:"message",repeat:2,T:()=>Es},{no:4,name:"next_situation_id",kind:"scalar",T:13}])}}const Ds=new Ls;class $s extends P{constructor(){super("nomari.ComboStarter",[{no:1,name:"situation_id",kind:"scalar",T:13},{no:2,name:"name",kind:"scalar",T:9},{no:3,name:"description",kind:"scalar",T:9},{no:5,name:"starter_action_id",kind:"scalar",opt:!0,T:9},{no:4,name:"routes",kind:"message",repeat:2,T:()=>Ds}])}}const Us=new $s;function js(n,e){const t=e.state.situation_id;if(t===void 0)throw new Error("Node does not have a situation_id");return{...n,rootSituationId:t,initialDynamicState:Gs(e)}}function Gs(n){return{resources:[{resourceType:J.PLAYER_HEALTH,value:n.state.playerHealth},{resourceType:J.OPPONENT_HEALTH,value:n.state.opponentHealth},{resourceType:J.PLAYER_OD_GAUGE,value:n.state.playerOd},{resourceType:J.OPPONENT_OD_GAUGE,value:n.state.opponentOd},{resourceType:J.PLAYER_SA_GAUGE,value:n.state.playerSa},{resourceType:J.OPPONENT_SA_GAUGE,value:n.state.opponentSa}]}}function zs(n,e,t){return{resources:n.resources.map(s=>s.resourceType===e?{...s,value:t}:{...s})}}function Ys(n,e,t){const i=[];for(let s=n;s<=e;s+=t)i.push(s);return i}let ze=!1;function ue(n){self.postMessage(n)}function Hs(n,e){const t=e.nodes[e.root];if(!t)return{playerStrategies:[],opponentStrategies:[]};const i=[],s=[],o=n.getAverageStrategy(e.root);if(t.playerActions)for(const a of t.playerActions.actions){const c=o?.get(a.actionId)??0;i.push({actionId:a.actionId,name:a.name,probability:c})}const r=n.getAverageOpponentStrategy(e.root);if(t.opponentActions)for(const a of t.opponentActions.actions){const c=r?.get(a.actionId)??0;s.push({actionId:a.actionId,name:a.name,probability:c})}return{playerStrategies:i,opponentStrategies:s}}async function Ws(n,e,t){ze=!1;const i=js(n,e),s=Ys(t.minValue,t.maxValue,t.stepSize),o=s.length;ue({type:"progress",current:0,total:o});for(let r=0;r<s.length;r++){if(ze){k.info("Sensitivity analysis cancelled");return}const a=s[r],c=zs(i.initialDynamicState,t.resourceType,a),l={...i,initialDynamicState:c},f=ds(l);if(!f.success){k.warn(`Failed to build game tree for parameter value ${a}:`,f.error);continue}const b=new Xn(f.gameTree);if(!b.solve()){k.warn(`Failed to solve for parameter value ${a}`);continue}const{playerStrategies:u,opponentStrategies:h}=Hs(b,f.gameTree);ue({type:"result",data:{parameterValue:a,playerStrategies:u,opponentStrategies:h}}),ue({type:"progress",current:r+1,total:o})}ue({type:"complete"})}self.onmessage=async n=>{const e=n.data;switch(e.type){case"start":try{await Ws(e.scenario,e.sourceNode,e.parameterConfig)}catch(t){ue({type:"error",message:t instanceof Error?t.message:"Unknown error"})}break;case"cancel":ze=!0;break}};
