syntax = "proto3";

package nomari;

// Definition of the game scenario
// nomari game tree builder would build a game tree from this scenario.
message Scenario {
  uint32 game_id = 1;

  string name = 2;
  string description = 3;

  // Root situation id of the game tree
  uint32 root_situation_id = 4;

  // Situations of the game
  repeated Situation situations = 5;

  // Terminal situations of the game
  repeated TerminalSituation terminal_situations = 6;

  // Initial dynamic state of the game
  DynamicState initial_dynamic_state = 7;

  // Reward computation method for terminal nodes
  RewardComputationMethod reward_computation_method = 8;

  // Player's combo library (combos when player hits opponent)
  repeated ComboStarter player_combo_starters = 9;

  // Opponent's combo library (combos when opponent hits player)
  repeated ComboStarter opponent_combo_starters = 10;
}

message Situation {
  uint32 situation_id = 1;

  // Human readable description of the situation
  string name = 2;

  // Possible actions for the player
  PlayerActions player_actions = 4;

  // Possible actions for the opponent
  PlayerActions opponent_actions = 5;

  // Transitions to the next nodes based on the player and opponent actions
  repeated Transition transitions = 6;
}

message TerminalSituation {
  uint32 situation_id = 1;

  string name = 2;
  string description = 3;

  // Corner state information for reward computation
  optional CornerState corner_state = 4;
}

enum CornerState {
  CORNER_STATE_UNKNOWN = 0; // Unknown (for compatibility with existing data)
  CORNER_STATE_NONE = 1; // Neither player is in corner
  CORNER_STATE_PLAYER_IN_CORNER = 2; // Player is in corner
  CORNER_STATE_OPPONENT_IN_CORNER = 3; // Opponent is in corner
}

message RewardComputationMethod {
  message DamageRace {
    // No configuration needed at this time
  }
  message WinProbability {
    // Corner bonus: combo damage bonus when opponent is in corner
    // Example: 500 means +500 damage per combo when opponent is cornered
    double corner_bonus = 1;
    // OD gauge bonus: lethal combo damage bonus per OD gauge point
    // player_od * od_gauge_bonus is added to lethal combo damage
    // Default: 0 (no effect)
    optional double od_gauge_bonus = 2;
    // SA gauge bonus: lethal combo damage bonus per SA gauge point
    // player_sa * sa_gauge_bonus is added to lethal combo damage
    // Default: 0 (no effect)
    optional double sa_gauge_bonus = 3;
  }

  oneof method {
    DamageRace damage_race = 1;
    WinProbability win_probability = 2;
  }
}

enum ResourceType {
  RESOURCE_TYPE_UNKNOWN = 0;

  RESOURCE_TYPE_PLAYER_HEALTH = 1;
  RESOURCE_TYPE_OPPONENT_HEALTH = 2;
  RESOURCE_TYPE_PLAYER_OD_GAUGE = 3;
  RESOURCE_TYPE_PLAYER_SA_GAUGE = 4;
  RESOURCE_TYPE_OPPONENT_OD_GAUGE = 5;
  RESOURCE_TYPE_OPPONENT_SA_GAUGE = 6;
}

// Transition from a game node to another game node might consume resources.
message ResourceConsumption {
  ResourceType resource_type = 1;
  double value = 2;
}

// Resource requirement for a transition.
// If the current state does not meet all requirements, the transition is not available.
message ResourceRequirement {
  ResourceType resource_type = 1;
  double value = 2; // Must have >= value to take this transition
}

// Dynamic state of the game like the player and opponent health, etc.
// The game tree builder would create multiple nodes from a single situation with different dynamic states.
message DynamicState {
  message Resource {
    ResourceType resource_type = 1;
    double value = 2;
  }

  repeated Resource resources = 1;
}

message PlayerActions {
  repeated Action actions = 1;
}

message Action {
  uint32 action_id = 1;

  // Name of the action (e.g. "attack", "guard")
  string name = 2;

  // Description of the action (e.g. "attack", "guard")
  string description = 3;

  // TODO: Add resource usage of the action
  // E.g. 'OD attack" would consumes drive.
  // repeated ResourceConsumption resource_consumptions = 4;
}

// Transition to the next node based on the player and opponent actions
message Transition {
  uint32 player_action_id = 1;
  uint32 opponent_action_id = 2;

  // Situation would be reached after the action is taken.
  // Can reference Situation, TerminalSituation, or ComboStarter.
  // In case player/opponent's health becomes 0, the next situation would be overwritten to a terminal situation.
  uint32 next_situation_id = 3;

  // Resource consumptions that occur during this transition (e.g., damage dealt)
  repeated ResourceConsumption resource_consumptions = 4;

  // Resource requirements for this transition.
  // The transition is only available if the current state meets all requirements.
  // Example: SA attack requires SA >= 3 to be available.
  repeated ResourceRequirement resource_requirements = 5;
}

// A branch route within a combo starter.
// Each route has different requirements and effects based on gauge state.
message ComboRoute {
  string name = 1; // e.g., "No gauge", "OD confirm", "SA finisher"

  // Requirements to use this route (must have >= these values)
  repeated ResourceRequirement requirements = 2;

  // Resources consumed by this combo route
  // For player combos: OPPONENT_HEALTH (damage to opponent), PLAYER_OD_GAUGE, etc.
  // For opponent combos: PLAYER_HEALTH (damage to player), OPPONENT_OD_GAUGE, etc.
  repeated ResourceConsumption consumptions = 3;

  // Destination situation after this combo route completes
  uint32 next_situation_id = 4;
}

// A combo starter that can be referenced from Transition.next_situation_id.
// The game-tree-builder will expand this into multiple branches based on
// which ComboRoutes are available given the current gauge state.
message ComboStarter {
  // Unique ID shared with Situation and TerminalSituation
  uint32 situation_id = 1;

  string name = 2; // e.g., "Medium punch starter", "Heavy punch starter"
  string description = 3;

  // Multiple routes that branch from this starter based on gauge requirements
  repeated ComboRoute routes = 4;
}
