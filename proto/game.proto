syntax = "proto3";

// Definition of the game
// Mari game tree builder would build a game tree from this definition.
message GameDefinition {
  string game_id = 1;

  string name = 2;
  string description = 3;

  // Root situation id of the game tree
  string root_situation_id = 4;

  // Situations of the game
  repeated Situation situations = 5;

  // Terminal situations of the game
  repeated TerminalSituation terminal_situations = 6;

  // Initial dynamic state of the game
  DynamicState initial_dynamic_state = 7;
}

message Situation {
  string situation_id = 1;

  // Human readable description of the situation
  string description = 2;

  // Possible actions for the player
  PlayerActions player_actions = 4;
  
  // Possible actions for the opponent
  PlayerActions opponent_actions = 5;

  // Transitions to the next nodes based on the player and opponent actions
  repeated Transition transitions = 6;
}

enum TerminalSituationType {
  TERMINAL_SITUATION_TYPE_UNKNOWN = 0;
  
  // Neutral terminal situation. Like, non Oki situation.
  // Let's calculate rewards at this point.
  TERMINAL_SITUATION_TYPE_NEUTRAL = 1;
  
  // TODO: Do users want to have win, lose, and draw terminal situations?
  // Mari game tree build should create terminal nodes for win/lose/draw automatically.
  /*
  TERMINAL_SITUATION_TYPE_WIN = 2;
  TERMINAL_SITUATION_TYPE_LOSE = 3;
  TERMINAL_SITUATION_TYPE_DRAW = 4;
  */
}

message TerminalSituation {
  string situation_id = 1;
  TerminalSituationType type = 2;

  string name = 3;
  string description = 4;
}

message RewardComputationRule {
  // TODO: Add reward computation rule
  // The reward should be calculated based on the player's probability of winning.
  // It's easy to calculate the probability in case of terminal node type is win or lose.
  // However, for draw, the win probability should be calculated based on both player's remaining resources.
}

enum ResourceType {
  RESOURCE_TYPE_UNKNOWN = 0;

  RESOURCE_TYPE_PLAYER_HEALTH = 1;
  RESOURCE_TYPE_OPPONENT_HEALTH = 2;
}

// Transition from a game node to another game node might consume resources.
message ResourceConsumption {
  ResourceType resource_type = 1;
  double value = 2;
}

// Dynamic state of the game like the player and opponent health, etc.
// The game tree builder would create multiple nodes from a single situation with different dynamic states.
message DynamicState {
  message Resource {
    ResourceType resource_type = 1;
    double value = 2;
  }

  repeated Resource resources = 1;
}

message PlayerActions {
  repeated Action actions = 1;
}

message Action {
  string action_id = 1;
  
  // Name of the action (e.g. "attack", "guard")
  string name = 2;

  // Description of the action (e.g. "attack", "guard")
  string description = 3;

  // TODO: Add resource usage of the action
  // E.g. 'OD attack" would consumes drive.
  // repeated ResourceConsumption resource_consumptions = 4;
}

// Transition to the next node based on the player and opponent actions
message Transition {
  string player_action_id = 1;
  string opponent_action_id = 2;

  // Situation would be reached after the action is taken.
  // In case player/opponent's health becomes 0, the next situation would be overwritten to a terminal situation.
  string next_situation_id = 3;

  // Resource consumptions that occur during this transition (e.g., damage dealt)
  repeated ResourceConsumption resource_consumptions = 4;
}
