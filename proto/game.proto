syntax = "proto3";

package nomari;

// Definition of the game scenario
// nomari game tree builder would build a game tree from this scenario.
message Scenario {
  uint32 game_id = 1;

  string name = 2;
  string description = 3;

  // Root situation id of the game tree
  uint32 root_situation_id = 4;

  // Situations of the game
  repeated Situation situations = 5;

  // Terminal situations of the game
  repeated TerminalSituation terminal_situations = 6;

  // Initial dynamic state of the game
  DynamicState initial_dynamic_state = 7;

  // Reward computation method for terminal nodes
  RewardComputationMethod reward_computation_method = 8;

  Character player = 13;
  Character opponent = 14;
}

// Character definition containing actions and combo starters
message Character {
  string name = 1;

  // Available actions for this character
  repeated Action actions = 2;

  // Combo starters for this character
  repeated ComboStarter combo_starters = 3;
}

message Situation {
  uint32 situation_id = 1;

  // Human readable description of the situation
  string name = 2;

  // Action IDs available for the player (references Scenario.player.actions)
  repeated uint32 player_action_ids = 4;

  // Action IDs available for the opponent (references Scenario.opponent.actions)
  repeated uint32 opponent_action_ids = 5;

  // Transitions to the next nodes based on the player and opponent actions
  repeated Transition transitions = 6;
}

message TerminalSituation {
  uint32 situation_id = 1;

  string name = 2;
  string description = 3;

  // Corner state information for reward computation
  optional CornerState corner_state = 4;
}

enum CornerState {
  CORNER_STATE_UNKNOWN = 0; // Unknown (for compatibility with existing data)
  CORNER_STATE_NONE = 1; // Neither player is in corner
  CORNER_STATE_PLAYER_IN_CORNER = 2; // Player is in corner
  CORNER_STATE_OPPONENT_IN_CORNER = 3; // Opponent is in corner
}

message RewardComputationMethod {
  message DamageRace {
    // No configuration needed at this time
  }
  message WinProbability {
    // Corner bonus: combo damage bonus when opponent is in corner
    // Example: 500 means +500 damage per combo when opponent is cornered
    double corner_bonus = 1;
    // OD gauge bonus: lethal combo damage bonus per OD gauge point
    // player_od * od_gauge_bonus is added to lethal combo damage
    // Default: 0 (no effect)
    optional double od_gauge_bonus = 2;
    // SA gauge bonus: lethal combo damage bonus per SA gauge point
    // player_sa * sa_gauge_bonus is added to lethal combo damage
    // Default: 0 (no effect)
    optional double sa_gauge_bonus = 3;
  }

  oneof method {
    DamageRace damage_race = 1;
    WinProbability win_probability = 2;
  }
}

enum ResourceType {
  RESOURCE_TYPE_UNKNOWN = 0;

  RESOURCE_TYPE_PLAYER_HEALTH = 1;
  RESOURCE_TYPE_OPPONENT_HEALTH = 2;
  RESOURCE_TYPE_PLAYER_OD_GAUGE = 3;
  RESOURCE_TYPE_PLAYER_SA_GAUGE = 4;
  RESOURCE_TYPE_OPPONENT_OD_GAUGE = 5;
  RESOURCE_TYPE_OPPONENT_SA_GAUGE = 6;
}

// Transition from a game node to another game node might consume resources.
message ResourceConsumption {
  ResourceType resource_type = 1;
  double value = 2;
}

// Resource requirement for a transition.
// If the current state does not meet all requirements, the transition is not available.
message ResourceRequirement {
  ResourceType resource_type = 1;
  double value = 2; // Must have >= value to take this transition
}

// Dynamic state of the game like the player and opponent health, etc.
// The game tree builder would create multiple nodes from a single situation with different dynamic states.
message DynamicState {
  message Resource {
    ResourceType resource_type = 1;
    double value = 2;
  }

  repeated Resource resources = 1;
}

message PlayerActions {
  repeated Action actions = 1;
}

// Resource type used by an action
enum ActionType {
  ACTION_TYPE_UNKNOWN = 0; // Unknown (for compatibility)
  ACTION_TYPE_NORMAL = 1; // Normal action (no resource consumption)
  ACTION_TYPE_OD = 2; // OD technique (2 OD gauge)
  ACTION_TYPE_SA1 = 3; // SA Level 1 (1 SA gauge)
  ACTION_TYPE_SA2 = 4; // SA Level 2 (2 SA gauge)
  ACTION_TYPE_SA3 = 5; // SA Level 3 (3 SA gauge)
  ACTION_TYPE_DRIVE_RUSH = 6; // Drive Rush (1 OD gauge)
  ACTION_TYPE_PARRY = 7; // Parry (0.5 OD gauge)
}

message Action {
  uint32 action_id = 1;

  // Name of the action (e.g. "attack", "guard")
  string name = 2;

  // Description of the action (e.g. "attack", "guard")
  string description = 3;

  // Action type (determines gauge consumption)
  ActionType action_type = 4;
}

// Transition to the next node based on the player and opponent actions
message Transition {
  uint32 player_action_id = 1;
  uint32 opponent_action_id = 2;

  // Situation would be reached after the action is taken.
  // Can reference Situation, TerminalSituation, or ComboStarter.
  uint32 next_situation_id = 3;
}

// A branch route within a combo starter.
// Each route has different requirements and effects based on gauge state.
message ComboRoute {
  // e.g., "No gauge", "OD confirm", "SA finisher"
  string name = 1;

  // Requirements to use this route (must have >= these values)
  repeated ResourceRequirement requirements = 2;

  // Resources consumed by this combo route
  // For player combos: OPPONENT_HEALTH (damage to opponent), PLAYER_OD_GAUGE, etc.
  // For opponent combos: PLAYER_HEALTH (damage to player), OPPONENT_OD_GAUGE, etc.
  repeated ResourceConsumption consumptions = 3;

  // Destination situation after this combo route completes
  uint32 next_situation_id = 4;
}

// A combo starter that can be referenced from Transition.next_situation_id.
// The game-tree-builder will expand this into multiple branches based on
// which ComboRoutes are available given the current gauge state.
message ComboStarter {
  // Unique ID shared with Situation and TerminalSituation
  uint32 situation_id = 1;

  // e.g., "Medium punch starter", "Heavy punch starter"
  string name = 2; 
  string description = 3;

  // The action which can start this combo.
  // If not specified, any action can start the combo.
  // It will be used by the sceneario editor to filter valid combo starters for an action.
  optional string starter_action_id = 5;

  // Multiple routes that branch from this starter based on gauge requirements
  repeated ComboRoute routes = 4;
}
