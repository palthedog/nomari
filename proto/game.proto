syntax = "proto3";

// Definition of the game
// nomari game tree builder would build a game tree from this definition.
message GameDefinition {
  uint32 game_id = 1;

  string name = 2;
  string description = 3;

  // Root situation id of the game tree
  uint32 root_situation_id = 4;

  // Situations of the game
  repeated Situation situations = 5;

  // Terminal situations of the game
  repeated TerminalSituation terminal_situations = 6;

  // Initial dynamic state of the game
  DynamicState initial_dynamic_state = 7;

  // Reward computation method for terminal nodes
  RewardComputationMethod reward_computation_method = 8;
}

message Situation {
  uint32 situation_id = 1;

  // Human readable description of the situation
  string description = 2;

  // Possible actions for the player
  PlayerActions player_actions = 4;
  
  // Possible actions for the opponent
  PlayerActions opponent_actions = 5;

  // Transitions to the next nodes based on the player and opponent actions
  repeated Transition transitions = 6;
}

message TerminalSituation {
  uint32 situation_id = 1;

  string name = 2;
  string description = 3;

  // Corner state information for reward computation
  optional CornerState corner_state = 4;
}

enum CornerState {
  CORNER_STATE_UNKNOWN = 0;                 // Unknown (for compatibility with existing data)
  CORNER_STATE_NONE = 1;                    // Neither player is in corner
  CORNER_STATE_PLAYER_IN_CORNER = 2;        // Player is in corner
  CORNER_STATE_OPPONENT_IN_CORNER = 3;      // Opponent is in corner
}

message RewardComputationMethod {
  message DamageRace {
    // No configuration needed at this time
  }
  message WinProbability {
    // Corner penalty for win probability calculation (HP value)
    // Example: 2000 means HP2000 worth of penalty when in corner (20% of max HP 10000)
    double corner_penalty = 1;
  }

  oneof method {
    DamageRace damage_race = 1;
    WinProbability win_probability = 2;
  }
}

enum ResourceType {
  RESOURCE_TYPE_UNKNOWN = 0;

  RESOURCE_TYPE_PLAYER_HEALTH = 1;
  RESOURCE_TYPE_OPPONENT_HEALTH = 2;
}

// Transition from a game node to another game node might consume resources.
message ResourceConsumption {
  ResourceType resource_type = 1;
  double value = 2;
}

// Dynamic state of the game like the player and opponent health, etc.
// The game tree builder would create multiple nodes from a single situation with different dynamic states.
message DynamicState {
  message Resource {
    ResourceType resource_type = 1;
    double value = 2;
  }

  repeated Resource resources = 1;
}

message PlayerActions {
  repeated Action actions = 1;
}

message Action {
  uint32 action_id = 1;
  
  // Name of the action (e.g. "attack", "guard")
  string name = 2;

  // Description of the action (e.g. "attack", "guard")
  string description = 3;

  // TODO: Add resource usage of the action
  // E.g. 'OD attack" would consumes drive.
  // repeated ResourceConsumption resource_consumptions = 4;
}

// Transition to the next node based on the player and opponent actions
message Transition {
  uint32 player_action_id = 1;
  uint32 opponent_action_id = 2;

  // Situation would be reached after the action is taken.
  // In case player/opponent's health becomes 0, the next situation would be overwritten to a terminal situation.
  uint32 next_situation_id = 3;

  // Resource consumptions that occur during this transition (e.g., damage dealt)
  repeated ResourceConsumption resource_consumptions = 4;
}
